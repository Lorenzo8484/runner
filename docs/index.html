<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Jungle Emoji Runner (Three.js)</title>
  <style>
    :root { color-scheme: dark; }
    html,body{height:100%;margin:0;background:#040805;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;overflow:hidden;}
    canvas{display:block;touch-action:none;}

    .hud{position:fixed;top:10px;left:10px;right:10px;display:flex;justify-content:space-between;gap:10px;pointer-events:none;z-index:10;}
    .card{pointer-events:none;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);border-radius:14px;padding:10px 12px;color:#eaf1ff;backdrop-filter:blur(10px);min-width:170px;}
    .row{display:flex;justify-content:space-between;gap:10px;align-items:center;}
    .small{font-size:12px;opacity:.86;line-height:1.2}
    .btn{pointer-events:auto;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.16);color:#eaf1ff;padding:10px 12px;border-radius:14px;font-weight:800;cursor:pointer;user-select:none;}
    .btn:active{transform:scale(.98);}
    .pill{display:inline-flex;align-items:center;gap:8px;margin-top:8px;padding:6px 10px;border-radius:999px;background:rgba(255,255,255,.07);border:1px solid rgba(255,255,255,.12);font-size:12px;white-space:nowrap;}
    .bar{height:6px;width:120px;border-radius:999px;background:rgba(255,255,255,.12);overflow:hidden;}
    .bar>i{display:block;height:100%;width:0%;background:rgba(255,255,255,.78);}

    .life{display:flex;align-items:center;gap:8px;margin-top:8px;}
    .ticks{display:flex;gap:6px;}
    .tick{width:14px;height:10px;border-radius:5px;border:1px solid rgba(255,255,255,.18);background:rgba(255,255,255,.10);}
    .tick.on{background:rgba(255,90,120,.78);border-color:rgba(255,90,120,.55);box-shadow:0 0 10px rgba(255,90,120,.28);}

    .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;padding:16px;
      background:radial-gradient(ellipse at center, rgba(0,0,0,.45), rgba(0,0,0,.88));
      backdrop-filter:blur(10px);z-index:20;}
    .panel{width:min(560px,100%);border-radius:18px;border:1px solid rgba(255,255,255,.16);
      background:rgba(10,14,22,.84);box-shadow:0 18px 60px rgba(0,0,0,.55);padding:16px;color:#eaf1ff;}
    .title{font-size:22px;font-weight:900;margin:4px 0 10px;}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
    .full{grid-column:1/-1;}
    .toggle{display:flex;align-items:center;justify-content:space-between;border:1px solid rgba(255,255,255,.16);
      border-radius:14px;padding:10px 12px;background:rgba(255,255,255,.06);cursor:pointer;user-select:none;}
    .toggle label{font-weight:800;}
    .toggle span{opacity:.85;font-size:12px;}
    .switch{width:44px;height:26px;border-radius:99px;background:rgba(255,255,255,.14);position:relative;border:1px solid rgba(255,255,255,.16);}
    .switch i{position:absolute;top:3px;left:3px;width:20px;height:20px;border-radius:999px;background:rgba(255,255,255,.86);transition:transform .18s ease;}
    .switch.on{background:rgba(140,255,190,.18);border-color:rgba(140,255,190,.24);}
    .switch.on i{transform:translateX(18px);}

    .help{position:fixed;bottom:10px;left:10px;right:10px;display:flex;justify-content:center;pointer-events:none;z-index:10;}
    .help .card{max-width:980px;text-align:center;}

    .stats{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:8px;}
    .stat{border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.06);border-radius:14px;padding:10px 12px;}
    .stat .k{opacity:.78;font-size:12px;}
    .stat .v{font-weight:900;font-size:18px;margin-top:2px;}

    input[type="file"]{display:none;}
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div class="hud">
    <div class="card">
      <div class="row"><div><strong>Score</strong>: <span id="score">0</span></div><div class="small">x<span id="mult">1.0</span></div></div>
      <div class="row"><div><strong>Emoji</strong>: <span id="coins">0</span></div><div class="small">Record: <span id="best">0</span></div></div>
      <div class="small">Velocit√†: <span id="spd">1.00</span>x</div>

      <div class="life">
        <div class="small" style="min-width:44px;">Vita</div>
        <div class="ticks" id="lifeTicks"></div>
      </div>

      <div class="pill" id="pillNone">Power-up: <strong>‚Äî</strong></div>
      <div class="pill" id="pillPower" style="display:none;">
        <span id="pEmoji">üöÄ</span><strong id="pName">Boost</strong>
        <div class="bar"><i id="pBar"></i></div>
      </div>
    </div>

    <div style="display:flex;gap:10px;">
      <button class="btn" id="pause">Pausa</button>
      <button class="btn" id="restart">Restart</button>
    </div>
  </div>

  <div class="help">
    <div class="card small">
      Desktop: ‚Üê ‚Üí, ‚Üë salto, ‚Üì scivolata, P pausa, R restart. ‚Ä¢ Mobile: swipe sx/dx, su (salto), gi√π (scivolata).
    </div>
  </div>

  <!-- MENU (minimal) -->
  <div class="overlay" id="menu">
    <div class="panel">
      <div class="title">Jungle Emoji Runner</div>
      <div class="grid">
        <button class="btn full" id="startBtn">‚ñ∂Ô∏è Inizia</button>

        <div class="toggle full" id="audioToggle">
          <div><label>Suoni</label><br/><span>On/Off</span></div>
          <div class="switch on" id="audioSwitch"><i></i></div>
        </div>

        <div class="toggle full" id="qualityToggle">
          <div><label>Qualit√†</label><br/><span>Alto / Medio</span></div>
          <div class="switch on" id="qualitySwitch"><i></i></div>
        </div>

        <button class="btn full" id="loadRunnerBtn">üèÉ Carica runner (.glb)</button>
        <input id="runnerFile" type="file" accept=".glb,.gltf" />

        <button class="btn full" id="loadObstacleBtn">ü™µ Carica ostacoli (.glb)</button>
        <input id="obstacleFiles" type="file" accept=".glb,.gltf" multiple />

        <button class="btn full" id="loadTreeBtn">üå¥ Carica albero (.glb)</button>
        <input id="treeFile" type="file" accept=".glb,.gltf" />

        <div class="toggle full">
          <div><label>Record</label><br/><span>Salvato in locale</span></div>
          <div style="font-weight:900;font-size:18px;" id="bestBig">0</div>
        </div>
      </div>
    </div>
  </div>

  <!-- GAME OVER -->
  <div class="overlay" id="gameover" style="display:none;">
    <div class="panel">
      <div class="title">Game Over</div>
      <div class="stats">
        <div class="stat"><div class="k">Score</div><div class="v" id="goScore">0</div></div>
        <div class="stat"><div class="k">Emoji raccolte</div><div class="v" id="goCoins">0</div></div>
        <div class="stat"><div class="k">Velocit√† max</div><div class="v" id="goMaxSpd">1.00x</div></div>
        <div class="stat"><div class="k">Tempo</div><div class="v" id="goTime">0:00</div></div>
      </div>

      <div style="display:flex;gap:10px;margin-top:12px;">
        <button class="btn" id="goRetry" style="flex:1;">üîÅ Riprova</button>
        <button class="btn" id="goMenu" style="flex:1;">‚ò∞ Menu</button>
      </div>

      <div class="small" style="opacity:.78;margin-top:10px;">
        Vita: 5 tacche (parti sempre con 3). Cuori ‚ù§Ô∏è pi√π frequenti per recuperare vita.
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    const IS_IOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

    // ---------- UI
    const scoreEl = document.getElementById('score');
    const coinsEl = document.getElementById('coins');
    const bestEl  = document.getElementById('best');
    const bestBig = document.getElementById('bestBig');
    const spdEl   = document.getElementById('spd');
    const multEl  = document.getElementById('mult');

    const lifeTicks = document.getElementById('lifeTicks');

    const pillNone = document.getElementById('pillNone');
    const pillPower= document.getElementById('pillPower');
    const pEmoji   = document.getElementById('pEmoji');
    const pName    = document.getElementById('pName');
    const pBar     = document.getElementById('pBar');

    const menu = document.getElementById('menu');
    const startBtn = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restart');
    const pauseBtn   = document.getElementById('pause');

    const gameover = document.getElementById('gameover');
    const goScore = document.getElementById('goScore');
    const goCoins = document.getElementById('goCoins');
    const goMaxSpd= document.getElementById('goMaxSpd');
    const goTime  = document.getElementById('goTime');
    const goRetry = document.getElementById('goRetry');
    const goMenu  = document.getElementById('goMenu');

    const audioToggle = document.getElementById('audioToggle');
    const audioSwitch = document.getElementById('audioSwitch');
    const qualityToggle = document.getElementById('qualityToggle');
    const qualitySwitch = document.getElementById('qualitySwitch');

    const loadRunnerBtn = document.getElementById('loadRunnerBtn');
    const runnerFile = document.getElementById('runnerFile');
    const loadObstacleBtn = document.getElementById('loadObstacleBtn');
    const obstacleFiles = document.getElementById('obstacleFiles');
    const loadTreeBtn = document.getElementById('loadTreeBtn');
    const treeFile = document.getElementById('treeFile');

    const rnd=(a,b)=>a+Math.random()*(b-a);
    const rndi=(a,b)=>Math.floor(rnd(a,b+1));
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp=(a,b,t)=>a+(b-a)*t;

    function toggleSwitch(el,on){ el.classList.toggle('on',!!on); return on; }
    function menuIsOpen(){ return menu.style.display !== 'none'; }
    function fmtTime(sec){
      sec = Math.max(0, sec|0);
      const m = (sec/60)|0;
      const s = sec%60;
      return `${m}:${String(s).padStart(2,'0')}`;
    }

    // ---------- Life UI
    const LIVES_MAX = 5;
    function buildLifeUI(){
      lifeTicks.innerHTML = '';
      for(let i=0;i<LIVES_MAX;i++){
        const d=document.createElement('div');
        d.className='tick';
        lifeTicks.appendChild(d);
      }
    }
    buildLifeUI();
    function renderLife(lives){
      const kids=[...lifeTicks.children];
      for(let i=0;i<kids.length;i++){
        kids[i].classList.toggle('on', i < lives);
      }
    }

    // ---------- Audio (fallback)
    let audioEnabled=true;
    let audioReady=false;
    let actx=null, master=null;
    let engineGain=null, engineOscA=null, engineOscB=null, engineFilter=null, engineNoise=null;

    function initAudio(){
      if(audioReady) return;
      try{
        actx = new (window.AudioContext||window.webkitAudioContext)();
        master = actx.createGain();
        master.gain.value = 0.45;
        master.connect(actx.destination);

        engineGain = actx.createGain(); engineGain.gain.value=0.0;
        engineFilter = actx.createBiquadFilter(); engineFilter.type='lowpass'; engineFilter.frequency.value=220;
        engineOscA = actx.createOscillator(); engineOscA.type='sawtooth'; engineOscA.frequency.value=60;
        engineOscB = actx.createOscillator(); engineOscB.type='square'; engineOscB.frequency.value=30;

        const noiseBuf = actx.createBuffer(1, actx.sampleRate*2, actx.sampleRate);
        const data = noiseBuf.getChannelData(0);
        for(let i=0;i<data.length;i++) data[i]=(Math.random()*2-1)*0.16;
        engineNoise = actx.createBufferSource(); engineNoise.buffer=noiseBuf; engineNoise.loop=true;

        const noiseHP = actx.createBiquadFilter(); noiseHP.type='highpass'; noiseHP.frequency.value=160;

        const mix = actx.createGain(); mix.gain.value=0.14;
        engineOscA.connect(mix); engineOscB.connect(mix);
        engineNoise.connect(noiseHP); noiseHP.connect(mix);
        mix.connect(engineFilter);
        engineFilter.connect(engineGain);
        engineGain.connect(master);

        engineOscA.start(); engineOscB.start(); engineNoise.start();
        audioReady=true;
      }catch(e){
        audioEnabled=false;
      }
      audioSwitch.classList.toggle('on',!!audioEnabled);
    }

    function setEngine(on){
      if(!audioEnabled) return;
      initAudio(); if(!audioReady) return;
      const t=actx.currentTime;
      const target= on ? 0.13 : 0.0;
      engineGain.gain.cancelScheduledValues(t);
      engineGain.gain.setValueAtTime(engineGain.gain.value,t);
      engineGain.gain.linearRampToValueAtTime(target, t+(on?0.25:0.15));
    }

    function updateEngine(speedMul){
      if(!audioEnabled||!audioReady) return;
      const t=actx.currentTime;
      const rpm = 1 + speedMul*0.35;
      engineOscA.frequency.setValueAtTime(60*rpm, t);
      engineOscB.frequency.setValueAtTime(30*rpm, t);
      engineFilter.frequency.setValueAtTime(220 + 170*rpm, t);
    }

    function beep(type,freq,dur=0.08,g=0.14){
      if(!audioEnabled) return;
      initAudio(); if(!audioReady) return;
      const t0=actx.currentTime;
      const o=actx.createOscillator();
      const gg=actx.createGain();
      o.type=type; o.frequency.setValueAtTime(freq,t0);
      gg.gain.setValueAtTime(0.0001,t0);
      gg.gain.exponentialRampToValueAtTime(g,t0+0.012);
      gg.gain.exponentialRampToValueAtTime(0.0001,t0+dur);
      o.connect(gg); gg.connect(master);
      o.start(t0); o.stop(t0+dur+0.02);
    }

    function playFootstep(){ beep('sine', 145 + Math.random()*35, 0.040, 0.030); }
    function playCoin(){ beep('triangle', 900, 0.055, 0.08); beep('sine', 1320, 0.06, 0.05); }
    function playPower(){ beep('sawtooth', 520, 0.09, 0.07); beep('triangle', 880, 0.10, 0.05); }
    function playHit(){ beep('square', 120, 0.14, 0.10); }
    function playHeart(){ beep('sine', 520, 0.07, 0.10); beep('sine', 820, 0.07, 0.07); }
    function playInvincible(){ beep('triangle', 980, 0.08, 0.10); beep('sine', 1500, 0.10, 0.07); }

    // ---------- Renderer / Scene
    const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    if(IS_IOS){
      renderer.physicallyCorrectLights = false;
      renderer.toneMapping = THREE.LinearToneMapping;
      renderer.toneMappingExposure = 1.8;
    }else{
      renderer.physicallyCorrectLights = true;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.05;
    }

    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x08120b);

    if(IS_IOS){
      scene.fog = new THREE.Fog(0x08120b, 18, 60);
    }else{
      scene.fog = new THREE.FogExp2(0x06110a, 0.040);
    }

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 240);
    camera.position.set(0, 2.2, 5.8);

    const sun = new THREE.DirectionalLight(0xf3ffe6, IS_IOS ? 2.8 : 1.9);
    sun.position.set(5, 9, 4);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048,2048);
    sun.shadow.camera.near = 0.5;
    sun.shadow.camera.far = 50;
    sun.shadow.camera.left = -9;
    sun.shadow.camera.right=  9;
    sun.shadow.camera.top  =  9;
    sun.shadow.camera.bottom=-9;
    sun.shadow.bias = -0.00028;
    scene.add(sun);

    scene.add(new THREE.HemisphereLight(0xaaffdd, 0x081209, IS_IOS ? 1.05 : 0.70));
    scene.add(new THREE.AmbientLight(0xffffff, IS_IOS ? 0.65 : 0.18));

    const front = new THREE.DirectionalLight(0xffffff, IS_IOS ? 1.35 : 0.45);
    front.position.set(0, 3.5, 6);
    scene.add(front);

    let composer=null, bloomPass=null, afterPass=null;
    if(!IS_IOS){
      composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));
      bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.18, 0.22, 0.92);
      composer.addPass(bloomPass);
      afterPass = new AfterimagePass();
      afterPass.uniforms['damp'].value = 0.94;
      composer.addPass(afterPass);
    }

    // Contact shadow
    function makeContactShadowTexture(size=512){
      const c=document.createElement('canvas'); c.width=c.height=size;
      const g=c.getContext('2d');
      g.clearRect(0,0,size,size);
      const grd=g.createRadialGradient(size/2,size/2,0, size/2,size/2,size*0.48);
      grd.addColorStop(0,'rgba(0,0,0,0.40)');
      grd.addColorStop(0.55,'rgba(0,0,0,0.10)');
      grd.addColorStop(1,'rgba(0,0,0,0)');
      g.fillStyle=grd; g.fillRect(0,0,size,size);
      const t=new THREE.CanvasTexture(c); t.colorSpace=THREE.SRGBColorSpace;
      return t;
    }
    const contactTex = makeContactShadowTexture(512);
    const contact = new THREE.Mesh(
      new THREE.PlaneGeometry(1.5,1.5),
      new THREE.MeshBasicMaterial({ map:contactTex, transparent:true, opacity:0.58, depthWrite:false })
    );
    contact.rotation.x = -Math.PI/2;
    contact.position.set(0, 0.02, 0.2);
    scene.add(contact);

    // ---------- World layout
    const lanesX = [-1.15, 0, 1.15];
    const segLen = 9.0, segCount = 9, roadWidth = 4.2;

    function makeDirtTexture(size=512){
      const c=document.createElement('canvas'); c.width=c.height=size;
      const g=c.getContext('2d');
      g.fillStyle='#3b3a28'; g.fillRect(0,0,size,size);
      for(let i=0;i<12000;i++){
        const x=Math.random()*size, y=Math.random()*size;
        const v=rndi(50,120);
        g.fillStyle=`rgba(${v+35},${v+20},${v},${rnd(0.05,0.18)})`;
        g.fillRect(x,y,1,1);
      }
      const t=new THREE.CanvasTexture(c);
      t.colorSpace=THREE.SRGBColorSpace;
      t.wrapS=t.wrapT=THREE.RepeatWrapping;
      t.repeat.set(2.0, 10.0);
      return t;
    }
    const dirtTex = makeDirtTexture(1024);

    const roadMat = new THREE.MeshStandardMaterial({
      map: dirtTex,
      roughness: 0.95,
      metalness: 0.0,
      color: new THREE.Color(0x7f8a62)
    });

    const segments=[];
    for(let i=0;i<segCount;i++){
      const geo = new THREE.PlaneGeometry(roadWidth, segLen);
      geo.rotateX(-Math.PI/2);
      const mesh = new THREE.Mesh(geo, roadMat);
      mesh.position.set(0, 0, -i*segLen);
      mesh.receiveShadow=true;
      scene.add(mesh);
      segments.push(mesh);
    }

    const sideGeo = new THREE.PlaneGeometry(40, segLen*segCount);
    sideGeo.rotateX(-Math.PI/2);
    const sideMat = new THREE.MeshStandardMaterial({ color:0x0d2416, roughness:1, metalness:0 });
    const side = new THREE.Mesh(sideGeo, sideMat);
    side.position.set(0, -0.02, -segLen*segCount/2 + segLen/2);
    side.receiveShadow = true;
    scene.add(side);

    // Jungle props
    let treeProto=null;
    function makeTreePrimitive(){
      const g = new THREE.Group();
      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.11, 0.16, 1.6, 10),
        new THREE.MeshStandardMaterial({ color:0x4a3523, roughness:1, metalness:0 })
      );
      trunk.castShadow=true; trunk.receiveShadow=true;
      trunk.position.y = 0.8;
      g.add(trunk);

      const crown = new THREE.Mesh(
        new THREE.ConeGeometry(0.75, 1.6, 12),
        new THREE.MeshStandardMaterial({ color:0x1c6b33, roughness:1, metalness:0 })
      );
      crown.castShadow=true; crown.receiveShadow=true;
      crown.position.y = 1.9;
      g.add(crown);

      const crown2 = new THREE.Mesh(
        new THREE.ConeGeometry(0.6, 1.3, 12),
        new THREE.MeshStandardMaterial({ color:0x135226, roughness:1, metalness:0 })
      );
      crown2.castShadow=true; crown2.receiveShadow=true;
      crown2.position.y = 2.3;
      g.add(crown2);

      return g;
    }
    treeProto = makeTreePrimitive();

    const jungle = new THREE.Group();
    scene.add(jungle);

    function spawnTree(x,z){
      const obj = treeProto.clone(true);
      obj.position.set(x, 0, z);
      obj.scale.setScalar(rnd(0.8, 1.25));
      obj.rotation.y = rnd(0, Math.PI*2);
      obj.traverse(o=>{ if(o.isMesh){ o.castShadow=true; o.receiveShadow=true; }});
      jungle.add(obj);
      return obj;
    }

    const treePool=[];
    const treeSpacing=2.8;
    const treeSideX = roadWidth/2 + 1.7;
    for(let i=0;i<Math.floor((segLen*segCount)/treeSpacing);i++){
      const z = -i*treeSpacing;
      treePool.push(spawnTree(-treeSideX - rnd(0,1.8), z));
      treePool.push(spawnTree( treeSideX + rnd(0,1.8), z));
      if(Math.random()<0.35){
        const bush = new THREE.Mesh(
          new THREE.SphereGeometry(rnd(0.35,0.65), 10, 8),
          new THREE.MeshStandardMaterial({ color:0x1b6a32, roughness:1, metalness:0 })
        );
        bush.position.set((Math.random()<0.5?-1:1)*(treeSideX-0.4 + rnd(0,1.2)), 0.35, z + rnd(-0.7,0.7));
        bush.castShadow=true; bush.receiveShadow=true;
        jungle.add(bush);
        treePool.push(bush);
      }
    }

    function loopJungle(scroll){
      const wrapZ = segLen*segCount;
      for(const obj of treePool){
        obj.position.z += scroll;
        if(obj.position.z > 6){
          obj.position.z -= wrapZ;
        }
      }
    }

    // ---------- Runner + loader
    const gltfLoader = new GLTFLoader();
    let runner = new THREE.Group();
    scene.add(runner);

    const dummyBody = new THREE.Mesh(
      new THREE.CapsuleGeometry(0.22, 0.55, 8, 16),
      new THREE.MeshStandardMaterial({ color:0x9db79a, roughness:0.65, metalness:0.0 })
    );
    dummyBody.position.y=0.85;
    dummyBody.castShadow=true;
    runner.add(dummyBody);

    const dummyHead = new THREE.Mesh(
      new THREE.SphereGeometry(0.18, 18, 14),
      new THREE.MeshStandardMaterial({ color:0xb7ccb2, roughness:0.6, metalness:0.0 })
    );
    dummyHead.position.set(0, 1.25, 0.05);
    dummyHead.castShadow=true;
    runner.add(dummyHead);

    let mixer=null;

    // Shield ring (per lo scudo)
    let shieldRing = null;
    function attachShieldToRunner(){
      if(shieldRing && shieldRing.parent) shieldRing.parent.remove(shieldRing);
      shieldRing = new THREE.Mesh(
        new THREE.TorusGeometry(0.48, 0.03, 10, 64),
        new THREE.MeshStandardMaterial({
          color:0x1b3a22, metalness:0.1, roughness:0.25,
          emissive:0x44ff88, emissiveIntensity:1.05,
          transparent:true, opacity:0.62
        })
      );
      shieldRing.rotation.x = Math.PI/2;
      shieldRing.position.y = 0.95;
      shieldRing.visible=false;
      runner.add(shieldRing);
    }

    // Bubble (invincibilit√† ‚Äúgrosso‚Äù)
    let fatBubble = null;
    function attachBubbleToRunner(){
      if(fatBubble && fatBubble.parent) fatBubble.parent.remove(fatBubble);
      fatBubble = new THREE.Mesh(
        new THREE.SphereGeometry(0.62, 26, 18),
        new THREE.MeshStandardMaterial({
          color:0x7ee6ff,
          roughness:0.08,
          metalness:0.0,
          emissive:0x3ad6ff,
          emissiveIntensity:0.65,
          transparent:true,
          opacity:0.18
        })
      );
      fatBubble.castShadow=false;
      fatBubble.receiveShadow=false;
      fatBubble.position.y = 0.95;
      fatBubble.visible = false;
      runner.add(fatBubble);
    }

    attachShieldToRunner();
    attachBubbleToRunner();

    function setRunnerTo(obj, animations){
      scene.remove(runner);
      runner = obj;
      runner.traverse(o=>{ if(o.isMesh){ o.castShadow=true; o.receiveShadow=true; }});
      runner.position.set(0,0,0);
      scene.add(runner);

      mixer=null;
      if(animations && animations.length){
        mixer = new THREE.AnimationMixer(runner);
        const a = mixer.clipAction(animations[0]);
        a.play();
      }

      attachShieldToRunner();
      attachBubbleToRunner();
      loadRunnerBtn.textContent = "‚úÖ Runner caricato";
    }

    async function tryLoadRunnerFromPath(){
      try{
        const gltf = await gltfLoader.loadAsync('./assets/models/runner.glb');
        setRunnerTo(gltf.scene, gltf.animations);
      }catch(e){}
    }

    // ---------- Obstacles
    const obstacleProtos=[];
    function addObstacleProto(sceneObj){
      sceneObj.traverse(o=>{ if(o.isMesh){ o.castShadow=true; o.receiveShadow=true; }});
      obstacleProtos.push(sceneObj);
    }
    async function tryLoadObstacleDefaults(){
      const tryOne = async (p)=>{
        try{
          const gltf = await gltfLoader.loadAsync(p);
          addObstacleProto(gltf.scene);
        }catch(e){}
      };
      await tryOne('./assets/models/rock_01.glb');
      await tryOne('./assets/models/log_01.glb');
    }

    function spawnObstacleVisual(){
      if(obstacleProtos.length){
        const proto = obstacleProtos[rndi(0, obstacleProtos.length-1)];
        const obj = proto.clone(true);
        obj.scale.setScalar(rnd(0.45, 0.80));
        obj.rotation.y = rnd(0, Math.PI*2);
        obj.traverse(o=>{ if(o.isMesh){ o.castShadow=true; o.receiveShadow=true; }});
        return obj;
      }
      const box = new THREE.Mesh(
        new THREE.BoxGeometry(rnd(0.6,0.9), rnd(0.7,1.2), rnd(0.6,0.9)),
        new THREE.MeshStandardMaterial({ color:0x6b4b2b, roughness:0.9, metalness:0.02 })
      );
      box.castShadow=true; box.receiveShadow=true;
      return box;
    }

    // ---------- Emoji sprites
    function makeEmojiSprite(emoji, size=256, glow=false){
      const c=document.createElement('canvas'); c.width=c.height=size;
      const g=c.getContext('2d');
      g.clearRect(0,0,size,size);

      g.globalAlpha = glow ? 0.22 : 0.18;
      g.fillStyle = glow ? '#ffffff' : '#cfefff';
      g.beginPath(); g.arc(size/2,size/2,size*(glow?0.38:0.33),0,Math.PI*2); g.fill();

      g.globalAlpha=1;
      g.font=`${size*0.58}px system-ui, Apple Color Emoji, Segoe UI Emoji`;
      g.textAlign='center'; g.textBaseline='middle';
      g.fillText(emoji, size/2, size/2+8);

      const tex=new THREE.CanvasTexture(c);
      tex.colorSpace=THREE.SRGBColorSpace;
      const mat=new THREE.SpriteMaterial({ map:tex, transparent:true });
      const spr=new THREE.Sprite(mat);
      spr.scale.set(0.75,0.75,1);
      return spr;
    }

    // Emoji ‚Äúcibo‚Äù che fanno ingrassare
    const FOOD_SET = new Set(["üçï","üçî","üçü","üå≠","üç©","üç∞","üç¶","üç´","üç™","üçâ","üçì","ü•ù","üçã"]);
    const EMOJIS = ["‚ú®","üçÄ","üî•","üçï","üéØ","üíé","‚ö°Ô∏è","üåà","üçã","‚≠êÔ∏è","üçì","ü•ù","üçî","üçü","üç©"];

    const POWERUPS = [
      { key:"magnet", emoji:"üß≤", name:"Magnete", dur:9.0 },
      { key:"shield", emoji:"üõ°Ô∏è", name:"Scudo",   dur:10.0 },
      { key:"double", emoji:"‚úñÔ∏è2", name:"Doppio",  dur:9.0 },
      { key:"slow",   emoji:"üê¢", name:"Slow-mo",  dur:7.0 },
      { key:"trail",  emoji:"üåü", name:"Emoji Trail", dur:7.0 },
      { key:"boost",  emoji:"üöÄ", name:"Boost",       dur:5.0 }
    ];

    // ---------- Game state
    const BEST_KEY='jungle_runner_best_v3';
    const loadBest=()=>Number(localStorage.getItem(BEST_KEY)||'0')||0;
    const saveBest=(v)=>localStorage.setItem(BEST_KEY,String(v));

    const game = {
      lane:1, targetLane:1,
      y:0, vy:0, jumping:false,
      sliding:false, slideT:0,

      // VELOCIT√Ä: permanente (non aumenta col punteggio)
      baseSpeed: 9.0,

      score:0, coins:0,
      best: loadBest(),

      over:false, paused:true,

      entities: [],
      spawnT:0.30,

      active:null,
      hasShield:false,

      magnet:false,
      double:false,
      slow:false,
      boost:false,
      trail:false,

      lives: 3,
      invuln: 0.0,
      stun: 0.0,
      runTime: 0.0,

      // Cuori pi√π frequenti
      nextHeartAt: 20,      // ‚ù§Ô∏è ogni 20 emoji (invece di 50)

      // ‚ÄúGrosso‚Äù da cibo
      foodCount: 0,         // cresce fino a 10
      fatInv: 0.0,          // invincibilit√† 10s quando foodCount==10
      runnerScale: 1.0,     // scala attuale (smooth)
      runnerScaleTarget: 1.0
    };

    bestEl.textContent = String(game.best);
    bestBig.textContent = String(game.best);
    renderLife(game.lives);

    function setActivePower(p){
      game.active = { ...p, t:p.dur };
      pillNone.style.display='none';
      pillPower.style.display='inline-flex';
      pEmoji.textContent = p.emoji;
      pName.textContent  = p.name;
      playPower();
    }

    function clearActivePower(){
      game.active=null;
      pillNone.style.display='inline-flex';
      pillPower.style.display='none';
      pBar.style.width='0%';
      game.magnet=false; game.double=false; game.slow=false; game.boost=false; game.trail=false;
    }

    function applyPowerFlags(){
      game.magnet=false; game.double=false; game.slow=false; game.boost=false; game.trail=false;
      if(!game.active) return;
      if(game.active.key==='magnet') game.magnet=true;
      if(game.active.key==='double') game.double=true;
      if(game.active.key==='slow')   game.slow=true;
      if(game.active.key==='boost')  game.boost=true;
      if(game.active.key==='trail')  game.trail=true;
      if(game.active.key==='shield') game.hasShield=true;
    }

    function openMenu(){
      menu.style.display='flex';
      gameover.style.display='none';
      game.paused=true;
      bestBig.textContent=String(game.best);
      setEngine(false);
    }
    function closeMenu(){ menu.style.display='none'; }

    function openGameOver(){
      gameover.style.display='flex';
      menu.style.display='none';
      setEngine(false);

      goScore.textContent = String(Math.floor(game.score));
      goCoins.textContent = String(game.coins);
      goMaxSpd.textContent = `1.00x`; // velocit√† permanente
      goTime.textContent = fmtTime(game.runTime);

      if(game.score>game.best){ game.best=Math.floor(game.score); saveBest(game.best); }
      bestEl.textContent = String(game.best);
      bestBig.textContent = String(game.best);
    }

    function resetRun(full=true){
      game.lane=1; game.targetLane=1;
      game.y=0; game.vy=0; game.jumping=false;
      game.sliding=false; game.slideT=0;

      game.baseSpeed=9.0;
      game.score=0; game.coins=0;
      game.spawnT=0.30;

      game.invuln=0.0; game.stun=0.0;
      game.runTime=0.0;

      for(const e of game.entities) scene.remove(e.obj);
      game.entities.length=0;

      clearActivePower();
      game.hasShield=false;
      if(shieldRing) shieldRing.visible=false;

      // cuori frequenti
      game.nextHeartAt = 20;

      // cibo / grandezza
      game.foodCount = 0;
      game.fatInv = 0.0;
      game.runnerScale = 1.0;
      game.runnerScaleTarget = 1.0;
      if(fatBubble) fatBubble.visible = false;

      if(full){
        game.lives = 3;
      }
      renderLife(game.lives);

      game.over=false;
      game.paused=false;
      pauseBtn.textContent='Pausa';
      closeMenu();
      gameover.style.display='none';
      setEngine(true);
    }

    function togglePause(){
      if(game.over) return;
      game.paused=!game.paused;
      pauseBtn.textContent = game.paused ? 'Riprendi' : 'Pausa';
      setEngine(!game.paused && !menuIsOpen() && gameover.style.display==='none');
    }

    // ---------- Spawning
    function spawnRow(){
      const blocked=new Set();
      const oCount = Math.random()<0.10 ? 2 : rndi(0,2);
      while(blocked.size<oCount) blocked.add(rndi(0,2));
      if(blocked.size===3) blocked.delete(rndi(0,2));

      const coinLanes=new Set();
      const cCount = rndi(1,2);
      while(coinLanes.size<cCount) coinLanes.add(rndi(0,2));

      const z0 = -48 - rnd(0,18);

      blocked.forEach(l=>{
        const kind = (Math.random()<0.5?'low':'high');
        const obj = spawnObstacleVisual();
        obj.position.set(lanesX[l], 0.65, z0);
        scene.add(obj);
        game.entities.push({ type:'obst', lane:l, z:z0, obj, kind });
      });

      coinLanes.forEach(l=>{
        const em = EMOJIS[rndi(0,EMOJIS.length-1)];
        const spr = makeEmojiSprite(em);
        spr.userData.emoji = em; // per cibo
        spr.position.set(lanesX[l], 1.10, z0 - rnd(0,3));
        spr.scale.set(0.78,0.78,1);
        scene.add(spr);
        game.entities.push({ type:'coin', lane:l, z:spr.position.z, obj:spr, emoji: em });
      });

      if(Math.random()<0.12){
        const p = POWERUPS[rndi(0,POWERUPS.length-1)];
        const lane=rndi(0,2);
        const spr=makeEmojiSprite(p.emoji, 256, true);
        spr.position.set(lanesX[lane], 1.18, z0 - rnd(1,5));
        spr.scale.set(0.88,0.88,1);
        scene.add(spr);
        game.entities.push({ type:'power', lane, z:spr.position.z, obj:spr, key:p.key, dur:p.dur, name:p.name, emoji:p.emoji });
      }
    }

    function spawnHeart(){
      if(game.lives >= LIVES_MAX) return;

      const z0 = -50 - rnd(0,14);
      const lane = rndi(0,2);

      // ‚ù§Ô∏è pi√π ‚Äúspesso‚Äù: pi√π grande + pi√π glow
      const spr = makeEmojiSprite('‚ù§Ô∏è', 420, true);
      spr.position.set(lanesX[lane], 1.28, z0);
      spr.scale.set(1.45, 1.45, 1);
      scene.add(spr);
      game.entities.push({ type:'heart', lane, z:spr.position.z, obj:spr });
    }

    let trailSpawnT = 0.0;
    function spawnTrailCoins(){
      const z0 = -30 - rnd(0,6);
      for(let l=0;l<3;l++){
        const em = EMOJIS[rndi(0,EMOJIS.length-1)];
        const spr = makeEmojiSprite(em);
        spr.userData.emoji = em;
        spr.position.set(lanesX[l], 1.10, z0 - l*0.9);
        spr.scale.set(0.78,0.78,1);
        scene.add(spr);
        game.entities.push({ type:'coin', lane:l, z:spr.position.z, obj:spr, emoji: em, trail:true });
      }
    }

    // ---------- Controls
    let tiltTarget=0, camRoll=0, camShake=0;

    function moveLane(dir){
      if(game.over||game.paused) return;
      game.targetLane = clamp(game.targetLane+dir,0,2);
      game.lane = game.targetLane;
      tiltTarget = clamp(tiltTarget + dir*0.18, -0.22, 0.22);
    }
    function jump(){
      if(game.over||game.paused) return;
      if(!game.jumping && game.y>=-0.001){
        game.jumping=true;
        game.vy = -7.8;
      }
    }
    function slide(){
      if(game.over||game.paused) return;
      game.sliding=true;
      game.slideT=0.45;
    }

    window.addEventListener('keydown', (e)=>{
      const k=e.key.toLowerCase();
      if(k==='arrowleft') moveLane(-1);
      if(k==='arrowright') moveLane(1);
      if(k==='arrowup' || k===' ') jump();
      if(k==='arrowdown') slide();
      if(k==='p') togglePause();
      if(k==='r') { initAudio(); resetRun(true); }
      if(k==='escape') openMenu();
    });

    let touchStart=null;
    renderer.domElement.addEventListener('pointerdown',(e)=>{
      initAudio();
      renderer.domElement.setPointerCapture(e.pointerId);
      touchStart={x:e.clientX,y:e.clientY,t:performance.now()};
    });
    renderer.domElement.addEventListener('pointerup',(e)=>{
      if(!touchStart) return;
      const dx=e.clientX-touchStart.x, dy=e.clientY-touchStart.y;
      const adx=Math.abs(dx), ady=Math.abs(dy);
      touchStart=null;
      const min=30;
      if(adx<min && ady<min) return;
      if(adx>ady) moveLane(dx>0?1:-1);
      else { if(dy<0) jump(); else slide(); }
    });

    startBtn.addEventListener('click', ()=>{ initAudio(); resetRun(true); });
    restartBtn.addEventListener('click', ()=>{ initAudio(); resetRun(true); });
    pauseBtn.addEventListener('click', ()=>{ initAudio(); togglePause(); });

    goRetry.addEventListener('click', ()=>{ initAudio(); resetRun(true); });
    goMenu.addEventListener('click', ()=>{ openMenu(); });

    let highQuality=true;
    qualityToggle.addEventListener('click', ()=>{
      highQuality=!highQuality;
      toggleSwitch(qualitySwitch,highQuality);
      const pr = highQuality ? Math.min(2, window.devicePixelRatio||1) : 1;
      renderer.setPixelRatio(pr);
      if(composer) composer.setPixelRatio(pr);
    });

    audioToggle.addEventListener('click', ()=>{
      initAudio();
      audioEnabled=!audioEnabled;
      toggleSwitch(audioSwitch,audioEnabled);
      if(!audioEnabled) setEngine(false);
      else setEngine(!game.paused && !menuIsOpen() && gameover.style.display==='none');
    });

    // File loaders
    loadRunnerBtn.addEventListener('click', ()=> runnerFile.click());
    runnerFile.addEventListener('change', async (e)=>{
      const f=e.target.files?.[0]; if(!f) return;
      const url=URL.createObjectURL(f);
      try{
        const gltf=await gltfLoader.loadAsync(url);
        setRunnerTo(gltf.scene, gltf.animations);
      } finally { URL.revokeObjectURL(url); }
    });

    loadObstacleBtn.addEventListener('click', ()=> obstacleFiles.click());
    obstacleFiles.addEventListener('change', async (e)=>{
      const files=[...(e.target.files||[])];
      if(!files.length) return;
      for(const f of files){
        const url=URL.createObjectURL(f);
        try{
          const gltf=await gltfLoader.loadAsync(url);
          addObstacleProto(gltf.scene);
        } finally { URL.revokeObjectURL(url); }
      }
      loadObstacleBtn.textContent = `‚úÖ Ostacoli (${obstacleProtos.length})`;
    });

    loadTreeBtn.addEventListener('click', ()=> treeFile.click());
    treeFile.addEventListener('change', async (e)=>{
      const f=e.target.files?.[0]; if(!f) return;
      const url=URL.createObjectURL(f);
      try{
        const gltf=await gltfLoader.loadAsync(url);
        treeProto = gltf.scene;
        treeProto.traverse(o=>{ if(o.isMesh){ o.castShadow=true; o.receiveShadow=true; }});
        for(const obj of treePool){ obj.parent && obj.parent.remove(obj); }
        treePool.length=0;
        const count = Math.floor((segLen*segCount)/treeSpacing);
        for(let i=0;i<count;i++){
          const z=-i*treeSpacing;

          const left = treeProto.clone(true);
          left.position.set(-treeSideX - rnd(0,1.8), 0, z);
          left.scale.setScalar(rnd(0.55, 0.95));
          left.rotation.y=rnd(0,Math.PI*2);
          left.traverse(o=>{ if(o.isMesh){ o.castShadow=true; o.receiveShadow=true; }});
          jungle.add(left); treePool.push(left);

          const right = treeProto.clone(true);
          right.position.set(treeSideX + rnd(0,1.8), 0, z);
          right.scale.setScalar(rnd(0.55, 0.95));
          right.rotation.y=rnd(0,Math.PI*2);
          right.traverse(o=>{ if(o.isMesh){ o.castShadow=true; o.receiveShadow=true; }});
          jungle.add(right); treePool.push(right);
        }
        loadTreeBtn.textContent = "‚úÖ Alberi";
      } finally { URL.revokeObjectURL(url); }
    });

    // ---------- Damage / Invincibility
    function setRunnerFlash(hex=0xff3355, intensity=1.2){
      runner.traverse(o=>{
        if(o.isMesh && o.material){
          o.material.emissive = o.material.emissive || new THREE.Color(0x000000);
          o.material.emissiveIntensity = intensity;
          o.material.emissive.setHex(hex);
        }
      });
    }
    function clearFlash(){
      runner.traverse(o=>{
        if(o.isMesh && o.material && o.material.emissive){
          o.material.emissiveIntensity = 0.0;
        }
      });
    }

    function startFatInvincible(){
      game.fatInv = 10.0;           // 10 secondi
      game.invuln = Math.max(game.invuln, 10.0);
      if(fatBubble) fatBubble.visible = true;
      playInvincible();
    }

    function damage(){
      // invincibile (fat inv) => non prendi danno
      if(game.fatInv > 0) return;

      // scudo annulla un colpo
      if(game.hasShield){
        game.hasShield=false;
        if(shieldRing) shieldRing.visible=false;
        playHit();
        camShake = 0.18;
        game.invuln = 0.8;
        setRunnerFlash(0x44ff88, 0.9);
        return;
      }

      game.lives = Math.max(0, game.lives - 1);
      renderLife(game.lives);

      playHit();
      camShake = 0.28;
      game.invuln = 1.25;
      game.stun = 0.22;
      setRunnerFlash(0xff3355, 1.2);

      if(game.lives <= 0){
        game.over=true;
        game.paused=true;
        openGameOver();
      }
    }

    // ---------- Update loop
    let tPrev=performance.now();
    let stepTimer=0;

    function update(dt, tNow){
      if(game.paused) return;

      game.runTime += dt;

      // invuln / stun timers
      if(game.invuln > 0){
        game.invuln = Math.max(0, game.invuln - dt);
        if(game.invuln===0) clearFlash();
      }
      if(game.stun > 0){
        game.stun = Math.max(0, game.stun - dt);
        dt *= 0.18;
      }

      // fat invincibility timer (se attiva)
      if(game.fatInv > 0){
        game.fatInv = Math.max(0, game.fatInv - dt);
        if(game.fatInv === 0){
          // torna normale: reset cibo e rimpicciolisce piano piano
          game.foodCount = 0;
          game.runnerScaleTarget = 1.0;
          if(fatBubble) fatBubble.visible = false;
          clearFlash();
        } else {
          // piccolo pulsare bolla
          if(fatBubble){
            const p = 1.0 + 0.06*Math.sin(tNow*0.01);
            fatBubble.scale.set(p,p,p);
            fatBubble.material.opacity = 0.16 + 0.05*Math.sin(tNow*0.009);
          }
          setRunnerFlash(0x3ad6ff, 0.55);
        }
      }

      // powers
      if(game.active){
        game.active.t -= dt;
        applyPowerFlags();
        const pct = clamp((game.active.t/game.active.dur)*100,0,100);
        pBar.style.width = pct.toFixed(1)+'%';
        if(game.active.key==='shield' && shieldRing) shieldRing.visible=true;
        if(game.active.t<=0){
          clearActivePower();
          if(shieldRing) shieldRing.visible = game.hasShield;
        }
      } else {
        game.magnet=false; game.double=false; game.slow=false; game.boost=false; game.trail=false;
      }

      // SLOW-MO quando salti (1/4) + camera ‚Äúzoom in‚Äù
      const inAir = (game.y < -0.01) || game.jumping;
      let timeScale = 1.0;
      if(game.slow) timeScale *= 0.70;
      if(inAir) timeScale *= 0.25; // ‚úÖ 1/4 durante salto

      // boost (solo temporaneo)
      const boostMul = game.boost ? 1.35 : 1.0;

      dt *= timeScale;

      // VELOCIT√Ä: fissa (non aumenta col punteggio)
      const speed = game.baseSpeed * boostMul;

      updateEngine(1.0 * boostMul);

      // gravity
      const g=22.0;
      game.vy += g*dt;
      game.y  += game.vy*dt;
      if(game.y>0){ game.y=0; game.vy=0; game.jumping=false; }

      // slide
      if(game.sliding){
        game.slideT -= dt;
        if(game.slideT<=0) game.sliding=false;
      }

      // runner scale: cresce piano piano con ‚Äúcibo‚Äù
      // ogni cibo aumenta target, max ~1.55; quando invincibile torna a 1.0
      if(game.fatInv <= 0){
        const sTarget = 1.0 + Math.min(0.55, game.foodCount * 0.055);
        game.runnerScaleTarget = sTarget;
      }
      game.runnerScale = lerp(game.runnerScale, game.runnerScaleTarget, 1 - Math.pow(0.0001, dt)); // smooth
      runner.scale.setScalar(game.runnerScale);

      // runner position
      runner.position.x = lanesX[game.lane];
      runner.position.y = (-game.y);

      // contact shadow
      const h = runner.position.y;
      const s = (1.10 + clamp(h*0.65, 0, 0.85)) * (0.92 + game.runnerScale*0.18);
      contact.position.x = runner.position.x;
      contact.scale.set(s,s,1);
      contact.material.opacity = clamp(0.58 - h*0.24, 0.12, 0.58);

      // animate runner
      if(mixer) mixer.update(dt);

      // scroll
      const scroll = speed*dt;
      dirtTex.offset.y -= scroll*0.085;

      for(const mesh of segments){
        mesh.position.z += scroll;
        if(mesh.position.z > segLen){
          mesh.position.z -= segLen*segCount;
        }
      }
      loopJungle(scroll);

      // spawn rows
      game.spawnT -= dt;
      const minGap = 0.55 / boostMul;
      if(game.spawnT<=0){
        spawnRow();
        game.spawnT = rnd(minGap, minGap+0.42);
      }

      // ‚ù§Ô∏è pi√π frequenti: ogni 20 emoji (se non full)
      if(game.coins >= game.nextHeartAt){
        spawnHeart();
        game.nextHeartAt += 20;
      }

      // Emoji Trail power-up
      if(game.trail){
        trailSpawnT -= dt;
        if(trailSpawnT <= 0){
          spawnTrailCoins();
          trailSpawnT = 0.45;
        }
      }else{
        trailSpawnT = 0;
      }

      // move entities + MAGNET pi√π forte
      for(const e of game.entities){
        e.z += scroll;
        e.obj.position.z = e.z;

        // magnet strong
        if(game.magnet && (e.type==='coin'||e.type==='power'||e.type==='heart')){
          const dx = lanesX[game.lane] - e.obj.position.x;
          const dz = (0 - e.z);
          const dist = Math.hypot(dx*2.2, dz);
          const radius = 10.5; // ‚úÖ pi√π raggio
          if(dist < radius){
            const pull = 4.2 * (1 - dist/radius); // ‚úÖ pi√π forza
            e.obj.position.x += dx * dt * pull;
          }
        }

        if(e.type==='heart'){
          const pulse = 1.45 + 0.12*Math.sin(tNow*0.008);
          e.obj.scale.set(pulse,pulse,1);
        }
      }

      // despawn
      for(let i=game.entities.length-1;i>=0;i--){
        if(game.entities[i].z > 4.2){
          scene.remove(game.entities[i].obj);
          game.entities.splice(i,1);
        }
      }

      // footsteps
      if(game.y===0 && !game.paused){
        stepTimer += dt * (speed/9.0);
        if(stepTimer >= 1.05){
          stepTimer = 0;
          playFootstep();
        }
      }

      // collisions
      const px = runner.position.x;
      const py = runner.position.y + 0.95;

      for(let i=game.entities.length-1;i>=0;i--){
        const e=game.entities[i];
        const dz=Math.abs(e.z - 0.25);
        const dx=Math.abs(e.obj.position.x - px);
        const dy=Math.abs(e.obj.position.y - py);

        const hit = (dz < 0.70 && dx < (0.55*game.runnerScale) && dy < (0.95*game.runnerScale));
        if(!hit) continue;

        if(e.type==='coin'){
          game.coins += 1;
          game.score += 28*(game.double?2:1);

          // se √® cibo => ingrassi piano piano
          const em = e.emoji || e.obj.userData.emoji;
          if(FOOD_SET.has(em)){
            game.foodCount = Math.min(10, game.foodCount + 1);
            if(game.foodCount >= 10 && game.fatInv <= 0){
              startFatInvincible();
            }
          }

          scene.remove(e.obj); game.entities.splice(i,1);
          playCoin();
          continue;
        }

        if(e.type==='power'){
          const p = POWERUPS.find(p=>p.key===e.key) || POWERUPS[0];
          setActivePower(p);
          applyPowerFlags();
          if(p.key==='shield'){ game.hasShield=true; if(shieldRing) shieldRing.visible=true; }
          scene.remove(e.obj); game.entities.splice(i,1);
          continue;
        }

        if(e.type==='heart'){
          if(game.lives < LIVES_MAX){
            game.lives = Math.min(LIVES_MAX, game.lives + 1);
            renderLife(game.lives);
            playHeart();
          }
          scene.remove(e.obj); game.entities.splice(i,1);
          continue;
        }

        if(e.type==='obst'){
          // invincibilit√† ‚Äúgrosso‚Äù => spacchi l‚Äôostacolo
          if(game.fatInv > 0){
            scene.remove(e.obj); game.entities.splice(i,1);
            camShake = 0.10;
            game.score += 35;
            continue;
          }

          // invulnerabile => ignora
          if(game.invuln > 0) continue;

          let mustHit=false;
          if(e.kind==='low'  && !game.jumping && game.y===0) mustHit=true;
          if(e.kind==='high' && !game.sliding) mustHit=true;

          if(mustHit){
            scene.remove(e.obj); game.entities.splice(i,1);
            damage();
          }
        }
      }

      // score tick (velocit√† fissa)
      game.score += 20*dt*(game.double?2:1);
      if(game.score>game.best){ game.best=Math.floor(game.score); saveBest(game.best); }

      // HUD
      scoreEl.textContent = String(Math.floor(game.score));
      coinsEl.textContent = String(game.coins);
      bestEl.textContent  = String(game.best);
      bestBig.textContent = String(game.best);
      multEl.textContent  = (game.double?'2.0':'1.0');
      spdEl.textContent   = (1.0 * boostMul).toFixed(2);

      // motion feel
      tiltTarget *= 0.92;
      camRoll = camRoll*0.90 + tiltTarget*0.10;
      camShake = Math.max(0, camShake - dt*0.9);
    }

    // Camera targets (per salto ‚Äúzoom in‚Äù)
    let camZ = 5.9;
    let camY = 2.25;
    let camFov = 60;

    function animate(tNow){
      const dt=Math.min(0.033,(tNow-tPrev)/1000);
      tPrev=tNow;

      update(dt,tNow);

      const inAir = (game.y < -0.01) || game.jumping;
      const boostFov = game.boost ? 12 : 0;

      // quando salti: FOV pi√π stretto (zoom-in) + camera pi√π vicina
      const targetFov = (inAir ? 48 : 60) + boostFov;
      const targetZ   = (inAir ? 4.85 : 5.9);
      const targetY   = (inAir ? 2.05 : 2.25);

      camFov = lerp(camFov, targetFov, 1 - Math.pow(0.0001, dt));
      camZ   = lerp(camZ,   targetZ,   1 - Math.pow(0.0001, dt));
      camY   = lerp(camY,   targetY,   1 - Math.pow(0.0001, dt));

      camera.fov = camFov;
      camera.updateProjectionMatrix();

      const bob = Math.sin(tNow*0.0024)*0.03 * (inAir ? 0.25 : 1.0);
      camera.position.set(0, camY + bob, camZ);

      const sx = (Math.sin(tNow*0.031)+Math.sin(tNow*0.017))*0.02*camShake;
      const sy = (Math.sin(tNow*0.027))*0.015*camShake;
      camera.position.x += sx;
      camera.position.y += sy;

      camera.rotation.z = camRoll;
      camera.lookAt(0, 1.20, -2.4);

      if(shieldRing && shieldRing.visible){
        shieldRing.material.opacity = 0.55 + 0.18*Math.sin(tNow*0.008);
        shieldRing.rotation.z += dt*1.2;
      }

      if(IS_IOS || !composer){
        renderer.render(scene, camera);
      }else{
        composer.render();
      }

      requestAnimationFrame(animate);
    }

    function onResize(){
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      if(composer){
        composer.setSize(window.innerWidth, window.innerHeight);
        bloomPass.setSize(window.innerWidth, window.innerHeight);
      }
    }
    window.addEventListener('resize', onResize);

    // Boot
    (async ()=>{
      await tryLoadRunnerFromPath();
      await tryLoadObstacleDefaults();
      openMenu();
      requestAnimationFrame(animate);
    })();
  </script>
</body>
</html>