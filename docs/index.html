<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Jungle Emoji Runner (Three.js)</title>
  <style>
    :root { color-scheme: dark; }
    html,body{height:100%;margin:0;background:#040805;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;overflow:hidden;}
    canvas{display:block;touch-action:none;}

    /* ‚úÖ NASCONDI TUTTO QUELLO CERCHIATO */
    .hud, .rightCol, .help, #menu { display:none !important; }

    /* --- Bottoni icona in alto a sinistra (solo Home/Settings/Pausa) --- */
    .topLeftBtns{
      position:fixed; top:8px; left:8px;
      display:flex; flex-direction:row; gap:8px;
      z-index:25; pointer-events:none;
    }
    .btn{
      pointer-events:auto;background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.16);
      color:#eaf1ff;padding:9px 11px;border-radius:12px;
      font-weight:800;cursor:pointer;user-select:none;
      backdrop-filter:blur(10px);
    }
    .btn:active{transform:scale(.98);}
    .iconBtn{
      pointer-events:auto;
      width:40px;height:40px;
      padding:0;
      border-radius:12px;
      display:flex;align-items:center;justify-content:center;
      font-size:17px;
      line-height:1;
    }

    /* ‚úÖ PULSANTI COME NEL CERCHIO: in basso a destra, verticali */
.rightStack{
  position:fixed;
  right:12px;
  bottom: calc(18px + env(safe-area-inset-bottom, 0px));
  z-index:30;
  display:flex;
  flex-direction:column;
  gap:10px;
  pointer-events:auto;
}

.bigBtn{
  width:80px;
  height:40px;
  border-radius:12px;
  font-weight:900;
  font-size:13px;
  letter-spacing:.1px;
  display:flex;
  align-items:center;
  justify-content:center;
  gap:8px;

  /* üî• QUESTE ERANO FUORI POSTO */
  background:rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.14);
  color:#eaf1ff;
  backdrop-filter:blur(10px);
  box-shadow:0 18px 60px rgba(0,0,0,.35);
}

/* üî¥ DOT STOP */
.pillDot{
  width:12px;                 /* leggermente pi√π grande = sempre visibile */
  height:12px;
  border-radius:50%;
  background:#ff3b30;
  flex:0 0 auto;

  box-shadow:
    0 0 0 2px rgba(0,0,0,.55), /* contorno scuro (stacca dal blur) */
    0 0 8px rgba(255,59,48,.9);
}

/* üü¢ DOT GO */
.pillDot.green{
  background:#34c759;
  box-shadow:
    0 0 0 2px rgba(0,0,0,.55),
    0 0 8px rgba(52,199,89,.9);
}
    

    /* --- Pannello impostazioni --- */
    .settingsOverlay{
      position:fixed; inset:0;
      display:none;
      align-items:flex-end;
      justify-content:center;
      padding:14px;
      background:radial-gradient(ellipse at center, rgba(0,0,0,.15), rgba(0,0,0,.65));
      backdrop-filter:blur(10px);
      z-index:40;
    }
    .panel{
      width:min(680px,100%);
      border-radius:18px;border:1px solid rgba(255,255,255,.16);
      background:rgba(10,14,22,.86);
      box-shadow:0 18px 60px rgba(0,0,0,.55);
      padding:14px;color:#eaf1ff;
    }
    .title{font-size:16px;font-weight:950;margin:4px 0 10px;}
    .settingsRow{display:flex;justify-content:space-between;align-items:center;gap:10px;font-size:13px;margin-top:10px;}
    .settingsRow small{opacity:.8}
    .settingsVal{font-weight:950}
    input[type="range"]{ width:100%; height:18px; accent-color: rgba(255,255,255,.85); }

    .toggle{
      display:flex;align-items:center;justify-content:space-between;
      border:1px solid rgba(255,255,255,.16);
      border-radius:14px;padding:10px 12px;background:rgba(255,255,255,.06);
      cursor:pointer;user-select:none;margin-top:10px;
    }
    .toggle label{font-weight:900;}
    .toggle span{opacity:.85;font-size:12px;}
    .switch{width:44px;height:26px;border-radius:99px;background:rgba(255,255,255,.14);position:relative;border:1px solid rgba(255,255,255,.16);}
    .switch i{position:absolute;top:3px;left:3px;width:20px;height:20px;border-radius:999px;background:rgba(255,255,255,.86);transition:transform .18s ease;}
    .switch.on{background:rgba(140,255,190,.18);border-color:rgba(140,255,190,.24);}
    .switch.on i{transform:translateX(18px);}
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>

  <!-- ‚úÖ SOLO 3 BOTTONI IN ALTO A SINISTRA -->
  <div class="topLeftBtns">
    <button class="btn iconBtn" id="btnHome" aria-label="Home">üè†</button>
    <button class="btn iconBtn" id="btnSettings" aria-label="Impostazioni">‚öôÔ∏è</button>
    <button class="btn iconBtn" id="btnPause" aria-label="Pausa">‚è∏Ô∏è</button>
  </div>

  <!-- ‚úÖ PULSANTE PRINCIPALE (Start/Stop/Restart) + Dance sotto -->
  <div class="rightStack">
    <button class="bigBtn" id="btnMain">
      <span class="pillDot" id="mainDot"></span>
      <span id="mainLbl">AVVIA</span>
    </button>
    <button class="bigBtn" id="btnDance">üï∫ Dance</button>
  </div>

  <!-- ‚úÖ SETTINGS -->
  <div class="settingsOverlay" id="settingsOverlay">
    <div class="panel">
      <div class="title">Impostazioni</div>

      <div class="settingsRow">
        <div><label>FOV</label><br><small>30‚Äì110 (base 60)</small></div>
        <div class="settingsVal" id="fovVal">60</div>
      </div>
      <input id="fovSlider" type="range" min="30" max="110" step="1" value="60" />

      <div class="settingsRow">
        <div><label>Distanza camera</label><br><small>2‚Äì15 (base 5.0)</small></div>
        <div class="settingsVal" id="camVal">5.0</div>
      </div>
      <input id="camSlider" type="range" min="2" max="15" step="0.1" value="5.0" />

      <div class="settingsRow">
        <div><label>Inquadratura player</label><br><small>0=alto ‚Ä¢ 1=molto in basso</small></div>
        <div class="settingsVal" id="frameVal">0.06</div>
      </div>
      <input id="frameSlider" type="range" min="0" max="1" step="0.01" value="0.06" />

      <div class="toggle" id="audioToggle">
        <div><label>Suoni</label><br/><span>Fallback semplice (stabile su iPhone).</span></div>
        <div class="switch on" id="audioSwitch"><i></i></div>
      </div>

      <div class="toggle" id="shakeToggle">
        <div><label>Camera shake</label><br/><span>Micro shake durante i boost.</span></div>
        <div class="switch on" id="shakeSwitch"><i></i></div>
      </div>

      <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:12px;">
        <button class="btn" id="resetCam">Reset camera</button>
        <button class="btn" id="closeSettings">Chiudi</button>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    const IS_IOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

    // ===== UI =====
    const btnHome = document.getElementById('btnHome');
    const btnSettings = document.getElementById('btnSettings');
    const btnPause = document.getElementById('btnPause');

    const btnMain = document.getElementById('btnMain');
    const mainLbl = document.getElementById('mainLbl');
    const mainDot = document.getElementById('mainDot');
    const btnDance = document.getElementById('btnDance');

    const settingsOverlay = document.getElementById('settingsOverlay');
    const closeSettingsBtn = document.getElementById('closeSettings');
    const resetCamBtn = document.getElementById('resetCam');

    const audioToggle= document.getElementById('audioToggle');
    const audioSwitch= document.getElementById('audioSwitch');
    const shakeToggle = document.getElementById('shakeToggle');
    const shakeSwitch = document.getElementById('shakeSwitch');

    const fovSlider = document.getElementById('fovSlider');
    const camSlider = document.getElementById('camSlider');
    const frameSlider = document.getElementById('frameSlider');
    const fovVal = document.getElementById('fovVal');
    const camVal = document.getElementById('camVal');
    const frameVal = document.getElementById('frameVal');

    const rnd=(a,b)=>a+Math.random()*(b-a);
    const rndi=(a,b)=>Math.floor(rnd(a,b+1));
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp=(a,b,t)=>a+(b-a)*t;
    const damp = (current, target, lambda, dt) => current + (target-current) * (1 - Math.exp(-lambda*dt));

    // ===== SETTINGS =====
    const CAM_KEY = 'jr_cam_settings_v7';
    const DEFAULTS = { baseFov: 60, baseCamZ: 5.0, framing: 0.06, shake: true };
    const saved = (()=>{ try{return JSON.parse(localStorage.getItem(CAM_KEY)||'{}')}catch{return {}} })();

    let baseFov  = clamp(Number(saved.baseFov ?? DEFAULTS.baseFov), 30, 110);
    let baseCamZ = clamp(Number(saved.baseCamZ ?? DEFAULTS.baseCamZ), 2, 15);
    let framing  = clamp(Number(saved.framing ?? DEFAULTS.framing), 0, 1);
    let shakeEnabled = (saved.shake ?? DEFAULTS.shake) !== false;

    function saveCam(){ localStorage.setItem(CAM_KEY, JSON.stringify({ baseFov, baseCamZ, framing, shake: !!shakeEnabled })); }
    function syncCamUI(){
      fovSlider.value = String(Math.round(baseFov));
      fovVal.textContent = String(Math.round(baseFov));
      camSlider.value = String(baseCamZ.toFixed(1));
      camVal.textContent = baseCamZ.toFixed(1);
      frameSlider.value = String(framing.toFixed(2));
      frameVal.textContent = framing.toFixed(2);
      shakeSwitch.classList.toggle('on', !!shakeEnabled);
      audioSwitch.classList.toggle('on', !!audioEnabled);
    }
    fovSlider.addEventListener('input', ()=>{ baseFov = clamp(Number(fovSlider.value), 30, 110); fovVal.textContent = String(Math.round(baseFov)); saveCam(); });
    camSlider.addEventListener('input', ()=>{ baseCamZ = clamp(Number(camSlider.value), 2, 15); camVal.textContent = baseCamZ.toFixed(1); saveCam(); });
    frameSlider.addEventListener('input', ()=>{ framing = clamp(Number(frameSlider.value), 0, 1); frameVal.textContent = framing.toFixed(2); saveCam(); });

    function openSettings(){ settingsOverlay.style.display='flex'; syncCamUI(); }
    function closeSettings(){ settingsOverlay.style.display='none'; }

    btnSettings.addEventListener('click', ()=>{ initAudio(); openSettings(); });
    closeSettingsBtn.addEventListener('click', closeSettings);

    shakeToggle.addEventListener('click', ()=>{
      shakeEnabled = !shakeEnabled;
      shakeSwitch.classList.toggle('on', !!shakeEnabled);
      saveCam();
    });

    resetCamBtn.addEventListener('click', ()=>{
      baseFov = DEFAULTS.baseFov; baseCamZ = DEFAULTS.baseCamZ; framing = DEFAULTS.framing; shakeEnabled = DEFAULTS.shake;
      saveCam(); syncCamUI();
    });

    // ===== Audio minimal =====
    let audioEnabled=true, audioReady=false, actx=null, master=null;
    function initAudio(){
      if(audioReady) return;
      try{
        actx = new (window.AudioContext||window.webkitAudioContext)();
        master = actx.createGain(); master.gain.value=0.55; master.connect(actx.destination);
        audioReady=true;
      }catch(e){ audioEnabled=false; }
      audioSwitch.classList.toggle('on',!!audioEnabled);
    }
    function beep(type,freq,dur=0.06,g=0.10){
      if(!audioEnabled) return;
      initAudio(); if(!audioReady) return;
      const t0=actx.currentTime;
      const o=actx.createOscillator();
      const gg=actx.createGain();
      o.type=type; o.frequency.setValueAtTime(freq,t0);
      gg.gain.setValueAtTime(0.0001,t0);
      gg.gain.exponentialRampToValueAtTime(g,t0+0.012);
      gg.gain.exponentialRampToValueAtTime(0.0001,t0+dur);
      o.connect(gg); gg.connect(master);
      o.start(t0); o.stop(t0+dur+0.02);
    }
    const sfx = {
      ring: ()=>{ beep('triangle', 700, 0.06, 0.10); },
      hit:  ()=>{ beep('square', 120, 0.12, 0.11); },
      lane: ()=>{ beep('sine', 160, 0.05, 0.05); },
      jump: ()=>{ beep('square', 420, 0.05, 0.08); },
      slide:()=>{ beep('sine', 220, 0.06, 0.06); },
      boost:()=>{ beep('sawtooth', 520, 0.10, 0.09); beep('triangle', 880, 0.10, 0.07); },
    };
    audioToggle.addEventListener('click', ()=>{ initAudio(); audioEnabled=!audioEnabled; audioSwitch.classList.toggle('on',!!audioEnabled); });

    // ===== Renderer / Scene =====
    const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x08120b);
    scene.fog = IS_IOS ? new THREE.Fog(0x08120b, 26, 110) : new THREE.FogExp2(0x06110a, 0.036);

    const camera = new THREE.PerspectiveCamera(baseFov, window.innerWidth/window.innerHeight, 0.1, 320);

    // lights
    const sun = new THREE.DirectionalLight(0xf3ffe6, IS_IOS ? 2.8 : 2.1);
    sun.position.set(6, 10, 6);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048,2048);
    sun.shadow.camera.near = 0.5;
    sun.shadow.camera.far = 80;
    sun.shadow.camera.left = -12;
    sun.shadow.camera.right=  12;
    sun.shadow.camera.top  =  12;
    sun.shadow.camera.bottom=-12;
    sun.shadow.bias = -0.00023;
    scene.add(sun);
    scene.add(new THREE.HemisphereLight(0xaaffdd, 0x081209, IS_IOS ? 1.05 : 0.78));
    scene.add(new THREE.AmbientLight(0xffffff, IS_IOS ? 0.6 : 0.24));
    const front = new THREE.DirectionalLight(0xffffff, IS_IOS ? 1.25 : 0.55);
    front.position.set(0, 4, 9);
    scene.add(front);

    // Contact shadow
    function makeContactShadowTexture(size=512){
      const c=document.createElement('canvas'); c.width=c.height=size;
      const g=c.getContext('2d');
      g.clearRect(0,0,size,size);
      const grd=g.createRadialGradient(size/2,size/2,0, size/2,size/2,size*0.48);
      grd.addColorStop(0,'rgba(0,0,0,0.38)');
      grd.addColorStop(0.55,'rgba(0,0,0,0.10)');
      grd.addColorStop(1,'rgba(0,0,0,0)');
      g.fillStyle=grd; g.fillRect(0,0,size,size);
      const t=new THREE.CanvasTexture(c); t.colorSpace=THREE.SRGBColorSpace;
      return t;
    }
    const contact = new THREE.Mesh(
      new THREE.PlaneGeometry(1.5,1.5),
      new THREE.MeshBasicMaterial({ map:makeContactShadowTexture(512), transparent:true, opacity:0.55, depthWrite:false })
    );
    contact.rotation.x = -Math.PI/2;
    contact.position.set(0, 0.02, 0.2);
    scene.add(contact);

    // ===== STRADA =====
    const segLen = 9.0, segCount = 10;
    const laneW = 1.35;
    const mainRoadWidth = laneW * 3;
    const shoulderWidth = 1.40;
    const totalRoadWidth = mainRoadWidth + shoulderWidth;
    const leftEdge = -totalRoadWidth/2;
    const lanesX = [
      leftEdge + laneW*0.5,
      leftEdge + laneW*1.5,
      leftEdge + laneW*2.5,
      leftEdge + mainRoadWidth + shoulderWidth*0.5
    ];

    function makeHighwayTexture(size=1024){
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const g = c.getContext('2d');
      g.fillStyle = '#2b2f35';
      g.fillRect(0,0,size,size);

      for(let i=0;i<20000;i++){
        const x = Math.random()*size, y = Math.random()*size;
        const v = Math.floor(70 + Math.random()*70);
        g.fillStyle = `rgba(${v},${v},${v},${Math.random()*0.10})`;
        g.fillRect(x,y,1,1);
      }

      const px = (worldX)=> Math.round(((worldX - leftEdge) / totalRoadWidth) * size);

      const shoulderStartX = leftEdge + mainRoadWidth;
      g.fillStyle = 'rgba(255,255,255,0.03)';
      g.fillRect(px(shoulderStartX), 0, px(leftEdge+totalRoadWidth) - px(shoulderStartX), size);

      const solidW = Math.max(6, Math.round(size * 0.008));
      const dashW  = Math.max(5, Math.round(size * 0.0065));
      const dashLen = Math.round(size * 0.180);
      const dashGap = Math.round(size * 0.999);

      g.fillStyle = '#f4f6f8';

      const xOuterL = px(leftEdge + 0.03);
      const xOuterR = px(leftEdge + totalRoadWidth - 0.03);
      const xOuterLi = Math.round(xOuterL - solidW/2);
      const xOuterRi = Math.round(xOuterR - solidW/2);
      g.fillRect(xOuterLi, 0, solidW, size);
      g.fillRect(xOuterRi, 0, solidW, size);

      const xShoulderSep = px(shoulderStartX);
      const xShoulderSepI = Math.round(xShoulderSep - solidW/2);
      g.fillRect(xShoulderSepI, 0, solidW, size);

      const xDash1 = px(leftEdge + laneW*1);
      const xDash2 = px(leftEdge + laneW*2);
      const xDash1I = Math.round(xDash1 - dashW/2);
      const xDash2I = Math.round(xDash2 - dashW/2);

      for(let y=0; y<size; y += (dashLen + dashGap)){
        const yi = Math.round(y);
        g.fillRect(xDash1I, yi, dashW, dashLen);
        g.fillRect(xDash2I, yi, dashW, dashLen);
      }

      const t = new THREE.CanvasTexture(c);
      t.colorSpace = THREE.SRGBColorSpace;
      t.wrapS = t.wrapT = THREE.RepeatWrapping;
      t.repeat.set(1.0, 10.0);
      return t;
    }

    function makePatchTexture(size=512){
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const g = c.getContext('2d');
      g.clearRect(0,0,size,size);

      const px = (worldX)=> ((worldX - leftEdge) / totalRoadWidth) * size;

      const centerLaneX = lanesX[1];
      const bandHalfW = laneW * 0.36;
      const xMin = Math.max(0, Math.floor(px(centerLaneX - bandHalfW)));
      const xMax = Math.min(size-1, Math.ceil(px(centerLaneX + bandHalfW)));

      for(let i=0;i<7000;i++){
        const x = xMin + Math.random()*(xMax-xMin);
        const y = Math.random()*size;
        const a = 0.02 + Math.random()*0.05;
        g.fillStyle = `rgba(0,0,0,${a})`;
        g.fillRect(x,y,1,1);
      }

      const stripCount = 8 + Math.floor(Math.random()*7);
      for(let i=0;i<stripCount;i++){
        const x = xMin + Math.random()*(xMax-xMin);
        const w = 14 + Math.random()*36;
        const a = 0.05 + Math.random()*0.12;

        const grad = g.createLinearGradient(x,0,x+w,0);
        grad.addColorStop(0, `rgba(0,0,0,0)`);
        grad.addColorStop(0.5, `rgba(0,0,0,${a})`);
        grad.addColorStop(1, `rgba(0,0,0,0)`);

        g.fillStyle = grad;
        g.fillRect(x, 0, w, size);
      }

      const patchCount = 6 + Math.floor(Math.random()*9);
      for(let i=0;i<patchCount;i++){
        const x = xMin + Math.random()*(xMax-xMin);
        const y = Math.random()*size;
        const w = 60 + Math.random()*170;
        const h = 8 + Math.random()*22;
        const a = 0.05 + Math.random()*0.12;
        g.fillStyle = `rgba(0,0,0,${a})`;
        g.fillRect(x,y,w,h);
      }

      const t = new THREE.CanvasTexture(c);
      t.colorSpace = THREE.SRGBColorSpace;
      t.wrapS = t.wrapT = THREE.RepeatWrapping;
      t.repeat.set(1.0, 10.0);
      return t;
    }

    const highwayTex = makeHighwayTexture(IS_IOS ? 768 : 1024);
    highwayTex.generateMipmaps = false;
    highwayTex.minFilter = THREE.NearestFilter;
    highwayTex.magFilter = THREE.NearestFilter;
    highwayTex.anisotropy = renderer.capabilities.getMaxAnisotropy();
    highwayTex.needsUpdate = true;
    highwayTex.repeat.set(1.0, 4.0);

    const patchTexPool = [
      makePatchTexture(IS_IOS ? 384 : 512),
      makePatchTexture(IS_IOS ? 384 : 512),
      makePatchTexture(IS_IOS ? 384 : 512),
    ];

    const roadMat = new THREE.MeshStandardMaterial({
      map: highwayTex,
      roughness: 0.96,
      metalness: 0.0,
      color: new THREE.Color(0xffffff)
    });

    const segments=[];
    let groupLeft = rndi(2,3);
    let groupShade = 0.94 + Math.random()*0.08;
    let groupPatch = patchTexPool[rndi(0, patchTexPool.length-1)];
    let groupPatchOpacity = 0.16 + Math.random()*0.10;

    for(let i=0;i<segCount;i++){
      const geo = new THREE.PlaneGeometry(totalRoadWidth, segLen);
      geo.rotateX(-Math.PI/2);
      const mesh = new THREE.Mesh(geo, roadMat);

      groupLeft--;
      if(groupLeft <= 0){
        groupLeft = rndi(2,3);
        groupShade = 0.94 + Math.random()*0.08;
        groupPatch = patchTexPool[rndi(0, patchTexPool.length-1)];
        groupPatchOpacity = 0.16 + Math.random()*0.10;
      }

      if(Math.abs(groupShade - 1.0) > 0.0001){
        const m = roadMat.clone();
        m.color = roadMat.color.clone().multiplyScalar(groupShade);
        mesh.material = m;
      }

      const patchGeo = new THREE.PlaneGeometry(totalRoadWidth, segLen);
      patchGeo.rotateX(-Math.PI/2);
      const patchMat = new THREE.MeshStandardMaterial({
        map: groupPatch,
        transparent: true,
        opacity: groupPatchOpacity,
        roughness: 1.0,
        metalness: 0.0,
        depthWrite: false,
        polygonOffset: true,
        polygonOffsetFactor: -1,
        polygonOffsetUnits: -1,
      });
      const patch = new THREE.Mesh(patchGeo, patchMat);
      patch.position.y = 0.003;
      mesh.add(patch);

      mesh.position.set(0, 0, -i*segLen);
      mesh.receiveShadow=true;

      scene.add(mesh);
      segments.push(mesh);
    }

    // terreno laterale
    const sideGeo = new THREE.PlaneGeometry(44, segLen*segCount);
    sideGeo.rotateX(-Math.PI/2);
    const sideMat = new THREE.MeshStandardMaterial({ color:0x0d2416, roughness:1, metalness:0 });
    const side = new THREE.Mesh(sideGeo, sideMat);
    side.position.set(0, -0.02, -segLen*segCount/2 + segLen/2);
    side.receiveShadow = true;
    scene.add(side);

    // alberi
    const jungle = new THREE.Group(); scene.add(jungle);
    function makeTree(){
      const g = new THREE.Group();
      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.11, 0.16, 1.6, 10),
        new THREE.MeshStandardMaterial({ color:0x4a3523, roughness:1, metalness:0 })
      );
      trunk.position.y=0.8; trunk.castShadow=true; trunk.receiveShadow=true; g.add(trunk);
      const crown = new THREE.Mesh(
        new THREE.ConeGeometry(0.75, 1.6, 12),
        new THREE.MeshStandardMaterial({ color:0x1c6b33, roughness:1, metalness:0 })
      );
      crown.position.y=1.9; crown.castShadow=true; crown.receiveShadow=true; g.add(crown);
      const crown2 = new THREE.Mesh(
        new THREE.ConeGeometry(0.6, 1.3, 12),
        new THREE.MeshStandardMaterial({ color:0x135226, roughness:1, metalness:0 })
      );
      crown2.position.y=2.3; crown2.castShadow=true; crown2.receiveShadow=true; g.add(crown2);
      return g;
    }
    const treeProto = makeTree();
    const treePool=[];
    const treeSpacing=2.8;
    const treeSideX = (totalRoadWidth/2) + 1.9;
    const jungleCount = Math.floor((segLen*segCount)/treeSpacing);
    for(let i=0;i<jungleCount;i++){
      const z = -i*treeSpacing;
      for(const sideSign of [-1,1]){
        const t = treeProto.clone(true);
        t.position.set(sideSign*(treeSideX + rnd(0,1.8)), 0, z);
        t.scale.setScalar(rnd(0.8,1.2));
        t.rotation.y = rnd(0,Math.PI*2);
        t.traverse(o=>{ if(o.isMesh){o.castShadow=true;o.receiveShadow=true;}});
        jungle.add(t); treePool.push(t);
      }
    }
    function loopJungle(scroll){
      const wrapZ = segLen*segCount;
      for(const obj of treePool){
        obj.position.z += scroll;
        if(obj.position.z > 10) obj.position.z -= wrapZ;
      }
    }

    // ===== Entities visuals =====
    function spawnObstacleVisual(){
      const box = new THREE.Mesh(
        new THREE.BoxGeometry(rnd(0.65,0.95), rnd(0.75,1.25), rnd(0.65,0.95)),
        new THREE.MeshStandardMaterial({ color:0x6b4b2b, roughness:0.9, metalness:0.02 })
      );
      box.castShadow=true; box.receiveShadow=true;
      return box;
    }
    function makeTurtle(){
      const g = new THREE.Group();
      const shell = new THREE.Mesh(
        new THREE.SphereGeometry(0.35, 18, 14),
        new THREE.MeshStandardMaterial({ color:0x1f6a3a, roughness:0.9, metalness:0.02 })
      );
      shell.scale.set(1.2,0.75,1.0);
      shell.position.y=0.35;
      shell.castShadow=true; shell.receiveShadow=true;
      g.add(shell);
      const head = new THREE.Mesh(
        new THREE.SphereGeometry(0.16, 16, 12),
        new THREE.MeshStandardMaterial({ color:0x2f8a4d, roughness:0.9, metalness:0.02 })
      );
      head.position.set(0,0.25,0.42);
      head.castShadow=true;
      g.add(head);
      return g;
    }
    function makeVerticalRing(){
      const ring = new THREE.Mesh(
        new THREE.TorusGeometry(0.55, 0.09, 14, 44),
        new THREE.MeshStandardMaterial({
          color:0xff4444,
          roughness:0.35,
          metalness:0.05,
          emissive:0x660000,
          emissiveIntensity:0.55
        })
      );
      ring.castShadow=true; ring.receiveShadow=true;
      return ring;
    }

    // ===== Runner =====
    const runnerPivot = new THREE.Group(); scene.add(runnerPivot);
    const runnerCenter = new THREE.Group(); runnerCenter.position.set(0, 0.95, 0); runnerPivot.add(runnerCenter);
    const runnerModel = new THREE.Group(); runnerModel.position.set(0, -0.95, 0); runnerCenter.add(runnerModel);

    // Bubble
    const bubble = new THREE.Mesh(
      new THREE.SphereGeometry(0.62, 24, 18),
      new THREE.MeshStandardMaterial({
        color:0x66ffcc, roughness:0.25, metalness:0.0,
        emissive:0x33ffaa, emissiveIntensity:0.7,
        transparent:true, opacity:0.22
      })
    );
    bubble.position.set(0, 0.95, 0);
    bubble.visible=false;
    runnerPivot.add(bubble);

    // ===== GLB loader + Animations =====
    const gltfLoader = new GLTFLoader();

    const RUNNER_GLB_URL = './running.glb';
    const ANIM_FILES = {
      idle: ['./DwarfIdle.glb', './WarriorIdle.glb', './HappyIdle.glb'],
      jump: './JumpOver.glb',
      flip: './RunningForwardFlip.glb',
      kick: './SoccerKick.glb',
      die:  './SideHitDie.glb',
      dance:'./HipHopDance.glb'
    };

    function setShadows(root){
      root.traverse(o=>{
        if(o.isMesh){ o.castShadow=true; o.receiveShadow=true; }
      });
    }
    function removeBigNonSkinnedPlanes(model){
      model.traverse(o=>{
        if(!o.isMesh) return;
        const isSkinned = (o.isSkinnedMesh === true) || (o.skeleton != null);
        if(isSkinned) return;

        const box = new THREE.Box3().setFromObject(o);
        const s = new THREE.Vector3(); box.getSize(s);

        const huge = (s.x > 2.4 || s.y > 2.4 || s.z > 2.4);
        const flat = (Math.min(s.x,s.y,s.z) < 0.03 && Math.max(s.x,s.y,s.z) > 1.6);

        const name = (o.name||'').toLowerCase();
        const suspicious = name.includes('plane') || name.includes('cube') || name.includes('quad') || name.includes('ground') || name.includes('floor');

        if(huge || flat || suspicious){
          o.visible = false;
        }
      });
    }
    function stripRootMotion(clip){
      const c = clip.clone();
      const TH = 0.02;
      try{
        for(const t of c.tracks){
          const name = (t.name || '').toLowerCase();
          if(!name.endsWith('.position')) continue;
          const v = t.values;
          if(!v || v.length < 6) continue;

          let minX=Infinity, maxX=-Infinity, minZ=Infinity, maxZ=-Infinity;
          for(let i=0;i<v.length;i+=3){
            const x=v[i], z=v[i+2];
            if(x<minX) minX=x; if(x>maxX) maxX=x;
            if(z<minZ) minZ=z; if(z>maxZ) maxZ=z;
          }
          const rangeX=maxX-minX, rangeZ=maxZ-minZ;
          if(rangeX>TH || rangeZ>TH){
            const baseX=v[0], baseZ=v[2];
            for(let i=0;i<v.length;i+=3){
              v[i]=baseX;
              v[i+2]=baseZ;
            }
          }
        }
      }catch(err){ console.warn('stripRootMotion fallback:', err); }
      return c;
    }

    let runnerMixer=null;
    let actions = {
      run:null,
      idles:[],
      jump:null,
      flip:null,
      kick:null,
      die:null,
      dance:null
    };

    let mixamoHips=null, mixamoRootNode=null;
    let hipsBaseX=0, hipsBaseZ=0, rootBaseX=0, rootBaseZ=0;

    const animState = {
      mode:'idle'
    };

    function fadeTo(next, fade=0.18){
      if(!next) return;
      const all = [];
      if(actions.run) all.push(actions.run);
      if(actions.jump) all.push(actions.jump);
      if(actions.flip) all.push(actions.flip);
      if(actions.kick) all.push(actions.kick);
      if(actions.die)  all.push(actions.die);
      if(actions.dance)all.push(actions.dance);
      for(const a of actions.idles) all.push(a);

      for(const a of all){
        if(a !== next){
          try{ a.fadeOut(fade); }catch{}
        }
      }
      try{
        next.reset();
        next.enabled = true;
        next.setEffectiveWeight(1.0);
        next.fadeIn(fade);
        next.play();
      }catch{}
    }

    function playRun(){
      if(!actions.run || animState.mode==='dead') return;
      animState.mode='run';
      fadeTo(actions.run, 0.12);
      actions.run.setLoop(THREE.LoopRepeat, Infinity);
      actions.run.clampWhenFinished = false;
    }

    function pickRandomIdle(){
      if(!actions.idles.length || animState.mode==='dead') return;
      const a = actions.idles[rndi(0, actions.idles.length-1)];
      a.setLoop(THREE.LoopOnce, 1);
      a.clampWhenFinished = true;
      a.time = 0;
      animState.mode='idle';
      fadeTo(a, 0.20);
    }

    function startIdleRandom(){
      if(animState.mode==='dead') return;
      pickRandomIdle();
    }

    function playOneShot(action, fade=0.08){
      if(!action || animState.mode==='dead') return;
      animState.mode='oneShot';
      action.reset();
      action.setLoop(THREE.LoopOnce, 1);
      action.clampWhenFinished = true;
      action.enabled = true;
      action.setEffectiveWeight(1.0);
      fadeTo(action, fade);
    }

    function playDance(){
      if(!actions.dance || animState.mode==='dead') return;
      animState.mode='dance';
      actions.dance.setLoop(THREE.LoopRepeat, Infinity);
      actions.dance.clampWhenFinished = false;
      fadeTo(actions.dance, 0.18);
    }

    function playDie(){
      if(!actions.die) return;
      animState.mode='dead';
      actions.die.reset();
      actions.die.setLoop(THREE.LoopOnce, 1);
      actions.die.clampWhenFinished = true;
      fadeTo(actions.die, 0.08);
    }

    async function loadAnimClip(url){
      return new Promise((resolve)=>{
        gltfLoader.load(url, (gltf)=>{
          const clips = (gltf.animations||[]).filter(c=>c && c.tracks && c.tracks.length);
          resolve(clips[0] || null);
        }, undefined, ()=>{
          console.warn('Anim load error:', url);
          resolve(null);
        });
      });
    }

    async function loadAllAnimations(){
      for(const u of ANIM_FILES.idle){
        const c = await loadAnimClip(u);
        if(c) actions.idles.push(c);
      }
      actions.jump = await loadAnimClip(ANIM_FILES.jump);
      actions.flip = await loadAnimClip(ANIM_FILES.flip);
      actions.kick = await loadAnimClip(ANIM_FILES.kick);
      actions.die  = await loadAnimClip(ANIM_FILES.die);
      actions.dance= await loadAnimClip(ANIM_FILES.dance);
    }

    async function loadRunnerModel(){
      return new Promise((resolve)=>{
        gltfLoader.load(RUNNER_GLB_URL, async (gltf)=>{
          const model = gltf.scene;
          model.position.set(0,0,0);
          model.scale.setScalar(0.95);
          setShadows(model);

          model.traverse(o=>{
            if(o.isMesh && o.material){
              const mats = Array.isArray(o.material) ? o.material : [o.material];
              for(const m of mats){ if(m) m.side = THREE.DoubleSide; }
            }
          });

          removeBigNonSkinnedPlanes(model);

          { // piedi a terra
            const box = new THREE.Box3().setFromObject(model);
            const lift = -box.min.y;
            model.position.y += lift + 0.01;
          }

          model.rotation.y = Math.PI;

          mixamoHips = null; mixamoRootNode = null;
          model.traverse(o=>{
            const n = (o.name||'').toLowerCase();
            if(!mixamoRootNode && (n.includes('armature') || n === 'root')) mixamoRootNode = o;
            if(o.isBone){
              if(n==='hips' || (n.includes('mixamorig') && n.includes('hips'))) mixamoHips = o;
            }
          });
          if(mixamoHips){ hipsBaseX = mixamoHips.position.x; hipsBaseZ = mixamoHips.position.z; }
          if(mixamoRootNode){ rootBaseX = mixamoRootNode.position.x; rootBaseZ = mixamoRootNode.position.z; }

          while(runnerModel.children.length) runnerModel.remove(runnerModel.children[0]);
          runnerModel.add(model);

          runnerMixer = new THREE.AnimationMixer(model);

          await loadAllAnimations();

          const baseClips = (gltf.animations||[]).filter(c=>c && c.tracks && c.tracks.length);
          const runClip = baseClips.find(c => (c.name||'').toLowerCase().includes('run')) || baseClips[0];
          const fixedRun = runClip ? stripRootMotion(runClip) : null;
          if(fixedRun){
            actions.run = runnerMixer.clipAction(fixedRun);
            actions.run.enabled = true;
            actions.run.setEffectiveWeight(1.0);
            actions.run.setEffectiveTimeScale(1.0);
          }

          const idleActions = [];
          for(const clip of actions.idles) idleActions.push(runnerMixer.clipAction(clip));
          actions.idles = idleActions;

          if(actions.jump) actions.jump = runnerMixer.clipAction(actions.jump);
          if(actions.flip) actions.flip = runnerMixer.clipAction(actions.flip);
          if(actions.kick) actions.kick = runnerMixer.clipAction(actions.kick);
          if(actions.die)  actions.die  = runnerMixer.clipAction(actions.die);
          if(actions.dance)actions.dance= runnerMixer.clipAction(actions.dance);

          runnerMixer.addEventListener('finished', ()=>{
            if(animState.mode==='dead') return;
            if(animState.mode==='oneShot'){
              if(game.started && !game.stopped && !game.paused && !game.over) playRun();
              else startIdleRandom();
              return;
            }
            if(animState.mode==='idle'){
              pickRandomIdle();
              return;
            }
          });

          startIdleRandom();
          resolve();
        }, undefined, ()=>{
          resolve();
        });
      });
    }

    // ===== Game data =====
    const game = {
      lane:1,
      y:0, vy:0, jumping:false,
      sliding:false, slideT:0,
      autoSlideCooldown:0,

      baseSpeed: 12.9,
      score:0, coins:0,

      maxLives:5,
      lives:3,

      ringCount:0,
      foodCount:0,
      foodHistory:[],

      invincibleT:0,
      foodBoostT:0,
      ringBoostT:0,
      magnetT:0,
      trioT:0,

      entities:[],
      spawnT:0.30,

      paused:false,
      started:false,
      over:false,

      stopped:true,
      stopBlend:1.0,

      lastTurtleZ: [-99999, -99999, -99999],
    };

    // ‚úÖ LABEL + DOT del pulsante principale (Start / Stop / Restart)
    function updateMainButton(){
      if(game.over){
        mainLbl.textContent = 'RESTART';
        mainDot.classList.remove('green');
        return;
      }
      if(!game.started){
        mainLbl.textContent = 'AVVIA';
        mainDot.classList.remove('green');
        return;
      }
      if(game.stopped){
        mainLbl.textContent = 'AVVIA';
        mainDot.classList.add('green');
        return;
      }
      mainLbl.textContent = 'STOP';
      mainDot.classList.remove('green');
    }

    // ‚úÖ +5% ostacoli ogni 5000 punti
    function obstacleMultiplier(){
      const steps = Math.floor(game.score / 5000);
      return 1 + 0.05 * steps;
    }

    // ===== Spawn =====
    const TURTLE_VIS_Z = 70;
    const TURTLE_MIN_GAP = TURTLE_VIS_Z * 3.0;

    function canSpawnTurtle(lane, z){
      return Math.abs(z - game.lastTurtleZ[lane]) >= TURTLE_MIN_GAP;
    }

    function spawnRow(){
      const z0 = -60 - rnd(0,18);

      const blocked=new Set();
      const mult = obstacleMultiplier();

      const p0 = clamp(0.22 / mult, 0.03, 0.22);
      let oCount = 0;
      if(Math.random() >= p0){
        const p2 = clamp(0.38 * mult, 0.18, 0.95);
        oCount = (Math.random() < p2) ? 2 : 1;
      }
      while(blocked.size<oCount) blocked.add(rndi(0,2));

      blocked.forEach(l=>{
        const obj = spawnObstacleVisual();
        obj.position.set(lanesX[l], 0.65, z0);
        scene.add(obj);
        game.entities.push({ type:'obst', lane:l, z:z0, obj });
      });

      if(Math.random() < 0.18){
        const lane=rndi(0,2);
        const tz = z0 - rnd(3,11);
        if(canSpawnTurtle(lane, tz)){
          const t = makeTurtle();
          t.position.set(lanesX[lane], 0, tz);
          t.traverse(o=>{ if(o.isMesh){ o.castShadow=true; o.receiveShadow=true; }});
          scene.add(t);
          game.entities.push({ type:'turtle', lane, z:tz, obj:t });
          game.lastTurtleZ[lane] = tz;
        }
      }

      if(Math.random() < 0.26){
        const lane = rndi(0,2);
        const baseZ = z0 - rnd(2,9);
        const gap = 0.82;
        for(let k=0;k<2;k++){
          const ring = makeVerticalRing();
          ring.position.set(lanesX[lane], 0.55, baseZ - k*gap);
          scene.add(ring);
          game.entities.push({ type:'ring', lane, z:ring.position.z, obj:ring });
        }
      }
    }

    // ===== Controls =====
    let tiltTarget=0, camRoll=0;

    function moveLane(dir){
      if(game.over||game.paused) return;
      if(!game.started) return;
      if(game.stopped) return;
      if(game.trioT>0) return;
      game.lane = clamp(game.lane+dir, 0, 3);
      tiltTarget = clamp(tiltTarget + dir*0.18, -0.22, 0.22);
      sfx.lane();
    }

    function jump(){
      if(game.over||game.paused) return;
      if(!game.started) return;
      if(game.stopped) return;
      if(!game.jumping && game.y>=-0.001){
        game.jumping=true;
        game.vy = -7.8;
        sfx.jump();
        playOneShot(actions.jump, 0.06);
      }
    }

    function slide(){
      if(game.over||game.paused) return;
      if(!game.started) return;
      if(game.stopped) return;
      game.sliding=true;
      game.slideT=0.55;
      sfx.slide();
    }

    window.addEventListener('keydown', (e)=>{
      const k=e.key.toLowerCase();
      if(k==='arrowleft') moveLane(-1);
      if(k==='arrowright') moveLane(1);
      if(k==='arrowup' || k===' ') jump();
      if(k==='arrowdown') slide();
      if(k==='p') togglePause();
    });

    let touchStart=null;
    renderer.domElement.addEventListener('pointerdown',(e)=>{
      initAudio();
      renderer.domElement.setPointerCapture(e.pointerId);
      touchStart={x:e.clientX,y:e.clientY,t:performance.now()};
    });
    renderer.domElement.addEventListener('pointerup',(e)=>{
      if(!touchStart) return;
      const dx=e.clientX-touchStart.x, dy=e.clientY-touchStart.y;
      const adx=Math.abs(dx), ady=Math.abs(dy);
      touchStart=null;
      const min=30;
      if(adx<min && ady<min) return;
      if(adx>ady) moveLane(dx>0?1:-1);
      else { if(dy<0) jump(); else slide(); }
    });

    // ===== Start/Stop/Pause/Home/Dance =====
    function setStop(on){
      game.stopped = !!on;
      if(game.stopped){
        startIdleRandom(); // ‚úÖ stop = player fermo + idle random
      }else{
        if(game.started && !game.paused && !game.over) playRun();
      }
      updateMainButton();
    }

    function resetRun(){
      game.lane=1;
      game.y=0; game.vy=0; game.jumping=false;
      game.sliding=false; game.slideT=0;
      game.autoSlideCooldown=0;

      game.score=0; game.coins=0;
      game.ringCount=0;
      game.foodCount=0; game.foodHistory=[];

      game.invincibleT=0;
      game.foodBoostT=0;
      game.ringBoostT=0;
      game.magnetT=0;
      game.trioT=0;

      for(const e of game.entities) scene.remove(e.obj);
      game.entities.length=0;

      game.spawnT = 0.30;
      game.over=false;
      game.lives=3;

      game.lastTurtleZ = [-99999, -99999, -99999];

      game.started = false;
      game.paused = false;
      setStop(true);
      updateMainButton();
    }

    function startGame(){
      game.started = true;
      game.paused = false;
      setStop(false);
      playRun();
      btnPause.textContent = '‚è∏Ô∏è';
      updateMainButton();
    }

    function togglePause(){
      if(game.over) return;
      game.paused = !game.paused;
      btnPause.textContent = game.paused ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è';

      if(game.paused){
        startIdleRandom();
      }else{
        if(game.started && !game.stopped) playRun();
        else startIdleRandom();
      }
    }

    // ‚úÖ PULSANTE PRINCIPALE (Start / Stop / Restart)
    btnMain.addEventListener('click', ()=>{
      initAudio();

      // Restart quando morto
      if(game.over){
        resetRun();
        startGame();           // riparte subito
        return;
      }

      // Avvio prima volta
      if(!game.started){
        startGame();
        return;
      }

      // Toggle STOP mentre corre
      if(game.paused) return;
      setStop(!game.stopped);
    });

    // ‚úÖ Dance sotto (se stai correndo: si ferma e poi balla)
    btnDance.addEventListener('click', ()=>{
      initAudio();
      if(game.over) return;
      if(game.started && !game.paused && !game.stopped) setStop(true);
      playDance();
    });

    btnPause.addEventListener('click', ()=>{ initAudio(); togglePause(); });

    btnHome.addEventListener('click', ()=>{
      initAudio();
      resetRun();
    });

    // ===== Collisions / Life =====
    function loseLife(){
      if(game.invincibleT>0) return;
      game.lives = Math.max(0, game.lives-1);
      sfx.hit();
      if(game.lives<=0){
        game.over=true;
        game.started=false;
        game.paused=false;
        setStop(true);

        playDie();             // ‚úÖ anim morte
        updateMainButton();    // ‚úÖ diventa RESTART
      }
    }

    // ===== Update loop =====
    let camZ = baseCamZ, camY = 4.6, camFov = baseFov, camX = 0;
    let tPrev=performance.now();

    function update(dt, tNow){
      // ‚úÖ animazioni SEMPRE
      if(runnerMixer){
        runnerMixer.timeScale = 1.0;
        runnerMixer.update(dt);

        if(mixamoHips){
          mixamoHips.position.x = hipsBaseX;
          mixamoHips.position.z = hipsBaseZ;
        }
        if(mixamoRootNode){
          mixamoRootNode.position.x = rootBaseX;
          mixamoRootNode.position.z = rootBaseZ;
        }
      }

      const gameplayOn = game.started && !game.paused && !game.over;

      const stopTarget = game.stopped ? 1.0 : 0.0;
      game.stopBlend = damp(game.stopBlend, stopTarget, 8, dt);

      if(!gameplayOn){
  // ‚úÖ tieni SEMPRE il player centrato nella corsia centrale quando non si gioca
  runnerPivot.position.x = lanesX[1];   // corsia centrale
  runnerPivot.position.y = 0;

  // ‚úÖ anche l'ombra segue
  contact.position.x = runnerPivot.position.x;
  contact.scale.set(1.10, 1.10, 1);
  contact.material.opacity = 0.55;

  // idle breathing leggero
  const breathe = Math.sin(tNow*0.0022) * 0.015;
  runnerCenter.position.y = 0.95 + breathe;
  runnerCenter.rotation.z = Math.sin(tNow*0.0016) * 0.015;

  return;
}

      runnerCenter.position.y = 0.95;
      runnerCenter.rotation.z = 0;

      const trafficMul = (1.0 - game.stopBlend);
      if(game.stopped) return;

      const foodMul = (game.foodBoostT>0) ? 2.30 : 1.0;
      const ringMul = (game.ringBoostT>0) ? 3.00 : 1.0;
      const both = (game.foodBoostT>0 && game.ringBoostT>0);
      const crazyMul = both ? 1.03 : 1.0;

      const speedMul = foodMul * ringMul * crazyMul;
      const speed = game.baseSpeed * speedMul * trafficMul;

      const g=22.0;
      game.vy += g*dt;
      game.y  += game.vy*dt;
      if(game.y>0){ game.y=0; game.vy=0; game.jumping=false; }

      if(game.sliding){ game.slideT -= dt; if(game.slideT<=0) game.sliding=false; }

      runnerPivot.position.x = lanesX[game.lane<=2 ? game.lane : 2];
      runnerPivot.position.y = (-game.y);

      const h = runnerPivot.position.y;
      const s = 1.10 + clamp(h*0.65, 0, 0.85);
      contact.position.x = runnerPivot.position.x;
      contact.scale.set(s,s,1);
      contact.material.opacity = clamp(0.55 - h*0.24, 0.10, 0.55);

      const scroll = speed*dt;
      highwayTex.offset.y -= scroll*0.085;
      for(const t of patchTexPool) t.offset.y -= scroll*0.085;

      for(const mesh of segments){
        mesh.position.z += scroll;
        if(mesh.position.z > segLen) mesh.position.z -= segLen*segCount;
      }
      loopJungle(scroll);

      game.spawnT -= dt;
      if(game.spawnT<=0){
        spawnRow();
        game.spawnT = rnd(0.40, 0.75);
      }

      for(const e of game.entities){
        e.z += scroll;
        e.obj.position.z = e.z;
      }

      for(let i=game.entities.length-1;i>=0;i--){
        const e = game.entities[i];
        if(e.z > 6.0){
          scene.remove(e.obj);
          game.entities.splice(i,1);
        }
      }

      const px = runnerPivot.position.x;
      const py = runnerPivot.position.y + (game.sliding ? 0.70 : 0.95);

      function collide(e){
        const dz = Math.abs(e.z - 0.25);
        const dx = Math.abs(e.obj.position.x - px);
        const ey = (e.obj.position.y ?? 0);
        const dy = Math.abs(ey - py);
        return (dz < 0.75 && dx < 0.60 && dy < 1.05);
      }
      function collideTurtle(e){
        const dz = Math.abs(e.z - 0.35);
        const dx = Math.abs(e.obj.position.x - px);
        return (dz < 1.05 && dx < 0.72);
      }

      if(!game.sliding && game.y===0 && game.autoSlideCooldown<=0 && game.lane<=2){
        for(const e of game.entities){
          if(e.type!=='ring') continue;
          if(e.lane !== game.lane) continue;
          if(Math.abs(e.z - 0.25) < 2.55){
            playOneShot(actions.flip, 0.05);
            game.sliding = true;
            game.slideT  = 0.48;
            game.autoSlideCooldown = 0.24;
            break;
          }
        }
      }
      game.autoSlideCooldown = Math.max(0, game.autoSlideCooldown - dt);

      for(let i=game.entities.length-1;i>=0;i--){
        const e=game.entities[i];

        if(e.type==='ring'){
          if(!collide(e)) continue;
          if(!game.sliding) continue;
          game.ringCount += 1;
          scene.remove(e.obj); game.entities.splice(i,1);
          sfx.ring();
          continue;
        }

        if(e.type==='turtle'){
          if(!collideTurtle(e)) continue;
          playOneShot(actions.kick, 0.05);
          sfx.boost();
          scene.remove(e.obj); game.entities.splice(i,1);
          continue;
        }

        if(e.type==='obst'){
          if(!collide(e)) continue;
          scene.remove(e.obj); game.entities.splice(i,1);
          loseLife();
          continue;
        }
      }

      game.score += (18 * speedMul) * dt;
    }

    function animate(tNow){
      const dt=Math.min(0.030,(tNow-tPrev)/1000);
      tPrev=tNow;

      update(dt,tNow);

      const bothBoost = (game.foodBoostT>0 && game.ringBoostT>0);
      const anyBoost = (game.foodBoostT>0 || game.ringBoostT>0);

      const fovBoost = bothBoost ? 7 : (anyBoost ? 5 : 0);
      const zBoost   = bothBoost ? 0.9 : (anyBoost ? 0.5 : 0.0);

      const targetFov = clamp(baseFov + fovBoost, 30, 110);
      const targetZ   = clamp(baseCamZ + zBoost, 2, 15);

      const lookAtY = lerp(0.05, 1.45, framing);
      const lookAtZ = lerp(-22.0, -38.0, framing);
      const camYBase = lerp(3.9, 5.8, framing);

      camFov = damp(camFov, targetFov, 8, dt);
      camZ   = damp(camZ,   targetZ,   8, dt);
      camY   = damp(camY,   camYBase + (bothBoost?0.10:0), 8, dt);

      camera.fov = camFov;
      camera.updateProjectionMatrix();

      const targetCamX = clamp(runnerPivot.position.x * 0.35, -1.2, 1.6);
      camX = damp(camX, targetCamX, 6, dt);

      let shakeX = 0, shakeY = 0;
      if(anyBoost && shakeEnabled){
        const intensity = bothBoost ? 0.018 : 0.011;
        shakeX = Math.sin(tNow*0.020) * intensity;
        shakeY = Math.sin(tNow*0.027) * (intensity*0.55);
      }

      tiltTarget *= 0.92;
      camRoll = damp(camRoll, tiltTarget, 10, dt);

      const bob = Math.sin(tNow*0.0020) * 0.005;
      camera.position.set(camX + shakeX, camY + bob + shakeY, camZ);
      camera.rotation.z = camRoll;
      camera.lookAt(camX*0.35, lookAtY, lookAtZ);

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    function onResize(){
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onResize);

    // ===== Boot =====
    (async ()=>{
      syncCamUI();
      await loadRunnerModel();

      game.started = false;
      game.over = false;
      game.paused = false;
      setStop(true);
      updateMainButton();

      requestAnimationFrame(animate);
    })();
  </script>
</body>
</html>