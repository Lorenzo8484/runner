
<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Jungle Emoji Runner (Three.js)</title>

  <style>
    :root{
      color-scheme: dark;

      /* ===== SCALE richieste ===== */
      --menuScale: 1.50; /* Home, Impostazioni, Avvia, Dance, foodCount, foodItem (+50%) */
      --hudScale:  1.40; /* Score, Emoji, Anelli, Vita, Magnete, Boost, Cibo Boost (+40%) */
      --hudW:      0.70; /* -30% larghezza (0.70) */
      --hudPillH: 12px;  /* altezza base di TUTTE le pillole HUD */
      --camOffsetY: 12px;
      --hud-bar-w: 60px;

      /* ‚úÖ extra UI */
      --shakeBoostInt: 0.028; /* sar√† usato nel JS (shake pi√π intenso in boost) */
    }

    html,body{
      height:100%;
      margin:0;
      background:#040805;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      overflow:hidden;
    }
    canvas{display:block;touch-action:none;}

    /* =========================================================
       PILL FX
       ========================================================= */
    .pillFx{
      position:relative;
      border-radius:999px;
      color:#eaf1ff;
      background: linear-gradient(180deg, rgba(60,90,140,.28), rgba(12,16,26,.64));
      border:1px solid rgba(170,210,255,.22);
      backdrop-filter: blur(6px) saturate(1.2);
      -webkit-backdrop-filter: blur(6px) saturate(1.2);
      box-shadow:
        0 7px 22px rgba(0,0,0,.50),
        0 0 0 1px rgba(95,160,255,.10),
        0 0 9px rgba(110,175,255,.18),
        inset 0 1px 0 rgba(255,255,255,.13),
        inset 0 -1px 0 rgba(0,0,0,.28);
      -webkit-tap-highlight-color: transparent;
      transform: translateZ(0);
    }
    .pillFx::after{
      content:"";
      position:absolute;
      inset:-1px;
      border-radius:999px;
      pointer-events:none;
      background: radial-gradient(120% 140% at 20% 10%,
        rgba(145,205,255,.32),
        rgba(90,150,255,.10) 38%,
        rgba(0,0,0,0) 72%
      );
      filter: blur(.55px);
      opacity:.85;
      mix-blend-mode: screen;
    }
    .pillFx::before{
      content:"";
      position:absolute;
      inset:0;
      border-radius:999px;
      pointer-events:none;
      background: linear-gradient(180deg, rgba(255,255,255,.11), rgba(255,255,255,0) 55%);
      opacity:.70;
    }
    button.pillFx:active{ transform:scale(.985); }

    /* =========================================================
       ICON BASE
       ========================================================= */
    .ico{
      width:11px;
      height:11px;
      display:inline-block;
      flex:0 0 auto;
      filter: drop-shadow(0 5px 8px rgba(0,0,0,.55));
    }
    .icoSm{ width:9px; height:9px; }

    /* =========================================================
       HUD (sinistra) + TOP RIGHT
       ========================================================= */
    .hudWrap{
      position:fixed;
      top:calc(5px * var(--menuScale));
      left:calc(8px * var(--hudScale));
      z-index:28;
      pointer-events:none;
      width:min(
        calc(230px * var(--hudScale) * var(--hudW)),
        calc(100vw - calc(16px * var(--hudScale)))
      );
    }
    .hudCard{ pointer-events:none; background:transparent; border:none; padding:0; margin:0; }
    .hudGrid{
      display:grid;
      grid-template-columns: minmax(0,1fr) minmax(0,1fr);
      gap:calc(6px * var(--hudScale));
      align-items:start;
    }
    .hudP{
      pointer-events:none;
      padding:calc(4px * var(--hudScale)) calc(6px * var(--hudScale));
      border-radius:999px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:calc(5px * var(--hudScale));
      min-width:0;
      min-height:calc(var(--hudPillH) * var(--hudScale));
      line-height:1;
      overflow:hidden;
    }
    .hudHalf{ grid-column: span 1; }
    .hudFull{ grid-column: 1 / -1; }

    .hudL{
      display:flex;
      align-items:center;
      gap:calc(5px * var(--hudScale));
      min-width:0;
      line-height:1;
      overflow:hidden;
    }
    .hudT{
      font-weight:950;
      font-size:calc(7px * var(--hudScale));
      white-space:nowrap;
      line-height:1;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .hudV{
      font-weight:950;
      font-size:calc(8px * var(--hudScale));
      white-space:nowrap;
      line-height:1;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:calc(3px * var(--hudScale));
      overflow:hidden;
      text-overflow:ellipsis;
      min-width:0;
    }
    .hudWrap .ico{
      width:calc(11px * var(--hudScale));
      height:calc(11px * var(--hudScale));
    }

    /* ‚úÖ Score: numeri ‚Äúadattabili‚Äù (JS aggiorna anche font-size) */
    #score{
      display:inline-block;
      max-width:100%;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      font-variant-numeric: tabular-nums;
    }

    /* TOP RIGHT: Home + Impostazioni */
    .topLeftBtns{
      position:fixed;
      top:calc(5px * var(--menuScale));
      right:calc(8px * var(--hudScale));
      z-index:35;
      pointer-events:none;
    }
    .topLeftBtns .btnGroup.pillFx{
      pointer-events:auto;
      display:flex;
      align-items:center;
      justify-content:space-between;
      min-height:calc(var(--hudPillH) * var(--hudScale));
      padding:calc(4px * var(--hudScale)) calc(6px * var(--hudScale));
      box-sizing:border-box;
      width:calc(66px * var(--hudScale));
      flex:0 0 auto;
      gap:calc(6px * var(--hudScale));
    }
    .topLeftBtns .btnSub{
      pointer-events:auto;
      border:none;
      background:transparent;
      padding:0;
      margin:0;
      min-height:calc(var(--hudPillH) * var(--hudScale));
      height:calc(var(--hudPillH) * var(--hudScale));
      display:flex;
      align-items:center;
      justify-content:center;
      border-radius:999px;
    }
    .topLeftBtns .btnSub .ico{
      width:calc(13px * var(--hudScale) * 1.25);
      height:calc(13px * var(--hudScale) * 1.25);
    }

    /* LIFE pill fix */
    .lifePill{ display:flex; align-items:center; justify-content:center; }
    .lifePill .hudL{ display:none; }
    .lifePill .hudV{
      flex:1;
      width:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      line-height:1;
    }
    #hpTxt{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:100%;
      white-space:nowrap;
      line-height:1;
      font-size: calc(8px * var(--hudScale));
    }

    /* =========================================================
       BAR ROW (Magnete/Boost/FoodBoost)
       + ‚úÖ animazione barra ‚Äúdisponibile‚Äù (shimmer)
       ========================================================= */
    .hudBarRow{
      display:grid;
      grid-template-columns: auto calc(var(--hud-bar-w) * var(--hudScale) * var(--hudW)) auto;
      align-items:center;
      gap:calc(5px * var(--hudScale));
      min-width:0;
      width:100%;
      line-height:1;
    }
    .hudBar{
      height:calc(3px * var(--hudScale));
      width:calc(var(--hud-bar-w) * var(--hudScale) * var(--hudW));
      min-width:calc(var(--hud-bar-w) * var(--hudScale) * var(--hudW));
      max-width:calc(var(--hud-bar-w) * var(--hudScale) * var(--hudW));
      border-radius:999px;
      background:rgba(255,255,255,.12);
      overflow:hidden;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08);
      position:relative;
    }
    .hudBar>i{
      display:block;
      height:100%;
      width:0%;
      background:rgba(200,210,255,.88);
      box-shadow: 0 0 7px rgba(140,200,255,.22);
      position:relative;
      overflow:hidden;
    }
    .hudBar>i::after{
      content:"";
      position:absolute;
      inset:0;
      transform:translateX(-120%);
      background: linear-gradient(90deg,
        rgba(255,255,255,0) 0%,
        rgba(255,255,255,.18) 45%,
        rgba(255,255,255,0) 90%
      );
      filter: blur(.2px);
      opacity:.85;
      animation: barShimmer 1.15s linear infinite;
      pointer-events:none;
    }
    @keyframes barShimmer{
      0%{ transform:translateX(-120%); }
      100%{ transform:translateX(120%); }
    }
    /* shimmer solo quando attivo (JS aggiunge .barActive sulla pill) */
    .barActive .hudBar>i::after{ display:block; }
    .hudP:not(.barActive) .hudBar>i::after{ display:none; }

    #pillBoost #boostIcon{
      font-size:calc(9px * var(--hudScale));
      line-height:1;
      display:inline-block;
    }

    /* =========================================================
       DEBUG BUTTON
       ========================================================= */
    .debugRow{
      pointer-events:auto;
      display:flex;
      justify-content:flex-start;
      margin-top:calc(6px * var(--hudScale));
    }
    .dbgBtn{
      pointer-events:auto;
      border:none;
      background:transparent;
      cursor:pointer;
      user-select:none;
      height:calc(var(--hudPillH) * var(--hudScale));
      padding:calc(4px * var(--hudScale)) calc(6px * var(--hudScale));
      border-radius:999px;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .dbgBtn .ico{
      width:calc(10px * var(--menuScale) * 1.25);
      height:calc(10px * var(--menuScale) * 1.25);
    }

    /* =========================================================
       Start/Dance/Boost stack
       ‚úÖ ordine dal basso verso l‚Äôalto: DANCE, START, BOOST
       (quindi HTML: BOOST, START, DANCE)
       ========================================================= */
    .rightStack{
      position:fixed;
      right:calc(6px * var(--menuScale));
      bottom: calc(calc(8px * var(--menuScale)) + env(safe-area-inset-bottom, 0px) + calc(22px * var(--menuScale)));
      z-index:30;
      display:flex;
      flex-direction:column;
      gap:calc(5px * var(--menuScale));
      pointer-events:auto;
      align-items:flex-end;
    }

    .bigBtn{
      pointer-events:auto;
      position:relative;
      width:calc(70px * var(--menuScale) * 0.75);
      height:calc(20px * var(--menuScale) * 1.50);
      border-radius:999px;
      font-weight:950;
      font-size:calc(7px * var(--menuScale) * 1.125);
      letter-spacing:.25px;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:0;
      color:#eaf1ff;
      background:transparent;
      border:none;
      line-height:1;
      text-align:center;
      overflow:hidden;
    }
    .bigBtn .centerLbl{
      width:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      line-height:1;
      text-transform:uppercase;
    }

    /* ‚úÖ BOOST row: pulsante numero (corto) a sinistra + pulsante uso boost a destra */
    .boostRow{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap:calc(5px * var(--menuScale));
      pointer-events:auto;
    }
    .boostCountBtn{
      pointer-events:auto;
      width:calc(26px * var(--menuScale));
      height:calc(20px * var(--menuScale) * 1.50);
      border-radius:999px;
      border:none;
      background:transparent;
      color:#eaf1ff;
      font-weight:950;
      font-size:calc(7px * var(--menuScale) * 1.05);
      display:flex;
      align-items:center;
      justify-content:center;
      font-variant-numeric: tabular-nums;
      user-select:none;
      position:relative;
      overflow:hidden;
    }
    /* ‚úÖ animazione ‚Äúbella‚Äù sul numero boost (pulse + sheen) */
    .boostCountBtn.pulse{
      animation: boostPulse .38s ease-out;
    }
    @keyframes boostPulse{
      0%{ transform:scale(1); }
      55%{ transform:scale(1.10); }
      100%{ transform:scale(1); }
    }
    .boostCountBtn::after{
      content:"";
      position:absolute;
      inset:-2px;
      border-radius:999px;
      background: linear-gradient(110deg,
        rgba(255,255,255,0) 0%,
        rgba(255,255,255,.22) 40%,
        rgba(255,255,255,0) 80%
      );
      transform: translateX(-140%);
      opacity:.75;
      pointer-events:none;
    }
    .boostCountBtn.sheen::after{
      animation: boostSheen .85s ease-out;
    }
    @keyframes boostSheen{
      0%{ transform: translateX(-140%); }
      100%{ transform: translateX(140%); }
    }

    /* ‚úÖ pulsante boost disabilitato quando boost gi√† attivo (JS mette .disabled) */
    .bigBtn.disabled,
    .boostCountBtn.disabled{
      opacity:.45;
      filter:saturate(.85);
      pointer-events:none;
    }

    /* ‚úÖ animazione DANCE quando premi (JS aggiunge .danceOn su btnDance) */
    #btnDance.danceOn{
      animation: danceGlow .65s ease-in-out infinite alternate;
    }
    @keyframes danceGlow{
      0%{
        box-shadow:
          0 7px 22px rgba(0,0,0,.50),
          0 0 0 1px rgba(95,160,255,.10),
          0 0 12px rgba(140,200,255,.22),
          inset 0 1px 0 rgba(255,255,255,.13),
          inset 0 -1px 0 rgba(0,0,0,.28);
        transform: translateZ(0) scale(1);
      }
      100%{
        box-shadow:
          0 10px 28px rgba(0,0,0,.58),
          0 0 0 1px rgba(95,160,255,.14),
          0 0 22px rgba(155,220,255,.32),
          inset 0 1px 0 rgba(255,255,255,.16),
          inset 0 -1px 0 rgba(0,0,0,.30);
        transform: translateZ(0) scale(1.02);
      }
    }

    /* =========================================================
       Colonna cibo
       ‚úÖ barra fissa, cibi partono da sotto e accumulano verso il basso
       ========================================================= */
    .rightCol{
      position:fixed;
      top:calc(67px * var(--menuScale));
      right:calc(5px * var(--menuScale));
      width:calc(32px * var(--menuScale));
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:calc(5px * var(--menuScale));
      pointer-events:none;
      z-index:20;
    }

    /* ‚úÖ ora prima la ‚Äúbarra‚Äù (foodCount), poi lo stack dei cibi sotto */
    .foodCount{
      width:calc(60px * var(--menuScale));
      text-align:center;
      font-weight:950;
      font-size:calc(7px * var(--menuScale));
      padding:calc(4px * var(--menuScale)) 0;
      border-radius:999px;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:calc(4px * var(--menuScale));
      line-height:1;
      pointer-events:none;
    }
    .foodCount .icoSm{
      width:calc(9px * var(--menuScale));
      height:calc(9px * var(--menuScale));
    }

    .foodStack{
      width:calc(32px * var(--menuScale));
      max-height:calc(110px * var(--menuScale));
      overflow:hidden;
      display:flex;
      flex-direction:column;          /* ‚úÖ cresce verso il basso */
      align-items:center;
      justify-content:flex-start;
      gap:calc(5px * var(--menuScale));
      background:transparent;
      border:none;
      padding:0;
      pointer-events:none;
    }
    .foodItem{
      width:calc(27px * var(--menuScale));
      height:calc(15px * var(--menuScale));
      border-radius:999px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:calc(8px * var(--menuScale));
      line-height:1;
    }

    /* =========================================================
       SETTINGS + CAMERA SEG (come prima, invariato qui)
       ========================================================= */
    .settingsOverlay{
      position:fixed;
      inset:0;
      display:none;
      align-items:flex-start;
      justify-content:center;
      padding:14px;
      background:radial-gradient(ellipse at center, rgba(0,0,0,.15), rgba(0,0,0,.72));
      backdrop-filter:blur(10px);
      z-index:40;
    }

    .camSegWrap{
      position:fixed;
      right:calc(8px * var(--hudScale));
      left:auto;
      top:calc(
        (5px * var(--menuScale)) +
        (var(--hudPillH) * var(--hudScale)) +
        (6px * var(--hudScale)) +
        var(--camOffsetY)
      );
      z-index:36;
      pointer-events:auto;
      display:flex;
      justify-content:flex-end;
      width:fit-content;
    }
    .camSegPill{
      position:relative;
      overflow:hidden;
      padding:calc(4px * var(--hudScale)) calc(6px * var(--hudScale));
      border-radius:999px;
      display:grid;
      grid-template-columns:1fr 1fr 1fr;
      align-items:center;
      gap:0;
      width:calc(118px * var(--hudScale));
    }
    .camSegPill.pillFx{
      box-sizing:border-box;
      width:calc(90px * var(--hudScale));
    }
    .camSegBtn{
      -webkit-appearance:none;
      appearance:none;
      padding:0;
      margin:0;
      width:100%;
      pointer-events:auto;
      border:none;
      background:transparent;
      cursor:pointer;
      user-select:none;
      height:100%;
      min-height:calc(var(--hudPillH) * var(--hudScale));
      border-radius:999px;
      font-weight:950;
      font-size:calc(7px * var(--hudScale));
      letter-spacing:.25px;
      line-height:1;
      color:#eaf1ff;
      opacity:.9;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .camSegBtn.active{ opacity:1; }
    .camThumb{
      position:absolute;
      z-index:0;
      top:calc(2px * var(--hudScale));
      bottom:calc(2px * var(--hudScale));
      left:calc(2px * var(--hudScale));
      width:calc((100% - calc(4px * var(--hudScale))) / 3);
      border-radius:999px;
      box-sizing:border-box;
      background:linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.05));
      border:none;
      box-shadow:
        inset 0 0 0 1px rgba(145,205,255,.28),
        0 0 0 1px rgba(95,160,255,.12),
        0 0 12px rgba(110,175,255,.20),
        inset 0 1px 0 rgba(255,255,255,.18),
        inset 0 -1px 0 rgba(0,0,0,.25);
      transition:transform .18s ease;
    }
    .camSegWrap, .topLeftBtns{ z-index:35; }

    /* (resto SETTINGS CSS resta identico, lo continuo in PART 2 per non spezzare male) */

    /* Motion blur fake (solo boost) */
    canvas.blurBoost{
      filter: blur(0.9px) saturate(1.03);
    }

  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/"
    }
  }
  </script>
</head>

<body>

  <!-- ‚úÖ HUD SINISTRA -->
  <div class="hudWrap">
    <div class="hudCard">
      <div class="hudGrid">

        <!-- Score (sx) -->
        <div class="hudP pillFx hudHalf">
          <div class="hudL">
            <svg class="ico" viewBox="0 0 24 24" aria-hidden="true">
              <defs>
                <linearGradient id="gScoreIcon" x1="0" y1="0" x2="1" y2="1">
                  <stop offset="0" stop-color="#ffffff" stop-opacity=".95"/>
                  <stop offset=".45" stop-color="#cfe6ff" stop-opacity=".95"/>
                  <stop offset="1" stop-color="#7fb4ff" stop-opacity=".90"/>
                </linearGradient>
              </defs>
              <path fill="url(#gScoreIcon)" d="M12 13.2a4.2 4.2 0 1 0 0-8.4 4.2 4.2 0 0 0 0 8.4z"/>
              <path fill="rgba(0,0,0,.20)" d="M12 6.3a2.7 2.7 0 1 1 0 5.4 2.7 2.7 0 0 1 0-5.4z"/>
              <path fill="url(#gScoreIcon)" d="M7.2 13.1 5 21l4-2 3 2-2.1-7.9c-.9.5-1.9.8-2.7.0z" opacity=".95"/>
              <path fill="url(#gScoreIcon)" d="M16.8 13.1 19 21l-4-2-3 2 2.1-7.9c.9.5 1.9.8 2.7.0z" opacity=".95"/>
            </svg>
            <div class="hudT">Score</div>
          </div>
          <div class="hudV"><span id="score">0</span></div>
        </div>

        <!-- Emoji (dx) -->
        <div class="hudP pillFx hudHalf">
          <div class="hudL">
            <svg class="ico" viewBox="0 0 24 24" aria-hidden="true">
              <defs>
                <linearGradient id="gEmojiIcon" x1="0" y1="0" x2="1" y2="1">
                  <stop offset="0" stop-color="#ffffff" stop-opacity=".95"/>
                  <stop offset=".40" stop-color="#d6ffe9" stop-opacity=".95"/>
                  <stop offset="1" stop-color="#34c759" stop-opacity=".92"/>
                </linearGradient>
              </defs>
              <circle cx="12" cy="12" r="8" fill="url(#gEmojiIcon)"/>
              <circle cx="9.3" cy="10.2" r="1.1" fill="rgba(0,0,0,.28)"/>
              <circle cx="14.7" cy="10.2" r="1.1" fill="rgba(0,0,0,.28)"/>
              <path d="M8.7 14.1c1 .9 2.1 1.4 3.3 1.4s2.3-.5 3.3-1.4"
                    fill="none" stroke="rgba(0,0,0,.28)" stroke-width="1.7" stroke-linecap="round"/>
            </svg>
            <div class="hudT">Emoji</div>
          </div>
          <div class="hudV"><span id="coins">0</span></div>
        </div>

        <!-- Rings (sx) -->
        <div class="hudP pillFx hudHalf">
          <div class="hudL">
            <svg class="ico" viewBox="0 0 24 24" aria-hidden="true">
              <defs>
                <linearGradient id="gRingsIcon" x1="0" y1="0" x2="1" y2="1">
                  <stop offset="0" stop-color="#ffffff" stop-opacity=".95"/>
                  <stop offset=".45" stop-color="#ffd1d1" stop-opacity=".95"/>
                  <stop offset="1" stop-color="#ff3b30" stop-opacity=".92"/>
                </linearGradient>
              </defs>
              <path fill="url(#gRingsIcon)"
                    d="M12 4.5c-4.1 0-7.5 3.4-7.5 7.5S7.9 19.5 12 19.5s7.5-3.4 7.5-7.5S16.1 4.5 12 4.5zm0 3c2.5 0 4.5 2 4.5 4.5S14.5 16.5 12 16.5 7.5 14.5 7.5 12 9.5 7.5 12 7.5z"/>
              <path fill="rgba(255,255,255,.22)" d="M14.8 7.9c1.2.8 2 2.2 2 3.8 0 .5-.1 1-.2 1.4-.2.8-1.2.9-1.6.2-.2-.4-.3-.9-.3-1.4 0-1.1-.6-2.1-1.4-2.7-.6-.4-.3-1.7.5-1.3z"/>
            </svg>
            <div class="hudT">Rings</div>
          </div>
          <div class="hudV"><span id="rings">0</span></div>
        </div>

        <!-- Vita -->
        <div class="hudP pillFx hudHalf lifePill">
          <div class="hudL"></div>
          <div class="hudV">
            <span id="hpTxt">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏èüñ§üñ§</span>
          </div>
        </div>

        <!-- Magnete -->
        <div class="hudP pillFx hudFull" id="magPill">
          <div class="hudBarRow">
            <div class="hudL">
              <svg class="ico" viewBox="0 0 24 24" aria-hidden="true">
                <defs>
                  <linearGradient id="gMag" x1="0" y1="0" x2="1" y2="1">
                    <stop offset="0" stop-color="#ffffff" stop-opacity=".95"/>
                    <stop offset=".35" stop-color="#ffd1d1" stop-opacity=".95"/>
                    <stop offset="1" stop-color="#ff3b30" stop-opacity=".95"/>
                  </linearGradient>
                </defs>
                <path fill="url(#gMag)" d="M7 3h4v9a1 1 0 0 0 2 0V3h4v9c0 3.9-3.1 7-7 7s-7-3.1-7-7V3Z"/>
                <path fill="rgba(0,0,0,.25)" d="M7 3h4v2H7V3zm10 0h-4v2h4V3z"/>
              </svg>
              <div class="hudT">Magnete</div>
            </div>
            <div class="hudBar"><i id="magBar"></i></div>
            <div class="hudV"><span id="magTxt">üß≤ 0</span></div>
          </div>
        </div>

        <!-- Debug button -->
        <div class="debugRow">
          <button class="dbgBtn pillFx" id="btnDebug" title="Debug" type="button">
            <svg class="ico" viewBox="0 0 24 24" aria-hidden="true">
              <defs>
                <linearGradient id="gBug" x1="0" y1="0" x2="1" y2="1">
                  <stop offset="0" stop-color="#ffffff" stop-opacity=".98"/>
                  <stop offset=".45" stop-color="#d6ffe9" stop-opacity=".96"/>
                  <stop offset="1" stop-color="#34c759" stop-opacity=".92"/>
                </linearGradient>
              </defs>
              <path fill="url(#gBug)"
                d="M14 7.2c.6-.5 1-1.2 1-2 0-1.5-1.3-2.7-3-2.7S9 3.7 9 5.2c0 .8.4 1.5 1 2C7.7 8 6.2 10 6.2 12.4V14H5v1.6h1.2c.1.8.4 1.6.8 2.3l-1 .9 1 1.2 1.1-1c.9.7 2 .9 3.2.9s2.3-.2 3.2-.9l1.1 1 1-1.2-1-.9c.4-.7.7-1.5.8-2.3H19V14h-1.2v-1.6c0-2.4-1.5-4.4-3.8-5.2ZM8.8 14h6.4v1.6H8.8V14Zm0-3.2h6.4V12.4H8.8v-1.6Z"/>
            </svg>
          </button>
        </div>

        <!-- Boost (HUD pill, in alto a sinistra) -->
        <div class="hudP pillFx hudFull" id="pillBoost" style="display:none;">
          <div class="hudBarRow">
            <div class="hudL">
              <span id="boostIcon">‚ö°Ô∏è</span>
              <div class="hudT"><strong id="boostName">BOOST</strong></div>
            </div>
            <div class="hudBar"><i id="boostBar"></i></div>
            <div class="hudV"><span id="boostTime">0.0s</span></div>
          </div>
        </div>

        <!-- Food Boost (HUD pill) -->
        <div class="hudP pillFx hudFull" id="foodBoostPill" style="display:none;">
          <div class="hudBarRow">
            <div class="hudL">
              <svg class="ico" viewBox="0 0 24 24" aria-hidden="true">
                <defs>
                  <linearGradient id="gFoodBoost" x1="0" y1="0" x2="1" y2="1">
                    <stop offset="0" stop-color="#ffffff" stop-opacity=".95"/>
                    <stop offset=".4" stop-color="#d6ffe9" stop-opacity=".95"/>
                    <stop offset="1" stop-color="#34c759" stop-opacity=".92"/>
                  </linearGradient>
                </defs>
                <path fill="url(#gFoodBoost)" d="M8 7c0-2.2 1.8-4 4-4s4 1.8 4 4v1h1.2c1 0 1.8.8 1.8 1.8V19c0 1-.8 1.8-1.8 1.8H6.8C5.8 20.8 5 20 5 19V9.8C5 8.8 5.8 8 6.8 8H8V7Zm2 1h4V7c0-1.1-.9-2-2-2s-2 .9-2 2v1Z"/>
                <path fill="rgba(0,0,0,.22)" d="M7 12h10v2H7v-2z"/>
              </svg>
              <div class="hudT">Cibo</div>
            </div>
            <div class="hudBar"><i id="foodBoostBar"></i></div>
            <div class="hudV"><span id="foodBoostTime">0.0s</span></div>
          </div>
        </div>

      </div>

      <span id="best" style="display:none;">0</span>
    </div>
  </div>

  <!-- ‚úÖ TOP RIGHT: HOME + IMPOSTAZIONI -->
  <div class="topLeftBtns">
    <div class="btnGroup pillFx">
      <button class="btnSub" id="btnHome" type="button" title="Home">
        <svg class="ico" viewBox="0 0 24 24">
          <path fill="rgba(255,255,255,.95)"
            d="M12 3.2 3 10.5v9.3c0 .6.5 1 1 1h5.3v-6.1c0-.6.4-1 1-1h3.4c.6 0 1 .4 1 1v6.1H20c.6 0 1-.4 1-1v-9.3L12 3.2z"/>
        </svg>
      </button>

      <button class="btnSub" id="btnSettings" type="button" title="Impostazioni">
        <svg class="ico" viewBox="0 0 24 24">
          <path fill="rgba(255,255,255,.95)"
            d="M19.4 13.5c.04-.5.04-1 0-1.5l2-1.6c.2-.2.25-.5.12-.75l-1.9-3.3c-.13-.25-.43-.35-.7-.26l-2.35.95a7.9 7.9 0 0 0-1.3-.75l-.36-2.5A.63.63 0 0 0 14.3 3h-3.8c-.3 0-.56.22-.6.52l-.36 2.5c-.46.2-.9.45-1.3.75L5.9 5.82c-.27-.1-.57 0-.7.26L3.3 9.38c-.13.25-.08.56.12.75l2 1.6c-.04.5-.04 1 0 1.5l-2 1.6c-.2.2-.25.5-.12.75l1.9 3.3c.13.25.43.35.7.26l2.35-.95c.4.3.84.56 1.3.75l.36 2.5c.04.3.3.52.6.52h3.8c.3 0 .56-.22.6-.52l.36-2.5c.46-.2.9-.45 1.3-.75l2.35.95c.27.1.57 0 .7-.26l1.9-3.3c.13-.25.08-.56-.12-.75l-2-1.6z"/>
        </svg>
      </button>
    </div>
  </div>

  <!-- Camera BACK / FPS / FRONT (UNICA) -->
  <div class="camSegWrap">
    <div class="camSegPill pillFx" aria-label="Camera">
      <span class="camThumb" id="camThumb"></span>
      <button class="camSegBtn" id="btnCamBack"  type="button">BACK</button>
      <button class="camSegBtn" id="btnCamFPS"   type="button">FPS</button>
      <button class="camSegBtn" id="btnCamFront" type="button">FRONT</button>
    </div>
  </div>

  <!-- live FPS toggle (nascosto, serve al JS) -->
  <button class="camBtn pillFx" id="btnFpsLive" style="display:none;" type="button">
    FPS: REAL
  </button>

  <!-- ‚úÖ Right stack: TOP->BOTTOM = BOOST, START, DANCE -->
  <div class="rightStack">

    <!-- ‚úÖ BOOST (sopra START) -->
    <div class="boostRow" id="boostRow" style="display:none;">
      <button class="boostCountBtn pillFx" id="btnBoostCount" type="button" aria-label="Boost disponibili">
        <span id="boostCountLbl">0</span>
      </button>

      <button class="bigBtn pillFx" id="btnFoodBoost" type="button" aria-label="Usa boost">
        <span class="centerLbl" id="foodBoostLbl">BOOST</span>
      </button>
    </div>

    <!-- START -->
    <button class="bigBtn pillFx" id="btnMain" type="button">
      <span class="centerLbl" id="mainLbl">AVVIA</span>
    </button>

    <!-- DANCE (bottom) -->
    <button class="bigBtn pillFx" id="btnDance" type="button">
      <span class="centerLbl">DANCE</span>
    </button>

  </div>

  <!-- ‚úÖ Colonna cibo: barra fissa sopra, cibi sotto -->
  <div class="rightCol">
    <div class="foodCount pillFx">
      <svg class="icoSm" viewBox="0 0 24 24" aria-hidden="true">
        <defs>
          <linearGradient id="gBag" x1="0" y1="0" x2="1" y2="1">
            <stop offset="0" stop-color="#ffffff" stop-opacity=".95"/>
            <stop offset=".4" stop-color="#d6ffe9" stop-opacity=".95"/>
            <stop offset="1" stop-color="#34c759" stop-opacity=".92"/>
          </linearGradient>
        </defs>
        <path fill="url(#gBag)" d="M8 7c0-2.2 1.8-4 4-4s4 1.8 4 4v1h1.2c1 0 1.8.8 1.8 1.8V19c0 1-.8 1.8-1.8 1.8H6.8C5.8 20.8 5 20 5 19V9.8C5 8.8 5.8 8 6.8 8H8V7z"/>
      </svg>
      <span><span id="foodCount">0</span>/10</span>
    </div>

    <div class="foodStack" id="foodStack"></div>
  </div>



  <!-- DEBUG PANEL -->
  <div class="debugPanel pillFx" id="debugPanel" style="display:none;">
    <div class="dbgRow"><b>DEBUG</b><span class="dbgSmall" id="dbgFps">fps: --</span></div>
    <div class="dbgSep"></div>
    <div class="dbgRow"><span>camera</span><span id="dbgCam">--</span></div>
    <div class="dbgRow"><span>mode</span><span id="dbgMode">--</span></div>
    <div class="dbgRow"><span>state</span><span id="dbgState">--</span></div>
    <div class="dbgRow"><span>entities</span><span id="dbgEnt">--</span></div>
    <div class="dbgRow"><span>lane</span><span id="dbgLane">--</span></div>
    <div class="dbgRow"><span>boosts</span><span id="dbgBoosts">--</span></div>
  </div>

  <!-- SETTINGS -->
  <div class="settingsOverlay" id="settingsOverlay">
    <div class="panel pillFx">

      <!-- ‚ùå X CHIUSURA -->
      <button class="settingsClose pillFx" id="btnCloseSettings" aria-label="Chiudi impostazioni">
        ‚úï
      </button>

      <div class="settingsTop">
        <div class="title">Impostazioni</div>
        <div class="tabs pillFx" aria-label="Tabs impostazioni">
          <button class="tabBtn active" id="tabCam">CAMERA</button>
          <button class="tabBtn" id="tabVisual">VISUAL</button>
          <button class="tabBtn" id="tabAudio">AUDIO</button>
        </div>
      </div>

      <div class="settingsBody" id="settingsBody">

        <!-- CAMERA TAB -->
        <div class="card" data-tab="cam">
          <h3>Camera</h3>

          <div class="settingsRow">
            <div><label>FOV</label><br><small>30‚Äì110 (base 60)</small></div>
            <div class="settingsVal" id="fovVal">60</div>
          </div>
          <input id="fovSlider" type="range" min="30" max="110" step="1" value="60" />

          <div class="settingsRow">
            <div><label>Distanza camera</label><br><small>2‚Äì15 (base 5.0)</small></div>
            <div class="settingsVal" id="camVal">5.0</div>
          </div>
          <input id="camSlider" type="range" min="2" max="15" step="0.1" value="5.0" />

          <div class="settingsRow">
            <div><label>Altezza camera</label><br><small>0=terra ‚Ä¢ 8=alto</small></div>
            <div class="settingsVal" id="camYVal">4.6</div>
          </div>
          <input id="camYSlider" type="range" min="0" max="8" step="0.1" value="4.6" />

          <!-- ‚úÖ NEW: slider altezza FPS (richiesto) -->
          <div class="settingsRow">
            <div><label>Altezza visuale (FPS)</label><br><small>1.2=bassa ‚Ä¢ 2.2=alta</small></div>
            <div class="settingsVal" id="fpsYVal">1.58</div>
          </div>
          <input id="fpsYSlider" type="range" min="1.2" max="2.2" step="0.01" value="1.58" />

          <div class="settingsRow">
            <div><label>Inquadratura player</label><br><small>0=alto ‚Ä¢ 1=molto in basso</small></div>
            <div class="settingsVal" id="frameVal">0.06</div>
          </div>
          <input id="frameSlider" type="range" min="0" max="1" step="0.01" value="0.06" />

          <!-- ‚úÖ ‚ÄúPreview mode slider‚Äù: quando tocchi uno slider, nascondo impostazioni e resta solo la linea -->
          <div id="sliderPreviewHint" class="dbgSmall" style="opacity:.7;margin-top:10px;">
            Suggerimento: tieni premuto e trascina uno slider per vedere il player pulito.
          </div>
        </div>

        <!-- VISUAL TAB -->
        <div class="card" data-tab="visual" style="display:none;">
          <h3>Visual (FPS)</h3>

          <div class="toggle" id="fpsModeToggle">
            <div>
              <label>FPS</label><br/>
              <span>Realistico: bob + elasticit√†. Stabile: camera ‚Äúferma‚Äù.</span>
            </div>
            <div class="seg pillFx" id="fpsSeg">
              <button class="segBtn" id="btnFpsReal">REALISTICO</button>
              <button class="segBtn" id="btnFpsStable">STABILE</button>
            </div>
          </div>

          <div class="toggle" id="motionToggle">
            <div>
              <label>Motion blur</label><br/>
              <span>Fake blur solo durante i boost (leggero).</span>
            </div>
            <div class="switch" id="motionSwitch"><i></i></div>
          </div>

          <div class="toggle" id="dynFovToggle">
            <div>
              <label>FOV dinamico (FPS)</label><br/>
              <span>Aumenta il FOV solo in boost quando sei in FPS.</span>
            </div>
            <div class="switch on" id="dynFovSwitch"><i></i></div>
          </div>

          <div class="toggle" id="shakeToggle">
            <div><label>Camera shake</label><br/><span>Micro shake durante i boost (non in FPS).</span></div>
            <div class="switch on" id="shakeSwitch"><i></i></div>
          </div>
        </div>

        <!-- AUDIO TAB -->
        <div class="card" data-tab="audio" style="display:none;">
          <h3>Audio</h3>

          <div class="toggle" id="audioToggle">
            <div><label>Suoni</label><br/><span>Fallback semplice (stabile su iPhone).</span></div>
            <div class="switch on" id="audioSwitch"><i></i></div>
          </div>
        </div>

      </div>

      <div class="settingsFooter">
        <button class="btnGroup pillFx" id="resetCam">Reset</button>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    /* =========================================================
       ‚úÖ MINI FIX ‚ÄúSAFE‚Äù
       ========================================================= */
    const $ = (id)=>document.getElementById(id);
    function safeOn(el, ev, fn){ if(el) el.addEventListener(ev, fn, { passive:false }); }

    window.addEventListener('error', (e)=>{
      console.warn('JS error caught:', e?.message || e);
    });

    const IS_IOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

    // ===== UI: HUD =====
    const scoreEl = $('score');
    const coinsEl = $('coins');
    const bestEl  = $('best'); // hidden
    const ringsEl = $('rings');
    const hpTxt   = $('hpTxt');
    const magTxt  = $('magTxt');

    const magPill  = $('magPill');
    const magBar   = $('magBar');

    const pillBoost = $('pillBoost');
    const boostIcon = $('boostIcon');
    const boostName = $('boostName');
    const boostBar  = $('boostBar');
    const boostTime = $('boostTime');

    const foodBoostPill = $('foodBoostPill');
    const foodBoostBar  = $('foodBoostBar');
    const foodBoostTime = $('foodBoostTime');

    const foodStack = $('foodStack');
    const foodCountEl = $('foodCount');

    // ===== UI: Buttons =====
    const btnHome = $('btnHome');
    const btnSettings = $('btnSettings');

    const boostRow = $('boostRow');
    const btnFoodBoost = $('btnFoodBoost');      // usa boost
    const foodBoostLbl = $('foodBoostLbl');      // testo ‚ÄúBOOST‚Äù
    const btnBoostCount = $('btnBoostCount');    // pillola numero
    const boostCountLbl = $('boostCountLbl');    // numero

    const btnMain = $('btnMain');
    const mainLbl = $('mainLbl');
    const btnDance = $('btnDance');
    const rightStack = document.querySelector('.rightStack');

    // Camera buttons
    const btnCamBack  = $('btnCamBack');
    const btnCamFPS   = $('btnCamFPS');
    const btnCamFront = $('btnCamFront');
    const camThumb    = $('camThumb');
    
    safeOn(btnCamBack,  'click', ()=>{ initAudio(); applyViewMode('back');  });
    safeOn(btnCamFPS,   'click', ()=>{ initAudio(); applyViewMode('fps');   });
    safeOn(btnCamFront, 'click', ()=>{ initAudio(); applyViewMode('front'); });
    
    // Debug
    const btnDebug = $('btnDebug');
    const debugPanel = $('debugPanel');
    const dbgFps = $('dbgFps');
    const dbgCam = $('dbgCam');
    const dbgMode = $('dbgMode');
    const dbgState = $('dbgState');
    const dbgEnt = $('dbgEnt');
    const dbgLane = $('dbgLane');
    const dbgBoosts = $('dbgBoosts');

    // ===== Settings overlay =====
    const settingsOverlay  = $('settingsOverlay');
    const closeSettingsBtn = $('btnCloseSettings');
    const resetCamBtn      = $('resetCam');

    // Tabs
    const tabCam    = $('tabCam');
    const tabVisual = $('tabVisual');
    const tabAudio  = $('tabAudio');

    // Toggles / UI refs
    const audioToggle  = $('audioToggle');
    const audioSwitch  = $('audioSwitch');

    const shakeToggle  = $('shakeToggle');
    const shakeSwitch  = $('shakeSwitch');

    const btnFpsReal   = $('btnFpsReal');
    const btnFpsStable = $('btnFpsStable');
    const btnFpsLive   = $('btnFpsLive');

    const motionToggle = $('motionToggle');
    const motionSwitch = $('motionSwitch');

    const dynFovToggle = $('dynFovToggle');
    const dynFovSwitch = $('dynFovSwitch');

    const fovSlider  = $('fovSlider');
    const camSlider  = $('camSlider');
    const camYSlider = $('camYSlider');
    const fpsYSlider = $('fpsYSlider');   // ‚úÖ NEW
    const frameSlider= $('frameSlider');

    const fovVal   = $('fovVal');
    const camVal   = $('camVal');
    const camYVal  = $('camYVal');
    const fpsYVal  = $('fpsYVal');        // ‚úÖ NEW
    const frameVal = $('frameVal');

    const rnd=(a,b)=>a+Math.random()*(b-a);
    const rndi=(a,b)=>Math.floor(rnd(a,b+1));
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp=(a,b,t)=>a+(b-a)*t;
    const damp = (current, target, lambda, dt) => current + (target-current) * (1 - Math.exp(-lambda*dt));

    /* =========================================================
       ‚úÖ SETTINGS + save
       ========================================================= */
    const CAM_KEY = 'jr_cam_settings_v11';
    const DEFAULTS = {
      baseFov: 60,
      baseCamZ: 5.0,
      baseCamY: 4.6,
      fpsEyeY: 1.58,   // ‚úÖ NEW
      framing: 0.06,
      shake: true,
      view: 'front',
      debug: false,
      motionBlur: true,
      fpsRealistic: true,
      fpsDynFov: true
    };

    const saved = (()=>{ try{return JSON.parse(localStorage.getItem(CAM_KEY)||'{}')}catch{return {}} })();

    let baseFov  = clamp(Number(saved.baseFov ?? DEFAULTS.baseFov), 30, 110);
    let baseCamZ = clamp(Number(saved.baseCamZ ?? DEFAULTS.baseCamZ), 2, 15);
    let baseCamY = clamp(Number(saved.baseCamY ?? DEFAULTS.baseCamY), 0, 8);
    let fpsEyeY  = clamp(Number(saved.fpsEyeY  ?? DEFAULTS.fpsEyeY), 1.2, 2.2);  // ‚úÖ NEW
    let framing  = clamp(Number(saved.framing ?? DEFAULTS.framing), 0, 1);

    let shakeEnabled = (saved.shake ?? DEFAULTS.shake) !== false;
    let motionBlurEnabled = (saved.motionBlur ?? DEFAULTS.motionBlur) !== false;

    let viewMode = (saved.view ?? DEFAULTS.view);
    if(!['front','back','fps'].includes(viewMode)) viewMode = 'front';

    let debugOn = !!(saved.debug ?? DEFAULTS.debug);
    let fpsRealistic = (saved.fpsRealistic ?? DEFAULTS.fpsRealistic) !== false;
    let fpsDynFov    = (saved.fpsDynFov ?? DEFAULTS.fpsDynFov) !== false;

    function saveCam(){
      localStorage.setItem(CAM_KEY, JSON.stringify({
        baseFov, baseCamZ, baseCamY, fpsEyeY, framing,
        shake: !!shakeEnabled,
        motionBlur: !!motionBlurEnabled,
        view: viewMode,
        debug: !!debugOn,
        fpsRealistic: !!fpsRealistic,
        fpsDynFov: !!fpsDynFov
      }));
    }

    function setSettingsTab(tab){
      if(!settingsOverlay) return;
      const cards = settingsOverlay.querySelectorAll('.card');
      for(const c of cards){
        const t = c.getAttribute('data-tab');
        c.style.display = (t === tab) ? 'block' : 'none';
      }
      if(tabCam)    tabCam.classList.toggle('active', tab === 'cam');
      if(tabVisual) tabVisual.classList.toggle('active', tab === 'visual');
      if(tabAudio)  tabAudio.classList.toggle('active', tab === 'audio');
    }

    function openSettings(){
      if(!settingsOverlay) return;
      settingsOverlay.style.display = 'flex';
      try { syncCamUI && syncCamUI(); } catch(e){ console.warn('syncCamUI error:', e); }
      setSettingsTab('cam');
    }
    function closeSettings(){
      if(!settingsOverlay) return;
      settingsOverlay.style.display = 'none';
      exitSliderPreview(); // ‚úÖ se eri in preview slider, esci
    }

    safeOn(tabCam,    'click', ()=>setSettingsTab('cam'));
    safeOn(tabVisual, 'click', ()=>setSettingsTab('visual'));
    safeOn(tabAudio,  'click', ()=>setSettingsTab('audio'));

    safeOn(btnSettings, 'click', ()=>{ initAudio(); openSettings(); });
    safeOn(closeSettingsBtn, 'click', (e)=>{ e.preventDefault(); closeSettings(); });

    window.addEventListener('keydown', (e)=>{
      if(e.key === 'Escape' && settingsOverlay && settingsOverlay.style.display === 'flex'){
        closeSettings();
      }
    });
    safeOn(settingsOverlay, 'pointerdown', (e)=>{
      if(e.target === settingsOverlay) closeSettings();
    });

    function setCamThumb(mode){
      if(!camThumb) return;
      const idx = (mode==='back') ? 0 : (mode==='fps') ? 1 : 2;
      camThumb.style.transform = `translateX(${idx*100}%)`;
    }
    function setActiveCamBtns(){
      if(btnCamBack)  btnCamBack.classList.toggle('active', viewMode==='back');
      if(btnCamFPS)   btnCamFPS.classList.toggle('active', viewMode==='fps');
      if(btnCamFront) btnCamFront.classList.toggle('active', viewMode==='front');
      setCamThumb(viewMode);
    }
    
    

    function setDebugUI(){
      if(debugPanel) debugPanel.style.display = debugOn ? 'block' : 'none';
    }

    /* ‚úÖ slider ‚Äúpreview mode‚Äù:
       - quando tocchi/trascini uno slider: nascondo pannello e lascio solo una linea sottile
       - rilasciando: torna tutto */
    let previewingSlider = null;
    function enterSliderPreview(sliderEl){
      if(!settingsOverlay) return;
      if(!sliderEl) return;
      previewingSlider = sliderEl;

      const panel = settingsOverlay.querySelector('.panel');
      if(panel) panel.style.opacity = '0.0';

      // lascia solo una linea sottile dello slider
      sliderEl.style.position = 'fixed';
      sliderEl.style.left = '12px';
      sliderEl.style.right = '12px';
      sliderEl.style.bottom = '12px';
      sliderEl.style.top = 'auto';
      sliderEl.style.zIndex = '9999';
      sliderEl.style.height = '18px';
      sliderEl.style.opacity = '0.95';

      // riduco il ‚Äúclick‚Äù sul resto
      settingsOverlay.style.background = 'rgba(0,0,0,0.08)';
      settingsOverlay.style.backdropFilter = 'blur(2px)';
    }
    function exitSliderPreview(){
      if(!previewingSlider || !settingsOverlay) return;
      const sliderEl = previewingSlider;
      previewingSlider = null;

      const panel = settingsOverlay.querySelector('.panel');
      if(panel) panel.style.opacity = '';

      // ripristina stile inline slider
      sliderEl.style.position = '';
      sliderEl.style.left = '';
      sliderEl.style.right = '';
      sliderEl.style.bottom = '';
      sliderEl.style.top = '';
      sliderEl.style.zIndex = '';
      sliderEl.style.height = '';
      sliderEl.style.opacity = '';

      settingsOverlay.style.background = '';
      settingsOverlay.style.backdropFilter = '';
    }

    function hookSliderPreview(sl){
      if(!sl) return;
      safeOn(sl, 'pointerdown', (e)=>{ e.preventDefault(); enterSliderPreview(sl); });
      safeOn(sl, 'pointerup',   ()=>{ exitSliderPreview(); });
      safeOn(sl, 'pointercancel',()=>{ exitSliderPreview(); });
      safeOn(sl, 'lostpointercapture',()=>{ exitSliderPreview(); });
    }
    hookSliderPreview(fovSlider);
    hookSliderPreview(camSlider);
    hookSliderPreview(camYSlider);
    hookSliderPreview(fpsYSlider);
    hookSliderPreview(frameSlider);

    function syncCamUI(){
      if(fovSlider){ fovSlider.value = String(Math.round(baseFov)); }
      if(fovVal){ fovVal.textContent = String(Math.round(baseFov)); }

      if(camSlider){ camSlider.value = String(baseCamZ.toFixed(1)); }
      if(camVal){ camVal.textContent = baseCamZ.toFixed(1); }

      if(camYSlider){ camYSlider.value = String(baseCamY.toFixed(1)); }
      if(camYVal){ camYVal.textContent = baseCamY.toFixed(1); }

      if(fpsYSlider){ fpsYSlider.value = String(fpsEyeY.toFixed(2)); }
      if(fpsYVal){ fpsYVal.textContent = fpsEyeY.toFixed(2); }

      if(frameSlider){ frameSlider.value = String(framing.toFixed(2)); }
      if(frameVal){ frameVal.textContent = framing.toFixed(2); }

      if(shakeSwitch){ shakeSwitch.classList.toggle('on', !!shakeEnabled); }
      if(audioSwitch){ audioSwitch.classList.toggle('on', !!audioEnabled); }

      if(btnFpsReal)   btnFpsReal.classList.toggle('active', !!fpsRealistic);
      if(btnFpsStable) btnFpsStable.classList.toggle('active', !fpsRealistic);

      if(motionSwitch) motionSwitch.classList.toggle('on', !!motionBlurEnabled);
      if(dynFovSwitch) dynFovSwitch.classList.toggle('on', !!fpsDynFov);

      if(btnFpsLive){ btnFpsLive.style.display = 'none'; }

      setActiveCamBtns();
      setDebugUI();
    }

    safeOn(fovSlider,'input', ()=>{ baseFov = clamp(Number(fovSlider.value), 30, 110); if(fovVal) fovVal.textContent = String(Math.round(baseFov)); saveCam(); });
    safeOn(camSlider,'input', ()=>{ baseCamZ = clamp(Number(camSlider.value), 2, 15); if(camVal) camVal.textContent = baseCamZ.toFixed(1); saveCam(); });
    safeOn(camYSlider,'input',()=>{ baseCamY = clamp(Number(camYSlider.value), 0, 8); if(camYVal) camYVal.textContent = baseCamY.toFixed(1); saveCam(); });
    safeOn(fpsYSlider,'input',()=>{ fpsEyeY = clamp(Number(fpsYSlider.value), 1.2, 2.2); if(fpsYVal) fpsYVal.textContent = fpsEyeY.toFixed(2); saveCam(); });
    safeOn(frameSlider,'input',()=>{ framing = clamp(Number(frameSlider.value), 0, 1); if(frameVal) frameVal.textContent = framing.toFixed(2); saveCam(); });

    function setFpsMode(real){
      fpsRealistic = !!real;
      saveCam();
      syncCamUI();
    }
    safeOn(btnFpsReal,'click', ()=>{ initAudio(); setFpsMode(true); });
    safeOn(btnFpsStable,'click',()=>{ initAudio(); setFpsMode(false); });
    safeOn(btnFpsLive,'click', ()=>{ initAudio(); setFpsMode(!fpsRealistic); });

    safeOn(shakeToggle,'click', ()=>{
      shakeEnabled = !shakeEnabled;
      if(shakeSwitch) shakeSwitch.classList.toggle('on', !!shakeEnabled);
      saveCam();
    });

    safeOn(motionToggle,'click', ()=>{
      initAudio();
      motionBlurEnabled = !motionBlurEnabled;
      if(motionSwitch) motionSwitch.classList.toggle('on', !!motionBlurEnabled);
      saveCam();
    });

    safeOn(dynFovToggle,'click', ()=>{
      initAudio();
      fpsDynFov = !fpsDynFov;
      if(dynFovSwitch) dynFovSwitch.classList.toggle('on', !!fpsDynFov);
      saveCam();
    });

    safeOn(resetCamBtn,'click', ()=>{
      baseFov = DEFAULTS.baseFov;
      baseCamZ = DEFAULTS.baseCamZ;
      baseCamY = DEFAULTS.baseCamY;
      fpsEyeY  = DEFAULTS.fpsEyeY;
      framing  = DEFAULTS.framing;
      shakeEnabled = DEFAULTS.shake;
      viewMode = DEFAULTS.view;
      debugOn = DEFAULTS.debug;
      fpsRealistic = DEFAULTS.fpsRealistic;
      fpsDynFov = DEFAULTS.fpsDynFov;
      motionBlurEnabled = DEFAULTS.motionBlur;
      saveCam();
      syncCamUI();
      applyViewMode(viewMode);
    });

    // ===== Audio minimal =====
    let audioEnabled=true, audioReady=false, actx=null, master=null;
    function initAudio(){
      if(audioReady) return;
      try{
        actx = new (window.AudioContext||window.webkitAudioContext)();
        master = actx.createGain(); master.gain.value=0.55; master.connect(actx.destination);
        audioReady=true;
      }catch(e){ audioEnabled=false; }
      if(audioSwitch) audioSwitch.classList.toggle('on',!!audioEnabled);
    }
    function beep(type,freq,dur=0.06,g=0.10){
      if(!audioEnabled) return;
      initAudio(); if(!audioReady) return;
      const t0=actx.currentTime;
      const o=actx.createOscillator();
      const gg=actx.createGain();
      o.type=type; o.frequency.setValueAtTime(freq,t0);
      gg.gain.setValueAtTime(0.0001,t0);
      gg.gain.exponentialRampToValueAtTime(g,t0+0.012);
      gg.gain.exponentialRampToValueAtTime(0.0001,t0+dur);
      o.connect(gg); gg.connect(master);
      o.start(t0); o.stop(t0+dur+0.02);
    }
    const sfx = {
      coin: ()=>{ beep('triangle', 900, 0.06, 0.10); beep('sine', 1350, 0.07, 0.07); },
      food: ()=>{ beep('sine', 520, 0.06, 0.09); },
      ring: ()=>{ beep('triangle', 700, 0.06, 0.10); },
      magnet: ()=>{ beep('sawtooth', 420, 0.10, 0.09); beep('triangle', 880, 0.10, 0.07); },
      hit:  ()=>{ beep('square', 120, 0.12, 0.11); },
      lane: ()=>{ beep('sine', 160, 0.05, 0.05); },
      jump: ()=>{ beep('square', 420, 0.05, 0.08); },
      slide:()=>{ beep('sine', 220, 0.06, 0.06); },
      boost:()=>{ beep('sawtooth', 520, 0.10, 0.09); beep('triangle', 880, 0.10, 0.07); },
      ui:   ()=>{ beep('triangle', 980, 0.04, 0.06); }
    };
    safeOn(audioToggle,'click', ()=>{ initAudio(); audioEnabled=!audioEnabled; if(audioSwitch) audioSwitch.classList.toggle('on',!!audioEnabled); });

   

    // ===== Renderer / Scene =====
    const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();

    // ‚úÖ FIX: evita qualsiasi ‚Äúflip‚Äù strano
    // (alcuni device/webview possono fare casino se camera.up viene toccato altrove)
    function hardFixCameraUp(){
      camera.up.set(0,1,0);
      camera.rotation.order = 'YXZ';
    }

    // =========================================================
    // ‚úÖ SKY NATURALE: gradiente + nuvole + raggi sole (realistico)
    // =========================================================
    function makeSkyDome(){
      const geo = new THREE.SphereGeometry(180, 32, 20);
      const mat = new THREE.ShaderMaterial({
        side: THREE.BackSide,
        depthWrite:false,
        uniforms:{
          topCol:   { value: new THREE.Color(0x74b9ff) },  // azzurro
          midCol:   { value: new THREE.Color(0xbfe7ff) },  // chiaro
          botCol:   { value: new THREE.Color(0xe9f6ff) },  // vicino orizzonte
          sunDir:   { value: new THREE.Vector3(0.4,0.65,0.3).normalize() },
          haze:     { value: 0.55 },
          time:     { value: 0.0 },
        },
        vertexShader: `
          varying vec3 vPos;
          void main(){
            vPos = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
          }
        `,
        fragmentShader: `
          precision highp float;
          varying vec3 vPos;
          uniform vec3 topCol;
          uniform vec3 midCol;
          uniform vec3 botCol;
          uniform vec3 sunDir;
          uniform float haze;
          uniform float time;

          float hash(vec2 p){
            p = fract(p*vec2(123.34, 456.21));
            p += dot(p,p+45.32);
            return fract(p.x*p.y);
          }
          float noise(vec2 p){
            vec2 i = floor(p);
            vec2 f = fract(p);
            float a = hash(i);
            float b = hash(i+vec2(1,0));
            float c = hash(i+vec2(0,1));
            float d = hash(i+vec2(1,1));
            vec2 u = f*f*(3.0-2.0*f);
            return mix(a,b,u.x) + (c-a)*u.y*(1.0-u.x) + (d-b)*u.x*u.y;
          }
          float fbm(vec2 p){
            float v=0.0;
            float a=0.5;
            for(int i=0;i<5;i++){
              v += a*noise(p);
              p *= 2.03;
              a *= 0.5;
            }
            return v;
          }

          void main(){
            vec3 n = normalize(vPos);
            float h = clamp(n.y*0.5 + 0.5, 0.0, 1.0);

            // base gradiente cielo
            vec3 col = mix(botCol, midCol, smoothstep(0.0, 0.55, h));
            col = mix(col, topCol, smoothstep(0.45, 1.0, h));

            // alone e foschia orizzonte
            float hazeAmt = (1.0 - h);
            col += vec3(1.0,1.0,1.0) * hazeAmt * 0.06 * haze;

            // raggi di sole ‚Äúsoft‚Äù
            float sd = max(dot(n, sunDir), 0.0);
            float sunCore = pow(sd, 140.0) * 0.9;
            float sunGlow = pow(sd, 18.0) * 0.22;
            col += vec3(1.0, 0.96, 0.86) * (sunCore + sunGlow);

            // ‚Äúgod rays‚Äù leggeri (finti) vicino sole
            float rays = pow(sd, 10.0) * (0.5 + 0.5*sin((n.x+n.z)*18.0 + time*0.8));
            col += vec3(1.0, 0.95, 0.85) * rays * 0.02;

            gl_FragColor = vec4(col, 1.0);
          }
        `
      });
      const dome = new THREE.Mesh(geo, mat);
      dome.renderOrder = -999;
      return dome;
    }

    // nuvole: texture procedurale su sprite
    function makeCloudTexture(size=256){
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const g = c.getContext('2d');
      g.clearRect(0,0,size,size);

      // blob multipli con blur
      for(let k=0;k<30;k++){
        const x = (0.15 + Math.random()*0.70) * size;
        const y = (0.20 + Math.random()*0.55) * size;
        const r = (0.10 + Math.random()*0.22) * size;
        const a = 0.03 + Math.random()*0.07;

        const grd = g.createRadialGradient(x,y,0, x,y,r);
        grd.addColorStop(0, `rgba(255,255,255,${a})`);
        grd.addColorStop(0.65, `rgba(255,255,255,${a*0.55})`);
        grd.addColorStop(1, `rgba(255,255,255,0)`);
        g.fillStyle = grd;
        g.beginPath(); g.arc(x,y,r,0,Math.PI*2); g.fill();
      }

      // leggero soft blur manuale (semplice)
      g.globalAlpha = 0.85;
      g.drawImage(c, -2, -2);
      g.drawImage(c,  2,  2);

      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
      tex.needsUpdate = true;
      return tex;
    }

    function makeCloudSprite(tex){
      const mat = new THREE.SpriteMaterial({
        map: tex,
        transparent:true,
        opacity: 0.85,
        depthWrite:false
      });
      const s = new THREE.Sprite(mat);
      return s;
    }

    const camera = new THREE.PerspectiveCamera(baseFov, window.innerWidth/window.innerHeight, 0.1, 320);
    hardFixCameraUp();

    // SKY
    const skyDome = makeSkyDome();
    scene.add(skyDome);

    const cloudTex = makeCloudTexture(IS_IOS ? 192 : 256);
    const clouds = new THREE.Group();
    scene.add(clouds);

    // nuvole piccole ‚Äúogni tanto‚Äù, movimento in avanti col run
    const cloudPool = [];
    const CLOUD_N = IS_IOS ? 18 : 26;
    for(let i=0;i<CLOUD_N;i++){
      const s = makeCloudSprite(cloudTex);
      const y = 14 + Math.random()*18;
      const z = -40 - Math.random()*180;
      const x = (Math.random()*2-1) * 35;
      s.position.set(x, y, z);
      const sc = 8 + Math.random()*10;
      s.scale.set(sc*(1.4+Math.random()*0.9), sc, 1);
      s.material.opacity = 0.35 + Math.random()*0.35;
      clouds.add(s);
      cloudPool.push(s);
    }
    function loopClouds(scroll){
      const wrap = 220;
      for(const c of cloudPool){
        c.position.z += scroll * 0.35; // lento rispetto alla strada
        // micro drift orizzontale (vento)
        c.position.x += Math.sin(c.position.z*0.02) * 0.002 * scroll;
        if(c.position.z > 20){
          c.position.z -= wrap;
          c.position.x = (Math.random()*2-1) * 35;
          c.position.y = 14 + Math.random()*18;
          const sc = 8 + Math.random()*10;
          c.scale.set(sc*(1.4+Math.random()*0.9), sc, 1);
          c.material.opacity = 0.35 + Math.random()*0.35;
        }
      }
    }

    // fog coerente col cielo (niente nero)
    scene.fog = IS_IOS
      ? new THREE.Fog(0xcfeeff, 40, 130)
      : new THREE.FogExp2(0xcfeeff, 0.017);

    // =========================================================
    // LUCI (sole naturale)
    // =========================================================
    const sun = new THREE.DirectionalLight(0xfff3d9, IS_IOS ? 2.5 : 1.9);
    sun.position.set(10, 16, 10);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048,2048);
    sun.shadow.camera.near = 0.5;
    sun.shadow.camera.far = 90;
    sun.shadow.camera.left = -14;
    sun.shadow.camera.right=  14;
    sun.shadow.camera.top  =  14;
    sun.shadow.camera.bottom=-14;
    sun.shadow.bias = -0.00023;
    scene.add(sun);

    scene.add(new THREE.HemisphereLight(0xe9f8ff, 0x2b3b2a, IS_IOS ? 0.95 : 0.70));
    scene.add(new THREE.AmbientLight(0xffffff, IS_IOS ? 0.42 : 0.22));

    const front = new THREE.DirectionalLight(0xffffff, IS_IOS ? 0.85 : 0.40);
    front.position.set(0, 6, 12);
    scene.add(front);

    // Contact shadow
    function makeContactShadowTexture(size=512){
      const c=document.createElement('canvas'); c.width=c.height=size;
      const g=c.getContext('2d');
      g.clearRect(0,0,size,size);
      const grd=g.createRadialGradient(size/2,size/2,0, size/2,size/2,size*0.48);
      grd.addColorStop(0,'rgba(0,0,0,0.38)');
      grd.addColorStop(0.55,'rgba(0,0,0,0.10)');
      grd.addColorStop(1,'rgba(0,0,0,0)');
      g.fillStyle=grd; g.fillRect(0,0,size,size);
      const t=new THREE.CanvasTexture(c); t.colorSpace=THREE.SRGBColorSpace;
      return t;
    }
    const contact = new THREE.Mesh(
      new THREE.PlaneGeometry(1.5,1.5),
      new THREE.MeshBasicMaterial({ map:makeContactShadowTexture(512), transparent:true, opacity:0.55, depthWrite:false })
    );
    contact.rotation.x = -Math.PI/2;
    contact.position.set(0, 0.02, 0.2);
    scene.add(contact);

    // =========================================================
    // STRADA
    // =========================================================
    const segLen = 9.0, segCount = 10;
    const laneW = 1.35;
    const mainRoadWidth = laneW * 3;
    const shoulderWidth = 1.40;
    const totalRoadWidth = mainRoadWidth + shoulderWidth;
    const leftEdge = -totalRoadWidth/2;

    const lanesX = [
      leftEdge + laneW*0.5,
      leftEdge + laneW*1.5,
      leftEdge + laneW*2.5,
      leftEdge + mainRoadWidth + shoulderWidth*0.5
    ];

    function makeHighwayTexture(size=1024){
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const g = c.getContext('2d');

      g.fillStyle = '#2b2f35';
      g.fillRect(0,0,size,size);

      for(let i=0;i<20000;i++){
        const x = Math.random()*size, y = Math.random()*size;
        const v = Math.floor(70 + Math.random()*70);
        g.fillStyle = `rgba(${v},${v},${v},${Math.random()*0.10})`;
        g.fillRect(x,y,1,1);
      }

      const px = (worldX)=> Math.round(((worldX - leftEdge) / totalRoadWidth) * size);

      const shoulderStartX = leftEdge + mainRoadWidth;
      g.fillStyle = 'rgba(255,255,255,0.03)';
      g.fillRect(px(shoulderStartX), 0, px(leftEdge+totalRoadWidth) - px(shoulderStartX), size);

      const solidW = Math.max(6, Math.round(size * 0.008));
      const dashW  = Math.max(5, Math.round(size * 0.0065));
      const dashLen = Math.round(size * 0.180);
      const dashGap = Math.round(size * 0.999);

      g.fillStyle = '#f4f6f8';

      const xOuterL = px(leftEdge + 0.03);
      const xOuterR = px(leftEdge + totalRoadWidth - 0.03);
      g.fillRect(Math.round(xOuterL - solidW/2), 0, solidW, size);
      g.fillRect(Math.round(xOuterR - solidW/2), 0, solidW, size);

      const xShoulderSep = px(shoulderStartX);
      g.fillRect(Math.round(xShoulderSep - solidW/2), 0, solidW, size);

      const xDash1 = px(leftEdge + laneW*1);
      const xDash2 = px(leftEdge + laneW*2);

      for(let y=0; y<size; y += (dashLen + dashGap)){
        const yi = Math.round(y);
        g.fillRect(Math.round(xDash1 - dashW/2), yi, dashW, dashLen);
        g.fillRect(Math.round(xDash2 - dashW/2), yi, dashW, dashLen);
      }

      const t = new THREE.CanvasTexture(c);
      t.colorSpace=THREE.SRGBColorSpace;
      t.wrapS=t.wrapT=THREE.RepeatWrapping;
      t.repeat.set(1.0, 10.0);
      return t;
    }

    function makePatchTexture(size=512){
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const g = c.getContext('2d');
      g.clearRect(0,0,size,size);

      const px = (worldX)=> ((worldX - leftEdge) / totalRoadWidth) * size;
      const centerLaneX = lanesX[1];
      const bandHalfW = laneW * 0.36;
      const xMin = Math.max(0, Math.floor(px(centerLaneX - bandHalfW)));
      const xMax = Math.min(size-1, Math.ceil(px(centerLaneX + bandHalfW)));

      for(let i=0;i<7000;i++){
        const x = xMin + Math.random()*(xMax-xMin);
        const y = Math.random()*size;
        const a = 0.02 + Math.random()*0.05;
        g.fillStyle = `rgba(0,0,0,${a})`;
        g.fillRect(x,y,1,1);
      }

      const stripCount = 8 + Math.floor(Math.random()*7);
      for(let i=0;i<stripCount;i++){
        const x = xMin + Math.random()*(xMax-xMin);
        const w = 14 + Math.random()*36;
        const a = 0.05 + Math.random()*0.12;

        const grad = g.createLinearGradient(x,0,x+w,0);
        grad.addColorStop(0, `rgba(0,0,0,0)`);
        grad.addColorStop(0.5, `rgba(0,0,0,${a})`);
        grad.addColorStop(1, `rgba(0,0,0,0)`);

        g.fillStyle = grad;
        g.fillRect(x, 0, w, size);
      }

      const patchCount = 6 + Math.floor(Math.random()*9);
      for(let i=0;i<patchCount;i++){
        const x = xMin + Math.random()*(xMax-xMin);
        const y = Math.random()*size;
        const w = 60 + Math.random()*170;
        const h = 8 + Math.random()*22;
        const a = 0.05 + Math.random()*0.12;
        g.fillStyle = `rgba(0,0,0,${a})`;
        g.fillRect(x,y,w,h);
      }

      const t = new THREE.CanvasTexture(c);
      t.colorSpace=THREE.SRGBColorSpace;
      t.wrapS=t.wrapT=THREE.RepeatWrapping;
      t.repeat.set(1.0, 10.0);
      return t;
    }

    const highwayTex = makeHighwayTexture(IS_IOS ? 768 : 1024);
    highwayTex.generateMipmaps = false;
    highwayTex.minFilter = THREE.NearestFilter;
    highwayTex.magFilter = THREE.NearestFilter;
    highwayTex.anisotropy = renderer.capabilities.getMaxAnisotropy();
    highwayTex.needsUpdate = true;
    highwayTex.repeat.set(1.0, 4.0);

    const patchTexPool = [
      makePatchTexture(IS_IOS ? 384 : 512),
      makePatchTexture(IS_IOS ? 384 : 512),
      makePatchTexture(IS_IOS ? 384 : 512),
    ];

    const roadMat = new THREE.MeshStandardMaterial({
      map: highwayTex,
      roughness: 0.96,
      metalness: 0.0,
      color: new THREE.Color(0xffffff)
    });

    const segments=[];
    let groupLeft = rndi(2,3);
    let groupShade = 0.94 + Math.random()*0.08;
    let groupPatch = patchTexPool[rndi(0, patchTexPool.length-1)];
    let groupPatchOpacity = 0.16 + Math.random()*0.10;

    for(let i=0;i<segCount;i++){
      const geo = new THREE.PlaneGeometry(totalRoadWidth, segLen);
      geo.rotateX(-Math.PI/2);
      const mesh = new THREE.Mesh(geo, roadMat);

      groupLeft--;
      if(groupLeft <= 0){
        groupLeft = rndi(2,3);
        groupShade = 0.94 + Math.random()*0.08;
        groupPatch = patchTexPool[rndi(0, patchTexPool.length-1)];
        groupPatchOpacity = 0.16 + Math.random()*0.10;
      }

      if(Math.abs(groupShade - 1.0) > 0.0001){
        const m = roadMat.clone();
        m.color = roadMat.color.clone().multiplyScalar(groupShade);
        mesh.material = m;
      }

      const patchGeo = new THREE.PlaneGeometry(totalRoadWidth, segLen);
      patchGeo.rotateX(-Math.PI/2);
      const patchMat = new THREE.MeshStandardMaterial({
        map: groupPatch,
        transparent: true,
        opacity: groupPatchOpacity,
        roughness: 1.0,
        metalness: 0.0,
        depthWrite: false,
        polygonOffset: true,
        polygonOffsetFactor: -1,
        polygonOffsetUnits: -1,
      });
      const patch = new THREE.Mesh(patchGeo, patchMat);
      patch.position.y = 0.003;
      mesh.add(patch);

      mesh.position.set(0, 0, -i*segLen);
      mesh.receiveShadow=true;

      scene.add(mesh);
      segments.push(mesh);
    }

    // terreno laterale (pi√π ‚Äúnaturale‚Äù col cielo chiaro)
    const sideGeo = new THREE.PlaneGeometry(44, segLen*segCount);
    sideGeo.rotateX(-Math.PI/2);
    const sideMat = new THREE.MeshStandardMaterial({ color:0x2e5a35, roughness:1, metalness:0 });
    const side = new THREE.Mesh(sideGeo, sideMat);
    side.position.set(0, -0.02, -segLen*segCount/2 + segLen/2);
    side.receiveShadow = true;
    scene.add(side);

    // alberi
    const jungle = new THREE.Group(); scene.add(jungle);
    function makeTree(){
      const g = new THREE.Group();
      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.11, 0.16, 1.6, 10),
        new THREE.MeshStandardMaterial({ color:0x4a3523, roughness:1, metalness:0 })
      );
      trunk.position.y=0.8; trunk.castShadow=true; trunk.receiveShadow=true; g.add(trunk);
      const crown = new THREE.Mesh(
        new THREE.ConeGeometry(0.75, 1.6, 12),
        new THREE.MeshStandardMaterial({ color:0x2a8a43, roughness:1, metalness:0 })
      );
      crown.position.y=1.9; crown.castShadow=true; crown.receiveShadow=true; g.add(crown);
      const crown2 = new THREE.Mesh(
        new THREE.ConeGeometry(0.6, 1.3, 12),
        new THREE.MeshStandardMaterial({ color:0x1f6f34, roughness:1, metalness:0 })
      );
      crown2.position.y=2.3; crown2.castShadow=true; crown2.receiveShadow=true; g.add(crown2);
      return g;
    }
    const treeProto = makeTree();
    const treePool=[];
    const treeSpacing=2.8;
    const treeSideX = (totalRoadWidth/2) + 1.9;
    const jungleCount = Math.floor((segLen*segCount)/treeSpacing);

    for(let i=0;i<jungleCount;i++){
      const z = -i*treeSpacing;
      for(const sideSign of [-1,1]){
        const t = treeProto.clone(true);
        t.position.set(sideSign*(treeSideX + rnd(0,1.8)), 0, z);
        t.scale.setScalar(rnd(0.8,1.2));
        t.rotation.y = rnd(0,Math.PI*2);
        t.traverse(o=>{ if(o.isMesh){o.castShadow=true;o.receiveShadow=true;}});
        jungle.add(t);
        treePool.push(t);
      }
    }
    function loopJungle(scroll){
      const wrapZ = segLen*segCount;
      for(const obj of treePool){
        obj.position.z += scroll;
        if(obj.position.z > 10) obj.position.z -= wrapZ;
      }
    }

    // SKY time update (per shader rays)
    function updateSkyTime(tNow){
      if(skyDome?.material?.uniforms?.time){
        skyDome.material.uniforms.time.value = tNow * 0.001;
      }
    }



    // =========================================================
    // ‚úÖ UI ‚ÄúMAGIA‚Äù (luce/brillantini) verso HUD
    // - useremo proiezione world->screen e Web Animations
    // - chiameremo flyToEl(...) quando raccogli cibo/magnete (in PART 5)
    // =========================================================
    const fxLayer = document.createElement('div');
    fxLayer.style.position = 'fixed';
    fxLayer.style.inset = '0';
    fxLayer.style.pointerEvents = 'none';
    fxLayer.style.zIndex = '55';
    fxLayer.style.overflow = 'hidden';
    document.body.appendChild(fxLayer);

    function worldToScreen(v3){
      const v = v3.clone().project(camera);
      const x = (v.x * 0.5 + 0.5) * window.innerWidth;
      const y = (-v.y * 0.5 + 0.5) * window.innerHeight;
      return { x, y, onScreen: (v.z < 1) };
    }

    function makeSparkNode(char='‚ú®'){
      const d = document.createElement('div');
      d.textContent = char;
      d.style.position = 'absolute';
      d.style.left = '0px';
      d.style.top = '0px';
      d.style.transform = 'translate(-50%,-50%)';
      d.style.fontSize = '18px';
      d.style.filter = 'drop-shadow(0 6px 10px rgba(0,0,0,.55))';
      d.style.willChange = 'transform, opacity';
      return d;
    }

    // üî• volo ‚Äúmagico‚Äù (sparkle) da world position a un elemento UI
    function flyToEl(fromWorldPos, toEl, options={}){
      if(!toEl) return;
      const { icon='‚ú®', duration=520, scatter=10 } = options;

      const from = worldToScreen(fromWorldPos);
      const r = toEl.getBoundingClientRect();
      const to = { x: r.left + r.width*0.15, y: r.top + r.height*0.5 };

      // se √® fuori schermo, fallback: parte dal centro
      const sx = from.onScreen ? from.x : window.innerWidth*0.5;
      const sy = from.onScreen ? from.y : window.innerHeight*0.55;

      // 1 spark grande + 4 micro
      const main = makeSparkNode(icon);
      main.style.fontSize = '22px';
      main.style.opacity = '0.98';
      fxLayer.appendChild(main);

      const micros = [];
      for(let i=0;i<4;i++){
        const m = makeSparkNode('‚ú®');
        m.style.fontSize = (12 + Math.random()*6).toFixed(0) + 'px';
        m.style.opacity = '0.75';
        fxLayer.appendChild(m);
        micros.push(m);
      }

      // curva (cubic-bezier) ‚Äúcinematografica‚Äù
      const mid = {
        x: (sx+to.x)*0.5 + (Math.random()*2-1)*scatter,
        y: Math.min(sy,to.y) - (40 + Math.random()*40)
      };

      const keyframesMain = [
        { transform:`translate(${sx}px,${sy}px) scale(1.0)`, opacity: 0.0 },
        { transform:`translate(${sx}px,${sy}px) scale(1.10)`, opacity: 1.0, offset: 0.08 },
        { transform:`translate(${mid.x}px,${mid.y}px) scale(1.10)`, opacity: 1.0, offset: 0.55 },
        { transform:`translate(${to.x}px,${to.y}px) scale(0.85)`, opacity: 0.0 }
      ];

      const a1 = main.animate(keyframesMain, {
        duration,
        easing: 'cubic-bezier(.2,.9,.2,1)',
        fill: 'forwards'
      });

      for(let i=0;i<micros.length;i++){
        const m = micros[i];
        const jx = sx + (Math.random()*2-1)*16;
        const jy = sy + (Math.random()*2-1)*16;
        const mm = {
          x: (sx+to.x)*0.5 + (Math.random()*2-1)*scatter*1.4,
          y: Math.min(sy,to.y) - (20 + Math.random()*65)
        };
        m.animate([
          { transform:`translate(${jx}px,${jy}px) scale(0.8)`, opacity: 0.0 },
          { transform:`translate(${jx}px,${jy}px) scale(1.0)`, opacity: 0.85, offset: 0.10 },
          { transform:`translate(${mm.x}px,${mm.y}px) scale(1.0)`, opacity: 0.75, offset: 0.55 },
          { transform:`translate(${to.x}px,${to.y}px) scale(0.65)`, opacity: 0.0 }
        ], {
          duration: duration + 90 + i*25,
          easing: 'cubic-bezier(.2,.85,.2,1)',
          fill:'forwards'
        });
      }

      a1.onfinish = ()=>{
        try{ fxLayer.removeChild(main); }catch{}
        for(const m of micros){ try{ fxLayer.removeChild(m); }catch{} }
      };
    }

    // =========================================================
    // Sprites
    // =========================================================
    function makeEmojiSprite(emoji, size=256){
      const c=document.createElement('canvas'); c.width=c.height=size;
      const g=c.getContext('2d');
      g.clearRect(0,0,size,size);

      // glow soft
      g.globalAlpha=0.18;
      g.fillStyle='#cfefff';
      g.beginPath(); g.arc(size/2,size/2,size*0.33,0,Math.PI*2); g.fill();

      g.globalAlpha=1;
      g.font=`${size*0.55}px system-ui, Apple Color Emoji, Segoe UI Emoji`;
      g.textAlign='center'; g.textBaseline='middle';
      g.fillText(emoji, size/2, size/2+8);

      const tex=new THREE.CanvasTexture(c);
      tex.colorSpace=THREE.SRGBColorSpace;

      const mat=new THREE.SpriteMaterial({ map:tex, transparent:true });
      const spr=new THREE.Sprite(mat);
      spr.scale.set(0.78,0.78,1);
      return spr;
    }

    // =========================================================
    // ‚úÖ Entities visuals
    // - ostacoli TUTTI stessa misura, appoggiati sul terreno, non troppo larghi
    // =========================================================
    const OBST_W = 0.78;
    const OBST_H = 0.95;
    const OBST_D = 0.78;

    function spawnObstacleVisual(){
      const box = new THREE.Mesh(
        new THREE.BoxGeometry(OBST_W, OBST_H, OBST_D),
        new THREE.MeshStandardMaterial({ color:0x6b4b2b, roughness:0.9, metalness:0.02 })
      );
      box.castShadow=true; box.receiveShadow=true;
      // ‚úÖ appoggiato a terra: y = met√† altezza
      box.position.y = OBST_H * 0.5;
      return box;
    }

    function makeTurtle(){
      const g = new THREE.Group();

      const shell = new THREE.Mesh(
        new THREE.SphereGeometry(0.35, 18, 14),
        new THREE.MeshStandardMaterial({ color:0x1f6a3a, roughness:0.9, metalness:0.02 })
      );
      shell.scale.set(1.2,0.75,1.0);
      shell.position.y=0.33;
      shell.castShadow=true; shell.receiveShadow=true;
      g.add(shell);

      const head = new THREE.Mesh(
        new THREE.SphereGeometry(0.16, 16, 12),
        new THREE.MeshStandardMaterial({ color:0x2f8a4d, roughness:0.9, metalness:0.02 })
      );
      head.position.set(0,0.22,0.42);
      head.castShadow=true;
      g.add(head);

      // ‚úÖ appoggiato a terra
      g.position.y = 0;

      // stato ‚Äúfuga‚Äù
      g.userData.fleeT = 0;     // secondi di fuga rimanenti
      g.userData.fleeV = 0;     // velocit√† extra

      return g;
    }

    function makeVerticalRing(){
      const ring = new THREE.Mesh(
        new THREE.TorusGeometry(0.55, 0.09, 14, 44),
        new THREE.MeshStandardMaterial({
          color:0xff4444,
          roughness:0.35,
          metalness:0.05,
          emissive:0x660000,
          emissiveIntensity:0.55
        })
      );
      ring.castShadow=true; ring.receiveShadow=true;
      return ring;
    }

    // =========================================================
    // Runner
    // =========================================================
    const runnerPivot = new THREE.Group(); scene.add(runnerPivot);
    const runnerCenter = new THREE.Group(); runnerCenter.position.set(0, 0.95, 0); runnerPivot.add(runnerCenter);
    const runnerModel = new THREE.Group(); runnerModel.position.set(0, -0.95, 0); runnerCenter.add(runnerModel);

    // Bubble (invincibilit√†)
    const bubble = new THREE.Mesh(
      new THREE.SphereGeometry(0.62, 24, 18),
      new THREE.MeshStandardMaterial({
        color:0x66ffcc, roughness:0.25, metalness:0.0,
        emissive:0x33ffaa, emissiveIntensity:0.7,
        transparent:true, opacity:0.22
      })
    );
    bubble.position.set(0, 0.95, 0);
    bubble.visible=false;
    runnerPivot.add(bubble);

    // fallback dummy (se GLB manca)
    const fallbackRunner = new THREE.Group();
    const dummyBody = new THREE.Mesh(
      new THREE.CapsuleGeometry(0.22, 0.55, 8, 16),
      new THREE.MeshStandardMaterial({ color:0x9db79a, roughness:0.65, metalness:0.0 })
    );
    dummyBody.position.y=0.85; dummyBody.castShadow=true; fallbackRunner.add(dummyBody);
    const dummyHead = new THREE.Mesh(
      new THREE.SphereGeometry(0.18, 18, 14),
      new THREE.MeshStandardMaterial({ color:0xb7ccb2, roughness:0.6, metalness:0.0 })
    );
    dummyHead.position.set(0, 1.25, 0.05); dummyHead.castShadow=true; fallbackRunner.add(dummyHead);

    // =========================================================
    // GLB loader + Animations
    // =========================================================
    const gltfLoader = new GLTFLoader();

    const RUNNER_GLB_URL = './running.glb';
    const ANIM_FILES = {
      idle: ['./DwarfIdle.glb', './WarriorIdle.glb', './HappyIdle.glb'],
      jump: './JumpOver.glb',
      flip: './RunningForwardFlip.glb',
      kick: './SoccerKick.glb',
      die:  './SideHitDie.glb',
      dance:'./HipHopDance.glb'
    };

    function setShadows(root){
      root.traverse(o=>{ if(o.isMesh){ o.castShadow=true; o.receiveShadow=true; } });
    }
    function removeBigNonSkinnedPlanes(model){
      model.traverse(o=>{
        if(!o.isMesh) return;
        const isSkinned = (o.isSkinnedMesh === true) || (o.skeleton != null);
        if(isSkinned) return;

        const box = new THREE.Box3().setFromObject(o);
        const s = new THREE.Vector3(); box.getSize(s);

        const huge = (s.x > 2.4 || s.y > 2.4 || s.z > 2.4);
        const flat = (Math.min(s.x,s.y,s.z) < 0.03 && Math.max(s.x,s.y,s.z) > 1.6);

        const name = (o.name||'').toLowerCase();
        const suspicious = name.includes('plane') || name.includes('cube') || name.includes('quad') || name.includes('ground') || name.includes('floor');

        if(huge || flat || suspicious) o.visible = false;
      });
    }
    function stripRootMotion(clip){
      const c = clip.clone();
      const TH = 0.02;
      try{
        for(const t of c.tracks){
          const name = (t.name || '').toLowerCase();
          if(!name.endsWith('.position')) continue;
          const v = t.values;
          if(!v || v.length < 6) continue;

          let minX=Infinity, maxX=-Infinity, minZ=Infinity, maxZ=-Infinity;
          for(let i=0;i<v.length;i+=3){
            const x=v[i], z=v[i+2];
            if(x<minX) minX=x; if(x>maxX) maxX=x;
            if(z<minZ) minZ=z; if(z>maxZ) maxZ=z;
          }
          const rangeX=maxX-minX, rangeZ=maxZ-minZ;
          if(rangeX>TH || rangeZ>TH){
            const baseX=v[0], baseZ=v[2];
            for(let i=0;i<v.length;i+=3){
              v[i]=baseX;
              v[i+2]=baseZ;
            }
          }
        }
      }catch(err){ console.warn('stripRootMotion fallback:', err); }
      return c;
    }

    let runnerMixer=null;
    let actions = { run:null, idles:[], jump:null, flip:null, kick:null, die:null, dance:null };
    let mixamoHips=null, mixamoRootNode=null, headBone=null;
    let hipsBaseX=0, hipsBaseZ=0, rootBaseX=0, rootBaseZ=0;

    // FPS mask ‚Äúshadow-only‚Äù (rimane identico)
    let fpsHiddenMeshes = [];
    function setFpsMaskHidden(on){
      if(viewMode==='fps') bubble.visible = false;

      for(const it of fpsHiddenMeshes){
        const m = it.mesh;
        try{
          m.visible = it.visible;
          m.castShadow = it.castShadow;
          if(m.material){
            const mats = Array.isArray(m.material) ? m.material : [m.material];
            const saved = it.materialStates || [];
            for(let i=0;i<mats.length;i++){
              const mat = mats[i];
              const st  = saved[i];
              if(!mat || !st) continue;
              mat.transparent = st.transparent;
              mat.opacity     = st.opacity;
              mat.colorWrite  = st.colorWrite;
              mat.depthWrite  = st.depthWrite;
              mat.depthTest   = st.depthTest;
              mat.needsUpdate = true;
            }
          }
        }catch{}
      }
      fpsHiddenMeshes = [];
      if(!on) return;

      runnerModel.traverse(o=>{
        if(!o.isMesh) return;

        const n = (o.name||'').toLowerCase();
        const hit =
          n.includes('head') || n.includes('face') || n.includes('hair') ||
          n.includes('helmet') || n.includes('hat') || n.includes('mask') ||
          n.includes('cap') || n.includes('hood') || n.includes('visor');

        if(!hit) return;

        const mats = o.material ? (Array.isArray(o.material) ? o.material : [o.material]) : [];
        const materialStates = mats.map(mat => mat ? ({
          transparent: mat.transparent,
          opacity: mat.opacity,
          colorWrite: mat.colorWrite,
          depthWrite: mat.depthWrite,
          depthTest: mat.depthTest
        }) : null);

        fpsHiddenMeshes.push({
          mesh: o,
          visible: o.visible,
          castShadow: o.castShadow,
          materialStates
        });

        o.visible = true;
        o.castShadow = true;

        for(const mat of mats){
          if(!mat) continue;
          mat.transparent = true;
          mat.opacity = 0.0;
          mat.colorWrite = false;
          mat.depthWrite = false;
          mat.depthTest  = true;
          mat.needsUpdate = true;
        }
      });
    }

    const animState = { mode:'idle' };
    let deadSnapPending = false;

    function collectAllActions(){
      const all=[];
      if(actions.run) all.push(actions.run);
      if(actions.jump) all.push(actions.jump);
      if(actions.flip) all.push(actions.flip);
      if(actions.kick) all.push(actions.kick);
      if(actions.die)  all.push(actions.die);
      if(actions.dance)all.push(actions.dance);
      for(const a of actions.idles) all.push(a);
      return all;
    }
    function fadeTo(next, fade=0.18){
      if(!next) return;
      const all = collectAllActions();
      for(const a of all){
        if(a && a !== next){ try{ a.fadeOut(fade); }catch{} }
      }
      try{
        next.reset();
        next.enabled = true;
        next.setEffectiveWeight(1.0);
        next.fadeIn(fade);
        next.play();
      }catch{}
    }
    function playRun(){
      if(!actions.run || animState.mode==='dead') return;
      animState.mode='run';
      actions.run.setLoop(THREE.LoopRepeat, Infinity);
      actions.run.clampWhenFinished = false;
      fadeTo(actions.run, 0.12);
    }
    function pickRandomIdle(){
      if(!actions.idles.length || animState.mode==='dead') return;
      const a = actions.idles[rndi(0, actions.idles.length-1)];
      a.setLoop(THREE.LoopOnce, 1);
      a.clampWhenFinished = true;
      a.time = 0;
      animState.mode='idle';
      fadeTo(a, 0.20);
    }
    function startIdleRandom(){
      if(animState.mode==='dead') return;
      pickRandomIdle();
    }
    function playOneShot(action, fade=0.08){
      if(!action || animState.mode==='dead') return;
      animState.mode='oneShot';
      action.reset();
      action.setLoop(THREE.LoopOnce, 1);
      action.clampWhenFinished = true;
      action.enabled = true;
      action.setEffectiveWeight(1.0);
      fadeTo(action, fade);
    }
    function playDance(){
      if(!actions.dance || animState.mode==='dead') return;
      animState.mode='dance';
      actions.dance.setLoop(THREE.LoopRepeat, Infinity);
      actions.dance.clampWhenFinished = false;
      fadeTo(actions.dance, 0.18);
    }

    function snapRunnerToGround(){
      try{
        const root = runnerModel.children[0];
        if(!root) return;
        const box = new THREE.Box3().setFromObject(root);
        const dy = -box.min.y;
        if(Number.isFinite(dy) && Math.abs(dy) > 0.0001){
          root.position.y += dy;
        }
      }catch{}
    }
    function playDie(){
      if(!actions.die) return;
      animState.mode='dead';
      deadSnapPending = true;
      actions.die.reset();
      actions.die.setLoop(THREE.LoopOnce, 1);
      actions.die.clampWhenFinished = true;
      fadeTo(actions.die, 0.08);
    }

    function resetAnimationsToIdle(){
      animState.mode = 'idle';
      deadSnapPending = false;
      const all = collectAllActions();
      for(const a of all){
        if(!a) continue;
        try{
          a.stop();
          a.reset();
          a.enabled = true;
          a.setEffectiveWeight(0);
          a.clampWhenFinished = false;
        }catch{}
      }
      startIdleRandom();
      setFpsMaskHidden(viewMode==='fps');
    }

    async function loadAnimClip(url){
      return new Promise((resolve)=>{
        gltfLoader.load(url, (gltf)=>{
          const clips = (gltf.animations||[]).filter(c=>c && c.tracks && c.tracks.length);
          resolve(clips[0] || null);
        }, undefined, ()=>{
          console.warn('Anim load error:', url);
          resolve(null);
        });
      });
    }
    async function loadAllAnimations(){
      for(const u of ANIM_FILES.idle){
        const c = await loadAnimClip(u);
        if(c) actions.idles.push(c);
      }
      actions.jump  = await loadAnimClip(ANIM_FILES.jump);
      actions.flip  = await loadAnimClip(ANIM_FILES.flip);
      actions.kick  = await loadAnimClip(ANIM_FILES.kick);
      actions.die   = await loadAnimClip(ANIM_FILES.die);
      actions.dance = await loadAnimClip(ANIM_FILES.dance);
    }

    async function loadRunnerModel(){
      return new Promise((resolve)=>{
        gltfLoader.load(RUNNER_GLB_URL, async (gltf)=>{
          const model = gltf.scene;

          model.position.set(0,0,0);
          model.scale.setScalar(0.95);
          setShadows(model);

          model.traverse(o=>{
            if(o.isMesh && o.material){
              const mats = Array.isArray(o.material) ? o.material : [o.material];
              for(const m of mats){ if(m) m.side = THREE.DoubleSide; }
            }
          });

          removeBigNonSkinnedPlanes(model);

          {
            const box = new THREE.Box3().setFromObject(model);
            const lift = -box.min.y;
            model.position.y += lift + 0.01;
          }

          model.rotation.y = Math.PI;

          mixamoHips = null; mixamoRootNode = null; headBone = null;
          model.traverse(o=>{
            const n = (o.name||'').toLowerCase();
            if(!mixamoRootNode && (n.includes('armature') || n === 'root')) mixamoRootNode = o;
            if(o.isBone){
              if(!mixamoHips && (n==='hips' || (n.includes('mixamorig') && n.includes('hips')))) mixamoHips = o;
              if(!headBone && (n==='head' || (n.includes('mixamorig') && n.includes('head')))) headBone = o;
            }
          });
          if(mixamoHips){ hipsBaseX = mixamoHips.position.x; hipsBaseZ = mixamoHips.position.z; }
          if(mixamoRootNode){ rootBaseX = mixamoRootNode.position.x; rootBaseZ = mixamoRootNode.position.z; }

          while(runnerModel.children.length) runnerModel.remove(runnerModel.children[0]);
          runnerModel.add(model);

          runnerMixer = new THREE.AnimationMixer(model);

          await loadAllAnimations();

          const baseClips = (gltf.animations||[]).filter(c=>c && c.tracks && c.tracks.length);
          const runClip = baseClips.find(c => (c.name||'').toLowerCase().includes('run')) || baseClips[0];
          const fixedRun = runClip ? stripRootMotion(runClip) : null;
          if(fixedRun){
            actions.run = runnerMixer.clipAction(fixedRun);
            actions.run.enabled = true;
            actions.run.setEffectiveWeight(1.0);
            actions.run.setEffectiveTimeScale(1.0);
          }

          const idleActions = [];
          for(const clip of actions.idles) idleActions.push(runnerMixer.clipAction(clip));
          actions.idles = idleActions;

          if(actions.jump)  actions.jump  = runnerMixer.clipAction(actions.jump);
          if(actions.flip)  actions.flip  = runnerMixer.clipAction(actions.flip);
          if(actions.kick)  actions.kick  = runnerMixer.clipAction(actions.kick);
          if(actions.die)   actions.die   = runnerMixer.clipAction(actions.die);
          if(actions.dance) actions.dance = runnerMixer.clipAction(actions.dance);

          runnerMixer.addEventListener('finished', ()=>{
            if(animState.mode==='dead'){
              if(deadSnapPending){
                deadSnapPending = false;
                snapRunnerToGround();
              }
              return;
            }
            if(animState.mode==='oneShot'){
              if(game.started && !game.stopped && !game.paused && !game.over) playRun();
              else startIdleRandom();
              return;
            }
            if(animState.mode==='idle'){
              pickRandomIdle();
              return;
            }
          });

          startIdleRandom();
          resolve();
        }, undefined, ()=>{
          while(runnerModel.children.length) runnerModel.remove(runnerModel.children[0]);
          runnerModel.add(fallbackRunner);
          resolve();
        });
      });
    }



    // =========================================================
    // ‚úÖ GAME DATA
    // =========================================================
    const EMOJIS = ["‚ú®","üçÄ","üíé","‚ö°Ô∏è","üåà","üçã","‚≠êÔ∏è","üçì","ü•ù"];
    const FOOD   = ["üçï","üçî","üçü","üåÆ","üç©","üç™","üç∞","üçú","üç£","ü•ê"];
    const HEART  = "‚ù§Ô∏è";
    const MAGNET = "üß≤";

    const BEST_KEY='jungle_runner_best_v4';
    const loadBest=()=>Number(localStorage.getItem(BEST_KEY)||'0')||0;
    const saveBest=(v)=>localStorage.setItem(BEST_KEY,String(v));

    // ‚úÖ ‚Äúdistanza visibile‚Äù strada ~ TURTLE_VIS_Z (gi√† definito prima) ‚Üí useremo per cooldown spawn
    const VISIBLE_DIST = TURTLE_VIS_Z; // 70
    const POWERUP_COOLDOWN_DIST = VISIBLE_DIST * 2.0; // 2x visibile

    // ‚úÖ riduci magneti ~20%
    const MAGNET_SPAWN_P = 0.10 * 0.80; // prima 0.10

    const game = {
      lane:1,
      y:0, vy:0, jumping:false,
      sliding:false, slideT:0,
      autoSlideCooldown:0,

      baseSpeed: 12.9,
      score:0,
      coins:0,
      best: loadBest(),

      maxLives:5,
      lives:3,

      ringCount:0,
      foodCount:0,
      foodHistory:[],
      foodBoostCharges: 0,

      invincibleT:0,
      foodBoostT:0,
      ringBoostT:0,
      magnetT:0,
      trioT:0,

      // ‚úÖ lock boost: non puoi riattivare finch√© boost attivo
      boostLock: false,

      // ‚úÖ cooldown spawn magnet/heart dopo raccolta (distanza in world units)
      powerupCooldownZ: 0, // finch√© >0 blocca spawn magnet/heart

      entities:[],
      spawnT:0.30,

      paused:false,
      started:false,
      over:false,

      stopped:true,
      stopBlend:1.0,

      lastTurtleZ: [-99999, -99999, -99999],

      // camera FPS info
      camSpeed: 0,
      grounded: true,
      vyNow: 0
    };

    if(bestEl) bestEl.textContent = String(game.best);

    function hpString(){
      let s="";
      for(let i=0;i<game.maxLives;i++) s += (i<game.lives) ? "‚ù§Ô∏è" : "üñ§";
      return s;
    }

    // =========================================================
    // ‚úÖ SCORE autosize: se numero lungo, riduci font per farlo stare nella pillola
    // =========================================================
    function fitScoreText(){
      if(!scoreEl) return;
      const el = scoreEl;
      const parent = el.closest('.hudV') || el.parentElement;
      if(!parent) return;

      // base via CSS: font-size ereditato
      el.style.transformOrigin = 'center';
      el.style.transform = 'scale(1)';

      // misura overflow
      const maxW = parent.clientWidth - 2;
      const w = el.scrollWidth;
      if(w > maxW && maxW > 0){
        const s = clamp(maxW / w, 0.72, 1.0);
        el.style.transform = `scale(${s.toFixed(3)})`;
      }
    }

    // =========================================================
    // ‚úÖ Food UI: accumulo dal basso (stack fisso a destra)
    // - CSS della colonna rimane fissa
    // - qui invertiamo il layout: ultimi elementi stanno in basso
    // =========================================================
    function updateFoodBoostButton(){
      if(!btnFoodBoost || !foodBoostLbl) return;
      // ‚úÖ ora il bottone boost NON mostra pi√π conteggio dentro (lo sposteremo in UI in PART 6)
      // ma per ora manteniamo compatibilit√†: mostriamo "BOOST"
      if(game.foodBoostCharges > 0){
        btnFoodBoost.style.display = 'flex';
        foodBoostLbl.textContent = `BOOST`;
      }else{
        btnFoodBoost.style.display = 'none';
        foodBoostLbl.textContent = `BOOST`;
      }
    }

    function refreshFoodUI(){
      if(!foodStack || !foodCountEl) return;

      // ‚úÖ stack: gli elementi devono accumulare verso il basso
      // Mostriamo max 6: i pi√π recenti finiscono in basso
      foodStack.innerHTML = "";

      const show = game.foodHistory.slice(-6); // in ordine cronologico
      // creiamo un wrapper che spinge in basso
      const frag = document.createDocumentFragment();

      for(const emo of show){
        const d=document.createElement('div');
        d.className = 'foodItem pillFx';
        d.textContent=emo;
        frag.appendChild(d);
      }
      foodStack.appendChild(frag);

      // ‚úÖ ‚Äúspingi‚Äù visivamente in basso usando margin-top auto
      // (se il browser non supporta bene, resta ok comunque)
      foodStack.style.display = 'flex';
      foodStack.style.flexDirection = 'column';
      foodStack.style.justifyContent = 'flex-end';

      foodCountEl.textContent = String(game.foodCount);

      updateFoodBoostButton();
      fitScoreText();
    }

    // =========================================================
    // ‚úÖ HUD Bars: animazione barra (ripple/shine) e update time
    // =========================================================
    
    

    let hudBarAnimPhase = 0;

    function setHudBar(el, pct){
      if(!el) return;
      el.style.width = `${clamp(pct,0,100).toFixed(1)}%`;
      // ‚Äúpulse‚Äù via box-shadow in base a pct (leggero)
      const glow = 0.18 + 0.22*(pct/100);
      el.style.boxShadow = `0 0 7px rgba(140,200,255,${glow.toFixed(3)})`;
    }

    function setBoostUI(){
  if(!pillBoost || !boostBar || !boostIcon || !boostName) return;

  const t = Math.max(game.foodBoostT, game.ringBoostT);
  if(t <= 0){
    pillBoost.style.display='none';
    setHudBar(boostBar, 0);
    if(boostTime) boostTime.textContent = '0.0s';
    return;
  }
  pillBoost.style.display='flex';

  const both = (game.foodBoostT>0 && game.ringBoostT>0);
  if(both){ boostIcon.textContent='üî•'; boostName.textContent='MEGA'; }
  else if(game.foodBoostT>0){ boostIcon.textContent='üçî'; boostName.textContent='FOOD'; }
  else { boostIcon.textContent='‚≠ïÔ∏è'; boostName.textContent='RING'; }

  const dur = 10.0;
  const pct = clamp((t/dur)*100,0,100);
  setHudBar(boostBar, pct);

  if(boostTime) boostTime.textContent = `${t.toFixed(1)}s`;
}

function setFoodBoostPillUI(){
  if(!foodBoostPill || !foodBoostBar) return;

  if(game.foodBoostT <= 0){
    foodBoostPill.style.display = 'none';
    setHudBar(foodBoostBar, 0);
    if(foodBoostTime) foodBoostTime.textContent = '0.0s';
    return;
  }

  foodBoostPill.style.display = 'flex';
  const dur = 10.0;
  const pct = clamp((game.foodBoostT/dur)*100,0,100);
  setHudBar(foodBoostBar, pct);

  if(foodBoostTime) foodBoostTime.textContent = `${game.foodBoostT.toFixed(1)}s`;
}

    function setMagnetUI(){
      if(!magTxt || !magBar) return;
      if(game.magnetT <= 0){
        magTxt.textContent = `üß≤ 0`;
        setHudBar(magBar, 0);
        return;
      }
      const dur = 8.0;
      const pct = clamp((game.magnetT/dur)*100,0,100);
      magTxt.textContent = `üß≤ ${game.magnetT.toFixed(1)}`;
      setHudBar(magBar, pct);
    }

    // =========================================================
    // ‚úÖ Main button label
    // =========================================================
    function updateMainButton(){
      if(!mainLbl) return;
      if(game.over){ mainLbl.textContent = 'RESTART'; return; }
      if(!game.started){ mainLbl.textContent = 'AVVIA'; return; }
      if(game.stopped){ mainLbl.textContent = 'AVVIA'; return; }
      mainLbl.textContent = 'STOP';
    }

    // =========================================================
    // Spawn helper
    // =========================================================
    function obstacleMultiplier(){
      const steps = Math.floor(game.score / 5000);
      return 1 + 0.05 * steps;
    }

    // ===== Spawn =====
    const TURTLE_MIN_GAP = TURTLE_VIS_Z * 3.0;
    function canSpawnTurtle(lane, z){
      return Math.abs(z - game.lastTurtleZ[lane]) >= TURTLE_MIN_GAP;
    }

    // ‚úÖ blocca magnet/heart se cooldown attivo
    function powerupAllowed(){
      return game.powerupCooldownZ <= 0;
    }

    function spawnRow(){
      const z0 = -60 - rnd(0,18);

      const blocked=new Set();
      const mult = obstacleMultiplier();

      const p0 = clamp(0.22 / mult, 0.03, 0.22);
      let oCount = 0;
      if(Math.random() >= p0){
        const p2 = clamp(0.38 * mult, 0.18, 0.95);
        oCount = (Math.random() < p2) ? 2 : 1;
      }
      while(blocked.size<oCount) blocked.add(rndi(0,2));

      const coinLanes=new Set();
      const cCount = rndi(1,2);
      while(coinLanes.size<cCount) coinLanes.add(rndi(0,2));

      blocked.forEach(l=>{
        const obj = spawnObstacleVisual();
        obj.position.x = lanesX[l];
        obj.position.z = z0;
        scene.add(obj);
        game.entities.push({ type:'obst', lane:l, z:z0, obj });
      });

      coinLanes.forEach(l=>{
        const spr = makeEmojiSprite(EMOJIS[rndi(0,EMOJIS.length-1)]);
        spr.position.set(lanesX[l], 1.10, z0 - rnd(0,2.8));
        scene.add(spr);
        game.entities.push({ type:'coin', lane:l, z:spr.position.z, obj:spr });
      });

      if(Math.random() < 0.30){
        const lane=rndi(0,2);
        const emo = FOOD[rndi(0,FOOD.length-1)];
        const spr = makeEmojiSprite(emo);
        spr.position.set(lanesX[lane], 1.15, z0 - rnd(1,6));
        spr.scale.set(0.82,0.82,1);
        scene.add(spr);
        game.entities.push({ type:'food', lane, z:spr.position.z, obj:spr, emo });
      }

      // ‚úÖ Magneti meno + cooldown post-raccolta
      if(powerupAllowed() && Math.random() < MAGNET_SPAWN_P){
        const lane=rndi(0,2);
        const spr = makeEmojiSprite(MAGNET);
        spr.position.set(lanesX[lane], 1.15, z0 - rnd(1,7));
        spr.scale.set(0.90,0.90,1);
        scene.add(spr);
        game.entities.push({ type:'magnet', lane, z:spr.position.z, obj:spr });
      }

      // ‚úÖ Vita: stessa regola cooldown (2x visibile dopo raccolta heart o magnet)
      if(powerupAllowed() && game.lives < game.maxLives){
        let spawnHeart = false;
        if(game.coins>0 && game.coins % 30 === 0 && Math.random() < 0.45) spawnHeart = true;
        if(!spawnHeart && Math.random() < 0.03) spawnHeart = true;
        if(spawnHeart){
          const lane=rndi(0,2);
          const spr = makeEmojiSprite(HEART);
          spr.position.set(lanesX[lane], 1.15, z0 - rnd(1,6));
          spr.scale.set(0.92,0.92,1);
          scene.add(spr);
          game.entities.push({ type:'heart', lane, z:spr.position.z, obj:spr });
        }
      }

      if(Math.random() < 0.18){
        const lane=rndi(0,2);
        const tz = z0 - rnd(3,11);
        if(canSpawnTurtle(lane, tz)){
          const t = makeTurtle();
          t.position.set(lanesX[lane], 0, tz);
          t.traverse(o=>{ if(o.isMesh){ o.castShadow=true; o.receiveShadow=true; }});
          scene.add(t);
          game.entities.push({ type:'turtle', lane, z:tz, obj:t });
          game.lastTurtleZ[lane] = tz;
        }
      }

      if(Math.random() < 0.26){
        const lane = rndi(0,2);
        const baseZ = z0 - rnd(2,9);
        const gap = 0.82;
        for(let k=0;k<2;k++){
          const ring = makeVerticalRing();
          ring.position.set(lanesX[lane], 0.55, baseZ - k*gap);
          scene.add(ring);
          game.entities.push({ type:'ring', lane, z:ring.position.z, obj:ring });
        }
      }
    }

    // =========================================================
    // Controls
    // =========================================================
    let tiltTarget=0, camRoll=0;

    function moveLane(dir){
      if(game.over||game.paused) return;
      if(!game.started) return;
      if(game.stopped) return;
      if(game.trioT>0) return;
      game.lane = clamp(game.lane+dir, 0, 3);
      tiltTarget = clamp(tiltTarget + dir*0.18, -0.22, 0.22);
      fpsLaneKick = clamp(fpsLaneKick + dir * 0.55, -1.2, 1.2);
      sfx.lane();
    }

    function jump(){
      if(game.over||game.paused) return;
      if(!game.started) return;
      if(game.stopped) return;
      if(!game.jumping && game.y>=-0.001){
        game.jumping=true;
        game.vy = -7.8;
        sfx.jump();
      }
    }

    function slide(){
      if(game.over||game.paused) return;
      if(!game.started) return;
      if(game.stopped) return;
      game.sliding=true;
      game.slideT=0.55;
      sfx.slide();
    }

    // =========================================================
    // Start/Stop/Dance/Home + Boost button (lock while active)
    // =========================================================
    function setStop(on){
      game.stopped = !!on;
      if(game.stopped){
        startIdleRandom();
      }else{
        if(game.started && !game.paused && !game.over) playRun();
      }
      updateMainButton();
    }

    function resetRun(){
      game.lane=1;
      runnerX = lanesX[1];
      game.y=0; game.vy=0; game.jumping=false;
      game.sliding=false; game.slideT=0.55*0;
      game.autoSlideCooldown=0;

      game.score=0; game.coins=0;
      game.ringCount=0;

      game.foodCount=0; game.foodHistory=[];
      game.foodBoostCharges = 0;
      game.boostLock = false;
      game.powerupCooldownZ = 0;

      refreshFoodUI();

      game.invincibleT=0;
      game.foodBoostT=0;
      game.ringBoostT=0;
      game.magnetT=0;
      game.trioT=0;

      bubble.visible=false;

      for(const e of game.entities) scene.remove(e.obj);
      game.entities.length=0;

      game.spawnT = 0.30;
      game.over=false;
      game.lives=3;

      game.lastTurtleZ = [-99999, -99999, -99999];

      game.started = false;
      game.paused = false;
      setStop(true);

      resetAnimationsToIdle();

      if(scoreEl) scoreEl.textContent = '0';
      if(coinsEl) coinsEl.textContent = '0';
      if(ringsEl) ringsEl.textContent = '0';
      if(hpTxt) hpTxt.textContent = hpString();
      setMagnetUI();
      setBoostUI();
      setFoodBoostPillUI();

      updateFoodBoostButton();
      updateMainButton();
      startIdleRandom();
      fitScoreText();
    }

    function startGame(){
      game.started = true;
      game.paused = false;
      setStop(false);
      playRun();
      updateMainButton();
    }

    function togglePause(){
      if(game.over) return;
      if(!game.started) return;
      game.paused = !game.paused;
      if(game.paused){
        startIdleRandom();
      }else{
        if(game.started && !game.stopped) playRun();
        else startIdleRandom();
      }
    }

    // NOTE: i listener dei bottoni gi√† in PART 3, qui solo boost handler aggiornato
    safeOn(btnFoodBoost,'click', ()=>{
      initAudio();

      if(game.over || game.paused) return;
      if(!game.started) return;
      if(game.stopped) return;

      // ‚úÖ se boost gi√† attivo o lock, non permettere
      if(game.boostLock) return;
      const active = (game.foodBoostT > 0 || game.ringBoostT > 0);
      if(active) return;

      if(game.foodBoostCharges <= 0) return;

      // consuma 1 carica
      game.foodBoostCharges -= 1;

      // attiva boost cibo
      game.foodBoostT = 10.0;
      game.invincibleT = Math.max(game.invincibleT, 10.0);
      bubble.visible = true;

      // ‚úÖ lock finch√© non finisce
      game.boostLock = true;

      updateFoodBoostButton();
      setFoodBoostPillUI();
      setBoostUI();
      sfx.boost();

      // ‚úÖ animazione pill numero (verr√† aggiunta in PART 6 con il nuovo pulsante contatore)
    });

    // =========================================================
    // Life / pickups
    // =========================================================
    function loseLife(){
      if(game.invincibleT>0) return;
      game.lives = Math.max(0, game.lives-1);
      sfx.hit();
      if(game.lives<=0){
        game.over=true;
        game.started=false;
        game.paused=false;
        setStop(true);
        playDie();
        updateMainButton();
      }
    }
    function addLife(){
      game.lives = Math.min(game.maxLives, game.lives+1);
      sfx.boost();
    }

    // =========================================================
    // Update loop
    // =========================================================
    let camZ = baseCamZ, camY = baseCamY, camFov = baseFov, camX = 0;
    let tPrev=performance.now();
    let runnerX = lanesX[game.lane];
    let runPhase = 0;

    // debug fps
    let fpsAcc=0, fpsN=0, fpsShow=0;
    let dbgTimer=0;

    // FPS camera state
    let fpsPhase = 0;
    let fpsX = 0, fpsY = 0;
    let fpsXPrev = 0;
    let fpsLandKick = 0;
    let fpsVyPrev = 0;
    let fpsGroundPrev = true;
    let fpsVelYSm = 0;
    let fpsLaneKick = 0;

    function update(dt, tNow){
      if(runnerMixer){
        runnerMixer.timeScale = 1.0;
        runnerMixer.update(dt);
        if(mixamoHips){ mixamoHips.position.x = hipsBaseX; mixamoHips.position.z = hipsBaseZ; }
        if(mixamoRootNode){ mixamoRootNode.position.x = rootBaseX; mixamoRootNode.position.z = rootBaseZ; }
      }

      const gameplayOn = game.started && !game.paused && !game.over;
      const stopTarget = game.stopped ? 1.0 : 0.0;
      game.stopBlend = damp(game.stopBlend, stopTarget, 8, dt);

      if(!gameplayOn){
        runnerPivot.position.x = lanesX[1];
        runnerPivot.position.y = 0;
        contact.position.x = runnerPivot.position.x;
        contact.scale.set(1.10, 1.10, 1);
        contact.material.opacity = 0.55;

        const breathe = Math.sin(tNow*0.0022) * 0.015;
        runnerCenter.position.y = 0.95 + breathe;
        runnerCenter.rotation.z = Math.sin(tNow*0.0016) * 0.015;

        game.camSpeed = 0;
        game.grounded = true;
        game.vyNow = 0;

        return;
      }

      const trafficMul = (1.0 - game.stopBlend);
      if(game.stopped){
        game.camSpeed = 0;
        game.grounded = true;
        game.vyNow = 0;
        return;
      }

      // ‚úÖ timers
      if(game.invincibleT>0){
        game.invincibleT = Math.max(0, game.invincibleT - dt*trafficMul);
        if(game.invincibleT<=0){
          bubble.visible=false;
        }
      }
      if(game.foodBoostT>0) game.foodBoostT = Math.max(0, game.foodBoostT - dt*trafficMul);
      if(game.ringBoostT>0) game.ringBoostT = Math.max(0, game.ringBoostT - dt*trafficMul);
      if(game.magnetT>0)    game.magnetT    = Math.max(0, game.magnetT    - dt*trafficMul);

      // ‚úÖ cooldown distanze powerup
      if(game.powerupCooldownZ > 0){
        // si ‚Äúconsuma‚Äù in base allo scroll: qui lo decrementiamo dopo aver calcolato speed
      }

      // ‚úÖ quando il boost finisce ‚Üí sblocca
      const anyBoostActive = (game.foodBoostT>0 || game.ringBoostT>0);
      if(!anyBoostActive && game.boostLock){
        game.boostLock = false;
      }

      const anyBoost = anyBoostActive;
      if(anyBoost && game.invincibleT<0.05){
        game.invincibleT = Math.max(game.invincibleT, Math.max(game.foodBoostT, game.ringBoostT));
        bubble.visible=true;
      }

      const foodMul = (game.foodBoostT>0) ? 2.30 : 1.0;
      const ringMul = (game.ringBoostT>0) ? 3.00 : 1.0;
      const both = (game.foodBoostT>0 && game.ringBoostT>0);
      const crazyMul = both ? 1.03 : 1.0;

      const speedMul = foodMul * ringMul * crazyMul;
      const speed = game.baseSpeed * speedMul * trafficMul;

      // ‚úÖ ora decremento cooldown distanza
      if(game.powerupCooldownZ > 0){
        game.powerupCooldownZ = Math.max(0, game.powerupCooldownZ - (speed*dt));
      }

      // ‚úÖ Run bob
      runPhase += dt * (9.5 + (speedMul-1.0)*2.0);

      const grounded = (game.y === 0 && !game.jumping);
      const bobOn = grounded ? 1.0 : 0.25;
      const slideOn = game.sliding ? 0.35 : 1.0;

      const bobY = Math.abs(Math.sin(runPhase)) * 0.045 * bobOn * slideOn;
      const sway = Math.sin(runPhase*0.5) * 0.035 * bobOn * slideOn;
      const lean = Math.sin(runPhase) * 0.050 * bobOn * slideOn;

      runnerCenter.position.y = 0.95 + bobY;
      runnerCenter.rotation.z = lean;
      runnerCenter.rotation.x = -sway * 0.35;

      game.camSpeed = speed;
      game.grounded = (game.y === 0);
      game.vyNow = game.vy;

      // physics
      const g=22.0;
      game.vy += g*dt;
      game.y  += game.vy*dt;
      if(game.y>0){ game.y=0; game.vy=0; game.jumping=false; }

      if(game.sliding){ game.slideT -= dt; if(game.slideT<=0) game.sliding=false; }

      // lane follow
      const laneTargetX = lanesX[ clamp(game.lane, 0, 3) ];
      runnerX = damp(runnerX, laneTargetX, 14, dt);
      runnerPivot.position.x = runnerX;
      runnerPivot.position.y = (-game.y);

      const h = runnerPivot.position.y;
      const s = 1.10 + clamp(h*0.65, 0, 0.85);
      contact.position.x = runnerPivot.position.x;
      contact.scale.set(s,s,1);
      contact.material.opacity = clamp(0.55 - h*0.24, 0.10, 0.55);

      const scroll = speed*dt;

      // road scroll
      highwayTex.offset.y -= scroll*0.085;
      for(const t of patchTexPool) t.offset.y -= scroll*0.085;

      for(const mesh of segments){
        mesh.position.z += scroll;
        if(mesh.position.z > segLen) mesh.position.z -= segLen*segCount;
      }
      loopJungle(scroll);
      loopClouds(scroll);
      

      // spawn
      game.spawnT -= dt;
      if(game.spawnT<=0){
        spawnRow();
        game.spawnT = rnd(0.40, 0.75);
      }

      const magnetOn = game.magnetT > 0;

      // entity update + turtle flee
      for(const e of game.entities){
        // ‚úÖ turtle scappa avanti se in fuga
        if(e.type === 'turtle' && e.obj?.userData){
          if(e.obj.userData.fleeT > 0){
            e.obj.userData.fleeT = Math.max(0, e.obj.userData.fleeT - dt);
            const fleeSpeed = 18.0 + e.obj.userData.fleeV; // extra
            e.z += fleeSpeed * dt; // scappa verso camera (pi√π veloce del scroll)
          }else{
            e.z += scroll;
          }
        }else{
          e.z += scroll;
        }
        e.obj.position.z = e.z;

        // magnet attraction
        if(magnetOn && (e.type==='coin'||e.type==='food'||e.type==='heart'||e.type==='magnet')){
          const dx = runnerPivot.position.x - e.obj.position.x;
          const dz = (0 - e.z);
          const dist = Math.hypot(dx*2.2, dz);
          if(dist < 12.0){
            e.obj.position.x += dx * dt * (5.6*(1-dist/12.0));
            if(e.obj.position.y < 1.1) e.obj.position.y += dt*0.6;
          }
        }
      }

      // cleanup behind
      for(let i=game.entities.length-1;i>=0;i--){
        const e = game.entities[i];
        if(e.z > 6.0){
          scene.remove(e.obj);
          game.entities.splice(i,1);
        }
      }

      const px = runnerPivot.position.x;
      const playerCenterY = runnerPivot.position.y + (game.sliding ? 0.55 : 0.95);

      function collideEntity(e){
        const ex = e.obj.position.x;
        const ey = (e.obj.position.y ?? 0);
        const ez = e.z;

        const dx = Math.abs(ex - px);
        const dy = Math.abs(ey - playerCenterY);
        const dz = Math.abs(ez - 0.25);

        const T = {
          coin:   { x:0.55, y:0.95, z:0.80 },
          food:   { x:0.58, y:0.98, z:0.85 },
          heart:  { x:0.58, y:0.98, z:0.85 },
          magnet: { x:0.60, y:1.05, z:0.90 },
          ring:   { x:0.42, y:0.75, z:0.55 },
          obst:   { x:0.52, y:(game.sliding ? 0.60 : 0.85), z:0.70 },
          turtle: { x:0.62, y:0.55, z:0.95 }
        };

        const th = T[e.type] || { x:0.60, y:1.0, z:0.85 };

        if(e.type === 'ring'){
          const yTh = game.sliding ? 0.55 : th.y;
          return (dx < th.x && dy < yTh && dz < th.z);
        }

        if(e.type === 'turtle'){
          if(game.jumping || runnerPivot.position.y > 0.35) return false;
          return (dx < th.x && dy < th.y && dz < th.z);
        }

        return (dx < th.x && dy < th.y && dz < th.z);
      }

      // collisions
      for(let i=game.entities.length-1;i>=0;i--){
        const e=game.entities[i];

        if(e.type==='ring'){
          if(!collideEntity(e)) continue;
          game.ringCount += 1;

          // ‚ú® magia verso HUD rings
          flyToEl(e.obj.getWorldPosition(new THREE.Vector3()), ringsEl, { icon:'‚ú®', duration:520 });

          scene.remove(e.obj); game.entities.splice(i,1);
          sfx.ring();

          if(game.ringCount >= 50){
            game.ringBoostT = 10.0;
            game.invincibleT = Math.max(game.invincibleT, 10.0);
            bubble.visible = true;
            game.ringCount = 0;
            sfx.boost();
          }
          continue;
        }

        if(e.type==='turtle'){
          if(!collideEntity(e)) continue;

          // ‚úÖ FIX: la tartaruga scappa avanti quando la colpisci (non sparisce)
          // la rimuoviamo solo dopo un attimo (quando esce dalla scena)
          sfx.boost();
          try{
            e.obj.userData.fleeT = 1.0;
            e.obj.userData.fleeV = 10 + Math.random()*8;
          }catch{}
          // niente remove/splice qui
          continue;
        }

        if(!collideEntity(e)) continue;

        if(e.type==='coin'){
          game.coins += 1;
          game.score += 28;

          flyToEl(e.obj.getWorldPosition(new THREE.Vector3()), coinsEl, { icon:'‚ú®', duration:520 });

          scene.remove(e.obj); game.entities.splice(i,1);
          sfx.coin();
          continue;
        }

        if(e.type==='food'){
          game.foodCount += 1;
          game.foodHistory.push(e.emo);
          refreshFoodUI();

          // ‚ú® magia verso colonna cibo (foodStack)
          flyToEl(e.obj.getWorldPosition(new THREE.Vector3()), foodStack, { icon:'‚ú®', duration:560 });

          scene.remove(e.obj); game.entities.splice(i,1);
          sfx.food();

          if(game.foodCount >= 10){
            game.foodBoostCharges += 1;
            game.foodCount = 0;
            game.foodHistory = [];
            refreshFoodUI();
            updateFoodBoostButton();
            sfx.boost();
          }
          continue;
        }

        if(e.type==='heart'){
          if(game.lives < game.maxLives) addLife();

          // ‚úÖ cooldown spawn powerup (heart)
          game.powerupCooldownZ = POWERUP_COOLDOWN_DIST;

          flyToEl(e.obj.getWorldPosition(new THREE.Vector3()), hpTxt, { icon:'‚ú®', duration:540 });

          scene.remove(e.obj); game.entities.splice(i,1);
          continue;
        }

        if(e.type==='magnet'){
          game.magnetT = 8.0;

          // ‚úÖ cooldown spawn powerup (magnet)
          game.powerupCooldownZ = POWERUP_COOLDOWN_DIST;

          // ‚ú® magia verso pill magnete (magTxt)
          flyToEl(e.obj.getWorldPosition(new THREE.Vector3()), magTxt, { icon:'‚ú®', duration:540 });

          scene.remove(e.obj); game.entities.splice(i,1);
          sfx.magnet();
          continue;
        }

        if(e.type==='obst'){
          const inv = (game.invincibleT>0);
          scene.remove(e.obj); game.entities.splice(i,1);
          if(!inv) loseLife();
          continue;
        }
      }

      // score tick
      game.score += (18 * speedMul) * dt;

      if(game.score > game.best){
        game.best = Math.floor(game.score);
        saveBest(game.best);
      }

      if(scoreEl) scoreEl.textContent = String(Math.floor(game.score));
      if(coinsEl) coinsEl.textContent = String(game.coins);
      if(bestEl)  bestEl.textContent  = String(game.best);
      if(ringsEl) ringsEl.textContent = String(game.ringCount);
      if(hpTxt)   hpTxt.textContent   = hpString();

      // ‚úÖ HUD bars
      setMagnetUI();
      setBoostUI();
      setFoodBoostPillUI();

      // bubble glow
      if(bubble.visible){
        bubble.material.opacity = 0.18 + 0.06*Math.sin(tNow*0.01);
      }

      tiltTarget *= 0.92;
      camRoll = damp(camRoll, tiltTarget, 10, dt);

      fitScoreText();
    }

    // =========================================================
    // Animate (camera shake boost INTENSO + bar shimmer phase)
    // =========================================================
    function animate(tNow){
      const dt=Math.min(0.030,(tNow-tPrev)/1000);
      tPrev=tNow;

      fpsAcc += dt; fpsN++;
      if(fpsAcc >= 0.5){
        fpsShow = fpsN / fpsAcc;
        fpsAcc = 0; fpsN = 0;
      }

      // phase per shimmer bars (usato in PART 6 per animazioni CSS/JS)
      hudBarAnimPhase += dt * 4.2;

      update(dt,tNow);

      const gameplayOn  = game.started && !game.paused && !game.over;
      const camDynamic  = gameplayOn && !game.stopped;

      const bothBoost = (game.foodBoostT > 0 && game.ringBoostT > 0);
      const anyBoost  = (game.foodBoostT > 0 || game.ringBoostT > 0);

      const fovBoost = bothBoost ? 7 : (anyBoost ? 5 : 0);
      const zBoost   = bothBoost ? 0.9 : (anyBoost ? 0.5 : 0.0);

      const useFovBoost = (viewMode === 'fps') ? fpsDynFov : true;

      const targetFov = clamp(baseFov + (useFovBoost ? fovBoost : 0), 30, 110);
      const targetZ   = clamp(baseCamZ + zBoost, 2, 15);
      const targetY   = clamp(baseCamY + (bothBoost ? 0.10 : 0), 0.0, 12.0);

      if(!camDynamic){
        camFov  = baseFov;
        camZ    = baseCamZ;
        camY    = baseCamY;
        camX    = 0;
        camRoll = 0;
      } else {
        camFov = damp(camFov, targetFov, 8, dt);
        camZ   = damp(camZ,   targetZ,   8, dt);
        camY   = damp(camY,   targetY,   8, dt);

        const targetCamX = clamp(runnerPivot.position.x * 0.55, -1.6, 1.6);
        camX = damp(camX, targetCamX, 5, dt);
      }

      camera.fov = camFov;
      camera.updateProjectionMatrix();

      // ‚úÖ shake abbastanza intenso quando boost attivo (NON in FPS)
      let shakeX = 0, shakeY = 0;
      if(camDynamic && anyBoost && shakeEnabled && viewMode!=='fps'){
        const base = bothBoost ? 0.030 : 0.022; // pi√π intenso
        shakeX = Math.sin(tNow*0.028) * base + Math.sin(tNow*0.071)*base*0.35;
        shakeY = Math.sin(tNow*0.035) * (base*0.65) + Math.sin(tNow*0.091)*base*0.25;
      }

      const bob = camDynamic ? (Math.sin(tNow*0.0020) * 0.005) : 0;

      camera.up.set(0,1,0);

      // ===== CAMERA MODES =====
      if(viewMode === 'fps'){
        camera.up.set(0,1,0);

        const eyeBaseY = fpsEyeY;
        const eyeFwd   = 1.05;
        const eyeZ     = 0.10;

        const stoppedOrMenu = (!game.started || game.paused || game.over || game.stopped);

        // blur fake solo in boost
        if(renderer?.domElement){
          renderer.domElement.classList.toggle('blurBoost', !!(motionBlurEnabled && anyBoost && !stoppedOrMenu));
        }

        const breatheY = stoppedOrMenu ? (Math.sin(tNow*0.0019) * 0.010) : 0.0;
        const breatheX = stoppedOrMenu ? (Math.sin(tNow*0.0015) * 0.006) : 0.0;

        const grounded = (game.y === 0 && !game.jumping);

        if(fpsGroundPrev === false && grounded === true) fpsLandKick = 1.0;
        fpsGroundPrev = grounded;

        fpsVelYSm = damp(fpsVelYSm, game.vy, 10, dt);
        fpsLandKick = damp(fpsLandKick, 0.0, 14, dt);

        if(!fpsRealistic){
          fpsLaneKick = damp(fpsLaneKick, 0.0, 20, dt);
        }else{
          fpsLaneKick = damp(fpsLaneKick, 0.0, 10, dt);
        }

        const sNorm = clamp((game.camSpeed - 8.0) / 18.0, 0, 1);
        const nonLinear = Math.pow(sNorm, 1.65);

        if(!stoppedOrMenu && fpsRealistic){
          fpsPhase += dt * (8.6 + 6.2*nonLinear + (anyBoost?1.0:0.0));
        } else {
          fpsPhase += dt * 2.0;
        }

        const runAmpY = (!stoppedOrMenu && fpsRealistic) ? (0.020 + 0.060*nonLinear) : 0.0;
        const runAmpX = (!stoppedOrMenu && fpsRealistic) ? (0.010 + 0.034*nonLinear) : 0.0;

        const runY = Math.abs(Math.sin(fpsPhase)) * runAmpY;
        const runX = Math.sin(fpsPhase*0.5) * runAmpX;

        const air = grounded ? 0.0 : 1.0;
        const airFloat = (fpsRealistic ? Math.sin(tNow*0.006) * 0.008 : 0.0);
        const landY = -fpsLandKick * 0.020;

        const slideChin = (game.sliding ? 0.10 : 0.0);
        const yFollow = runnerPivot.position.y + eyeBaseY - slideChin;

        const laneKickX = fpsRealistic ? (fpsLaneKick * 0.030) : 0.0;
        const yVelFeel = (air * clamp(-fpsVelYSm*0.002, -0.02, 0.02));

        const xOff = breatheX + (1-air)*runX + laneKickX;
        const yOff = breatheY + (1-air)*runY + airFloat + landY + yVelFeel;

        camera.position.set(
          runnerPivot.position.x + xOff,
          yFollow + yOff,
          eyeZ - eyeFwd
        );

        camera.lookAt(
          runnerPivot.position.x + xOff,
          yFollow + yOff,
          -10
        );

        camera.rotation.z = 0;
      }
      else if(viewMode === 'back'){
        const lookAtY = lerp(0.35, 1.45, framing);
        const lookAtZ = -6.5;
        camera.position.set(camX + shakeX, camY + bob + shakeY, camZ);
        camera.lookAt(camX*0.35, lookAtY, lookAtZ);
        camera.rotation.z = camRoll * 0.55;
        camera.up.set(0,1,0);
      }
      else { // FRONT
        const lookAtY = lerp(0.30, 1.55, framing);
        const lookAtZ = 0.10;
        camera.position.set(camX + shakeX, camY + bob + shakeY, -camZ);
        camera.lookAt(camX*0.35, lookAtY, lookAtZ);
        camera.rotation.z = camRoll * 0.55;
        camera.up.set(0,1,0);
      }

      if(debugOn){
        dbgTimer += dt;
        if(dbgTimer > 0.12){
          dbgTimer = 0;
          if(dbgFps) dbgFps.textContent = `fps: ${fpsShow ? fpsShow.toFixed(0) : '--'}`;
          if(dbgCam) dbgCam.textContent = `${camera.position.x.toFixed(2)}, ${camera.position.y.toFixed(2)}, ${camera.position.z.toFixed(2)}`;
          if(dbgMode) dbgMode.textContent = viewMode;
          if(dbgState) dbgState.textContent = `started:${game.started} stopped:${game.stopped} paused:${game.paused} over:${game.over} anim:${animState.mode}`;
          if(dbgEnt) dbgEnt.textContent = String(game.entities.length);
          if(dbgLane) dbgLane.textContent = String(game.lane);
          if(dbgBoosts) dbgBoosts.textContent = `food:${game.foodBoostT.toFixed(1)} ring:${game.ringBoostT.toFixed(1)} mag:${game.magnetT.toFixed(1)}`;
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // =========================================================
    // Resize + Boot continue in PART 6
    // =========================================================
    function onResize(){
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      fitScoreText();
    }
    window.addEventListener('resize', onResize);



    // =========================================================
    // ‚úÖ 1) UI: ordine pulsanti (dal basso: DANCE, AVVIA, BOOST)
    // + bottone contatore BOOST corto a sinistra
    // + rimuovi conteggio dal bottone BOOST (gi√† fatto) e mostra numero nel contatore
    // =========================================================
    (function setupBoostUI(){
      if(!rightStack || !btnDance || !btnMain || !btnFoodBoost) return;

      // ‚úÖ riordina DOM: TOP->BOTTOM deve essere: BOOST, START, DANCE
      // (perch√© flex-direction: column)
      try{
        rightStack.innerHTML = '';
        // wrapper boost row: [countBtn][boostBtn]
        const boostRow = document.createElement('div');
        boostRow.style.display = 'flex';
        boostRow.style.gap = `calc(5px * var(--menuScale))`;
        boostRow.style.alignItems = 'center';
        boostRow.style.pointerEvents = 'auto';

        // pulsante contatore (stessa altezza, pi√π corto)
        const btnBoostCount = document.createElement('button');
        btnBoostCount.id = 'btnBoostCount';
        btnBoostCount.type = 'button';
        btnBoostCount.className = 'bigBtn pillFx';
        btnBoostCount.style.width = `calc(30px * var(--menuScale) * 0.75)`;
        btnBoostCount.style.padding = '0';
        btnBoostCount.style.justifyContent = 'center';
        btnBoostCount.style.display = 'flex';
        btnBoostCount.innerHTML = `<span class="centerLbl" id="boostCountLbl">0</span>`;

        // rendi boostBtn un pelo pi√π largo per stare bene col row
        btnFoodBoost.style.width = `calc(70px * var(--menuScale) * 0.75)`;

        boostRow.appendChild(btnBoostCount);
        boostRow.appendChild(btnFoodBoost);

        // ‚úÖ inserisci in ordine: BoostRow, Start, Dance
        rightStack.appendChild(boostRow);
        rightStack.appendChild(btnMain);
        rightStack.appendChild(btnDance);

        // mostra/aggiorna numero cariche
        const boostCountLbl = $('boostCountLbl');

        // animazioni CSS via style inject
        const st = document.createElement('style');
        st.textContent = `
          @keyframes pulsePop { 
            0%{transform:scale(1)} 
            35%{transform:scale(1.18)} 
            100%{transform:scale(1)} 
          }
          @keyframes glowSweep {
            0%{filter:drop-shadow(0 0 0 rgba(160,220,255,0));}
            50%{filter:drop-shadow(0 0 10px rgba(160,220,255,.35));}
            100%{filter:drop-shadow(0 0 0 rgba(160,220,255,0));}
          }
          .pulsePop{ animation:pulsePop .28s ease; }
          .danceFlash{ animation:glowSweep .45s ease; }
          /* shimmer barre */
          .hudBar>i{
            background: linear-gradient(90deg,
              rgba(200,210,255,.65),
              rgba(255,255,255,.95),
              rgba(200,210,255,.65)
            );
            background-size: 180% 100%;
          }
          @keyframes barShine{ 
            0%{ background-position: 0% 0%; } 
            100%{ background-position: 180% 0%; } 
          }
          .barActive{ animation: barShine .9s linear infinite; }
        `;
        document.head.appendChild(st);

        function bump(el){
          if(!el) return;
          el.classList.remove('pulsePop');
          void el.offsetWidth;
          el.classList.add('pulsePop');
        }

        // esponi helper globale per altri punti
        window.__jrBoostCount = {
          el: btnBoostCount,
          lbl: boostCountLbl,
          bump
        };

        // aggiorna sempre
        const _oldUpdateFoodBoostButton = updateFoodBoostButton;
        updateFoodBoostButton = function(){
          // bottone boost visibile solo se cariche >0
          if(game.foodBoostCharges > 0){
            btnFoodBoost.style.display = 'flex';
            if(btnBoostCount) btnBoostCount.style.display = 'flex';
          }else{
            btnFoodBoost.style.display = 'none';
            if(btnBoostCount) btnBoostCount.style.display = 'none';
          }
          if(boostCountLbl) boostCountLbl.textContent = String(game.foodBoostCharges);
        };

        // bump quando cambia cariche
        let prev = game.foodBoostCharges;
        const _oldRefreshFoodUI = refreshFoodUI;
        refreshFoodUI = function(){
          _oldRefreshFoodUI();
          if(game.foodBoostCharges !== prev){
            prev = game.foodBoostCharges;
            if(window.__jrBoostCount?.el) window.__jrBoostCount.bump(window.__jrBoostCount.el);
          }
          updateFoodBoostButton();
        };

        // bump quando usi boost
        safeOn(btnFoodBoost, 'click', ()=>{
          if(window.__jrBoostCount?.el) window.__jrBoostCount.bump(window.__jrBoostCount.el);
        });

      }catch(e){
        console.warn('setupBoostUI err', e);
      }
    })();

    // =========================================================
    // ‚úÖ 2) Fix tartaruga: dopo hit NON collide pi√π ma continua a scappare
    // (sposta turtle in lista separata)
    // =========================================================
    const fleeingTurtles = [];
    (function patchTurtleFlee(){
      const _update = update;
      update = function(dt, tNow){
        _update(dt, tNow);

        // sposta turtles ‚Äúin fuga‚Äù fuori dalle entities per evitare collisioni ripetute
        for(let i=game.entities.length-1;i>=0;i--){
          const e = game.entities[i];
          if(e.type === 'turtle' && e.obj?.userData?.fleeT > 0){
            // trasferisci
            fleeingTurtles.push({
              obj: e.obj,
              z: e.z,
              v: 18 + (e.obj.userData.fleeV||0)
            });
            game.entities.splice(i,1);
          }
        }

        // aggiorna turtles in fuga
        if(fleeingTurtles.length){
          // scappa ‚Äúavanti‚Äù e sparisce quando passa la camera
          for(let i=fleeingTurtles.length-1;i>=0;i--){
            const t = fleeingTurtles[i];
            t.z += (t.v * dt);
            t.obj.position.z = t.z;
            if(t.z > 6.0){
              scene.remove(t.obj);
              fleeingTurtles.splice(i,1);
            }
          }
        }
      };
    })();

    // =========================================================
    // ‚úÖ 3) Ostacoli: stessi size + appoggiati a terra
    // =========================================================
    spawnObstacleVisual = function(){
      const w = 0.82, h = 1.02, d = 0.82;
      const box = new THREE.Mesh(
        new THREE.BoxGeometry(w,h,d),
        new THREE.MeshStandardMaterial({ color:0x6b4b2b, roughness:0.9, metalness:0.02 })
      );
      box.castShadow=true; box.receiveShadow=true;
      // appoggia a terra: y = h/2 (strada √® y=0)
      box.position.y = h/2;
      return box;
    };

    // =========================================================
    // ‚úÖ 5) Fix ‚Äúcamera capovolta‚Äù (robusto): nessuna transform CSS sul canvas
    // =========================================================
    if(renderer?.domElement){
      renderer.domElement.style.transform = 'none';
      renderer.domElement.style.webkitTransform = 'none';
    }

    // =========================================================
    // ‚úÖ 6) Slider Altezza FPS in impostazioni + salvataggio
    // =========================================================

      // refresh UI quando entri
      const _syncCamUI = syncCamUI;
      syncCamUI = function(){
        _syncCamUI();
        const s = $('fpsEyeSlider');
        const v = $('fpsEyeVal');
        if(s) s.value = fpsEyeY.toFixed(2);
        if(v) v.textContent = fpsEyeY.toFixed(2);
      };

    // =========================================================
    // ‚úÖ 7) ‚ÄúFocus slider‚Äù: quando tocchi uno slider, spariscono impostazioni (vedi bene player)
    // resta solo una striscia sottile con lo slider
    // =========================================================
    (function sliderFocusMode(){
      if(!settingsOverlay) return;
      const panel = settingsOverlay.querySelector('.panel');
      if(!panel) return;

      const focusStrip = document.createElement('div');
      focusStrip.id = 'focusStrip';
      focusStrip.className = 'pillFx';
      focusStrip.style.position = 'fixed';
      focusStrip.style.left = '50%';
      focusStrip.style.bottom = `calc(env(safe-area-inset-bottom, 0px) + 10px)`;
      focusStrip.style.transform = 'translateX(-50%)';
      focusStrip.style.width = 'min(520px, calc(100vw - 28px))';
      focusStrip.style.padding = '10px 12px';
      focusStrip.style.display = 'none';
      focusStrip.style.zIndex = '80';
      focusStrip.style.pointerEvents = 'auto';
      focusStrip.innerHTML = `<div style="font-weight:950;font-size:12px;opacity:.9;margin-bottom:8px" id="focusTitle">Regola</div>`;
      document.body.appendChild(focusStrip);

      let moved = null;

      function enterFocus(slider, title){
        if(!slider) return;
        moved = { slider, parent: slider.parentElement, next: slider.nextSibling };
        // nascondi panel quasi tutto
        panel.style.display = 'none';
        settingsOverlay.style.background = 'radial-gradient(ellipse at center, rgba(0,0,0,.08), rgba(0,0,0,.38))';

        const ft = $('focusTitle');
        if(ft) ft.textContent = title || 'Regola';

        focusStrip.appendChild(slider);
        focusStrip.style.display = 'block';
      }

      function exitFocus(){
        if(!moved) return;
        const { slider, parent, next } = moved;
        // ripristina
        if(next) parent.insertBefore(slider, next);
        else parent.appendChild(slider);
        focusStrip.style.display = 'none';
        panel.style.display = 'block';
        settingsOverlay.style.background = 'radial-gradient(ellipse at center, rgba(0,0,0,.15), rgba(0,0,0,.72))';
        moved = null;
      }

      // aggancia a tutti i range (anche quello creato ora)
      function hookAll(){
        const ranges = settingsOverlay.querySelectorAll('input[type="range"]');
        ranges.forEach(r=>{
          r.addEventListener('pointerdown', ()=>{
            // titolo dal label sopra
            const row = r.previousElementSibling;
            const lab = row?.querySelector('label')?.textContent || 'Regola';
            enterFocus(r, lab);
          }, { passive:true });
          r.addEventListener('pointerup', exitFocus, { passive:true });
          r.addEventListener('pointercancel', exitFocus, { passive:true });
        });
      }
      hookAll();

      // quando apri settings, ri-hook
      const _openSettings = openSettings;
      openSettings = function(){
        _openSettings();
        setTimeout(hookAll, 40);
      };
    })();

    // =========================================================
    // ‚úÖ 8) Animazione ‚Äúmagia‚Äù pickup ‚Üí HUD target
    // =========================================================
    function worldToScreen(v3){
      const v = v3.clone().project(camera);
      const x = (v.x * 0.5 + 0.5) * window.innerWidth;
      const y = (-v.y * 0.5 + 0.5) * window.innerHeight;
      return { x, y };
    }

    function elCenter(el){
      if(!el) return { x: window.innerWidth*0.5, y: window.innerHeight*0.5 };
      const r = el.getBoundingClientRect();
      return { x: r.left + r.width*0.5, y: r.top + r.height*0.5 };
    }

    function flyToEl(worldPos, targetEl, opt={}){
      const { duration=520 } = opt;
      const start = worldToScreen(worldPos);
      const end   = elCenter(targetEl);

      const d = document.createElement('div');
      d.style.position = 'fixed';
      d.style.left = `${start.x}px`;
      d.style.top  = `${start.y}px`;
      d.style.width = '10px';
      d.style.height = '10px';
      d.style.borderRadius = '999px';
      d.style.pointerEvents = 'none';
      d.style.zIndex = '9999';
      d.style.background = 'rgba(255,255,255,.95)';
      d.style.boxShadow = '0 0 14px rgba(160,220,255,.55), 0 0 30px rgba(160,220,255,.22)';
      document.body.appendChild(d);

      // brillantini
      const sparkN = IS_IOS ? 5 : 8;
      const sparks = [];
      for(let i=0;i<sparkN;i++){
        const s = document.createElement('div');
        s.style.position='fixed';
        s.style.left=`${start.x}px`;
        s.style.top =`${start.y}px`;
        s.style.width='4px';
        s.style.height='4px';
        s.style.borderRadius='999px';
        s.style.pointerEvents='none';
        s.style.zIndex='9998';
        s.style.background='rgba(255,255,255,.85)';
        s.style.boxShadow='0 0 10px rgba(255,255,255,.35)';
        document.body.appendChild(s);
        sparks.push({ el:s, a: rnd(0,Math.PI*2), r: rnd(10,22) });
      }

      const t0 = performance.now();
      function easeOutCubic(t){ return 1 - Math.pow(1-t,3); }
      function tick(now){
        const t = clamp((now - t0)/duration, 0, 1);
        const k = easeOutCubic(t);

        // curva ‚Äúcinematica‚Äù
        const cx = (start.x + end.x)*0.5 + rnd(-30,30);
        const cy = Math.min(start.y, end.y) - rnd(40,80);

        // bezier quad
        const x = (1-k)*(1-k)*start.x + 2*(1-k)*k*cx + k*k*end.x;
        const y = (1-k)*(1-k)*start.y + 2*(1-k)*k*cy + k*k*end.y;

        d.style.left = `${x}px`;
        d.style.top  = `${y}px`;
        d.style.transform = `translate(-50%,-50%) scale(${(0.9 + 0.3*(1-t)).toFixed(3)})`;

        for(const sp of sparks){
          const wob = (1-t);
          const sx = x + Math.cos(sp.a + now*0.02) * sp.r * wob;
          const sy = y + Math.sin(sp.a + now*0.02) * sp.r * wob;
          sp.el.style.left = `${sx}px`;
          sp.el.style.top  = `${sy}px`;
          sp.el.style.transform = `translate(-50%,-50%) scale(${(0.7 + 0.6*wob).toFixed(3)})`;
          sp.el.style.opacity = `${(1-t).toFixed(3)}`;
        }

        if(t < 1){
          requestAnimationFrame(tick);
        }else{
          d.remove();
          for(const sp of sparks) sp.el.remove();
        }
      }
      requestAnimationFrame(tick);
    }

    // =========================================================
    // ‚úÖ 9) Dance: animazione bottone + camera 360 + zoom ‚Äúcinematic‚Äù
    // =========================================================
    let danceCamOn = false;
    let orbitAz = 0.0;
    let orbitRad = 4.6;
    let orbitRadTarget = 4.6;
    let orbitY = 2.0;

    function setDanceCam(on){
      danceCamOn = !!on;
      orbitAz = 0.0;
      orbitRad = orbitRadTarget = 4.8;
    }

    safeOn(btnDance, 'click', ()=>{
      // flash UI
      btnDance.classList.remove('danceFlash'); void btnDance.offsetWidth; btnDance.classList.add('danceFlash');
      setDanceCam(true);
    });

    // input orbit solo se dance
    let danceTouch = null;
    renderer.domElement.addEventListener('pointerdown', (e)=>{
      if(!danceCamOn) return;
      renderer.domElement.setPointerCapture(e.pointerId);
      danceTouch = { x:e.clientX, y:e.clientY, id:e.pointerId };
    });
    renderer.domElement.addEventListener('pointermove', (e)=>{
      if(!danceCamOn || !danceTouch || danceTouch.id!==e.pointerId) return;
      const dx = e.clientX - danceTouch.x;
      const dy = e.clientY - danceTouch.y;
      danceTouch.x = e.clientX; danceTouch.y = e.clientY;

      // 360 orbit
      orbitAz += dx * 0.006;

      // swipe su -> zoom in (cinematic)
      orbitRadTarget = clamp(orbitRadTarget + (dy * 0.010), 2.2, 7.0);
    });
    renderer.domElement.addEventListener('pointerup', (e)=>{
      if(danceTouch && danceTouch.id===e.pointerId) danceTouch = null;
    });
    renderer.domElement.addEventListener('pointercancel', ()=>{ danceTouch=null; });

    // patch animate: se danceCamOn e animState.dance, camera orbit intorno player
    (function patchDanceCamera(){
      const _animate = animate;
      animate = function(tNow){
        

        // aggiorna lock boost UI (numero sempre)
        if(window.__jrBoostCount?.lbl){
          window.__jrBoostCount.lbl.textContent = String(game.foodBoostCharges);
          // lock: se boost attivo, fai shimmer sul contatore
          const active = (game.foodBoostT>0 || game.ringBoostT>0);
          window.__jrBoostCount.el?.classList.toggle('barActive', active);
        }

        // barra shimmer quando timer >0
        if(magBar) magBar.classList.toggle('barActive', game.magnetT>0);
        if(boostBar) boostBar.classList.toggle('barActive', (game.foodBoostT>0 || game.ringBoostT>0));
        if(foodBoostBar) foodBoostBar.classList.toggle('barActive', game.foodBoostT>0);

        _animate(tNow);

        // after _animate ha gi√† renderizzato: qui NO.
        // (quindi facciamo la camera orbit DENTRO al loop render vero: patchiamo la camera nel ramo fps/front/back in PART 5 non era facile)
        // -> soluzione: se danceCamOn, forziamo camera subito prima del render nel frame successivo:
      };
    })();

    // ‚ö†Ô∏è Patch camera orbit dentro requestAnimationFrame: usiamo un hook prima del render
    // Rimettiamo un render ‚Äúoverride‚Äù leggero: spostiamo la camera orbit in un wrapper su renderer.render
    (function patchRendererRenderForDance(){
      const _render = renderer.render.bind(renderer);
      renderer.render = function(sc, cam){
        if(danceCamOn && animState.mode === 'dance'){
          // smoothing
          orbitRad = damp(orbitRad, orbitRadTarget, 8, 1/60);

          const cx = runnerPivot.position.x;
          const cy = runnerPivot.position.y + orbitY;
          const cz = 0.0;

          const x = cx + Math.sin(orbitAz) * orbitRad;
          const z = cz + Math.cos(orbitAz) * orbitRad;

          cam.position.set(x, cy, z);
          cam.lookAt(cx, cy - 0.25, cz);

          cam.rotation.z = 0;
          cam.up.set(0,1,0);
        } else {
          // se non stai danzando, spegni danceCam
          if(danceCamOn && animState.mode !== 'dance') danceCamOn = false;
        }

        // ‚úÖ FPS eye height slider applicato
        if(viewMode === 'fps'){
          // il calcolo completo √® nel ramo FPS gi√† in PART 5
          // qui basta assicurare che il valore sia usato: lo usiamo con una variabile letta nel ramo FPS:
          // -> patchiamo una variabile globale letta nel ramo FPS usando "fpsEyeY" sostituendo eyeBaseY (vedi patch sotto).
        }

        return _render(sc, cam);
      };
    })();

    // =========================================================
    // ‚úÖ 10) Patch FPS eyeBaseY: usa fpsEyeY (slider)
    // (override leggero: ridefinisco applyViewMode non serve; patcho nel ramo FPS via variabile globale letta)
    // =========================================================
    // Hack pulito: rendiamo disponibile un getter globale e usiamo fpsEyeY al posto di 1.58
    // Nel ramo FPS di PART 5 √® "const eyeBaseY = 1.58;" ‚Üí non possiamo cambiare quella const ormai.
    // Quindi forziamo l‚Äôaltezza extra aggiungendo un offset alla camera in FPS ad ogni render.
    (function fpsEyeOffsetPatch(){
      const _render = renderer.render.bind(renderer);
      renderer.render = function(sc, cam){
        // dance wrapper gi√† sopra? se s√¨, questo rimpiazzo deve preservare l‚Äôaltro render:
        // quindi controlliamo se √® gi√† patchato
        return _render(sc, cam);
      };
      // Invece patchiamo nella tick FPS: aggiungiamo offset in animate via camera.position.y
      // (funziona perch√© nel ramo FPS la camera.position viene settata ogni frame)
      const _animate2 = animate;
      animate = function(tNow){
        _animate2(tNow);
        if(viewMode === 'fps' && (game.started && !game.paused && !game.over)){
          // aggiungi offset differenza (fpsEyeY - 1.58)
          const off = fpsEyeY - 1.58;
          camera.position.y += off;
        }
      };
    })();

    // =========================================================
    // ‚úÖ 11) Boost lock: quando boost finisce, niente spam
    // (gi√† fatto in PART 5) + feedback UI: disabilita bottone mentre attivo
    // =========================================================
    (function boostDisableFeedback(){
      const _setFoodBoostPillUI = setFoodBoostPillUI;
      setFoodBoostPillUI = function(){
        _setFoodBoostPillUI();
        const active = (game.foodBoostT>0 || game.ringBoostT>0);
        if(btnFoodBoost){
          btnFoodBoost.style.opacity = active ? '0.65' : '1';
        }
      };
    })();

    // =========================================================
    // ‚úÖ 12) Boot finale
    // =========================================================
    (async ()=>{
      refreshFoodUI();
      updateFoodBoostButton();
      if(hpTxt) hpTxt.textContent = hpString();
      syncCamUI();

      await loadRunnerModel();

      game.started = false;
      game.over = false;
      game.paused = false;
      game.stopped = true;
      game.stopBlend = 1.0;
      updateMainButton();
      startIdleRandom();

      if(scoreEl) scoreEl.textContent = '0';
      if(coinsEl) coinsEl.textContent = '0';
      if(bestEl)  bestEl.textContent = String(game.best);
      if(ringsEl) ringsEl.textContent = '0';
      setMagnetUI();
      setBoostUI();
      setFoodBoostPillUI();

      applyViewMode(viewMode);
      setDebugUI();

      // forza update UI cariche
      updateFoodBoostButton();
      fitScoreText();

      requestAnimationFrame(animate);
    })();