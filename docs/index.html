<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Jungle Emoji Runner (Three.js)</title>
  <style>
    :root{
      color-scheme: dark;

      /* ===== SCALE richieste ===== */
      --menuScale: 1.50; /* Home, Impostazioni, Avvia, Dance, foodCount, foodItem (+50%) */
      --hudScale:  1.40; /* Score, Emoji, Anelli, Vita, Magnete, Boost, Cibo Boost (+40%) */
      --hudW:      0.70; /* -30% larghezza (0.70) */

      /* barra base */
      --hud-bar-w: 60px;
    }

    html,body{
      height:100%;
      margin:0;
      background:#040805;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      overflow:hidden;
    }
    canvas{display:block;touch-action:none;}

    /* =========================================================
       PILL FX
       ========================================================= */
    .pillFx{
      position:relative;
      border-radius:999px;
      color:#eaf1ff;
      background: linear-gradient(180deg, rgba(60,90,140,.28), rgba(12,16,26,.64));
      border:1px solid rgba(170,210,255,.22);
      backdrop-filter: blur(6px) saturate(1.2);
      -webkit-backdrop-filter: blur(6px) saturate(1.2);
      box-shadow:
        0 7px 22px rgba(0,0,0,.50),
        0 0 0 1px rgba(95,160,255,.10),
        0 0 9px rgba(110,175,255,.18),
        inset 0 1px 0 rgba(255,255,255,.13),
        inset 0 -1px 0 rgba(0,0,0,.28);
      -webkit-tap-highlight-color: transparent;
    }
    .pillFx::after{
      content:"";
      position:absolute;
      inset:-1px;
      border-radius:999px;
      pointer-events:none;
      background: radial-gradient(120% 140% at 20% 10%,
        rgba(145,205,255,.32),
        rgba(90,150,255,.10) 38%,
        rgba(0,0,0,0) 72%
      );
      filter: blur(.55px);
      opacity:.85;
      mix-blend-mode: screen;
    }
    .pillFx::before{
      content:"";
      position:absolute;
      inset:0;
      border-radius:999px;
      pointer-events:none;
      background: linear-gradient(180deg, rgba(255,255,255,.11), rgba(255,255,255,0) 55%);
      opacity:.70;
    }
    button.pillFx:active{ transform:scale(.985); }

    /* =========================================================
       ICON BASE (poi vengono scalate per zona)
       ========================================================= */
    .ico{
      width:11px;
      height:11px;
      display:inline-block;
      flex:0 0 auto;
      filter: drop-shadow(0 5px 8px rgba(0,0,0,.55));
    }
    .icoSm{ width:9px; height:9px; }

    /* =========================================================
       HUD (sinistra): +40% e -30% larghezza
       ========================================================= */
    .hudWrap{
      position:fixed;
      top:calc(5px * var(--menuScale));
      left:calc(8px * var(--hudScale));
      z-index:28;
      pointer-events:none;

      width:min(
        calc(230px * var(--hudScale) * var(--hudW)),
        calc(100vw - calc(16px * var(--hudScale)))
      );
    }
    .hudCard{ pointer-events:none; background:transparent; border:none; padding:0; margin:0; }

    .hudGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:calc(6px * var(--hudScale));
      align-items:start;
    }

    .hudP{
      pointer-events:none;
      padding:calc(4px * var(--hudScale)) calc(6px * var(--hudScale));
      border-radius:999px;

      display:flex;
      align-items:center;
      justify-content:space-between;

      gap:calc(5px * var(--hudScale));
      min-width:0;
      line-height:1;

      overflow:hidden;
    }
    .hudHalf{ grid-column: span 1; }
    .hudFull{ grid-column: 1 / -1; }

    .hudL{
      display:flex;
      align-items:center;
      gap:calc(5px * var(--hudScale));
      min-width:0;
      line-height:1;
      overflow:hidden;
    }
    .hudT{
      font-weight:950;
      font-size:calc(7px * var(--hudScale));
      white-space:nowrap;
      line-height:1;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .hudV{
      font-weight:950;
      font-size:calc(8px * var(--hudScale));
      white-space:nowrap;
      line-height:1;

      display:flex;
      align-items:center;
      justify-content:center;
      gap:calc(3px * var(--hudScale));

      overflow:hidden;
      text-overflow:ellipsis;
    }

    .hudWrap .ico{
      width:calc(11px * var(--hudScale));
      height:calc(11px * var(--hudScale));
    }

    /* ‚úÖ Vita: solo cuori centrati */
    .lifePill{ justify-content:center; }
    .lifePill .hudV{ width:100%; justify-content:center; }

    /* =========================================================
       BAR ROW (Magnete/Boost/FoodBoost) con -30% larghezza
       ========================================================= */
    .hudBarRow{
      display:grid;
      grid-template-columns: auto calc(var(--hud-bar-w) * var(--hudScale) * var(--hudW)) auto;
      align-items:center;
      gap:calc(5px * var(--hudScale));
      min-width:0;
      width:100%;
      line-height:1;
    }
    .hudBar{
      height:calc(3px * var(--hudScale));
      width:calc(var(--hud-bar-w) * var(--hudScale) * var(--hudW));
      min-width:calc(var(--hud-bar-w) * var(--hudScale) * var(--hudW));
      max-width:calc(var(--hud-bar-w) * var(--hudScale) * var(--hudW));
      border-radius:999px;
      background:rgba(255,255,255,.12);
      overflow:hidden;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08);
    }
    .hudBar>i{
      display:block;height:100%;width:0%;
      background:rgba(200,210,255,.88);
      box-shadow: 0 0 7px rgba(140,200,255,.22);
    }

    #pillBoost #boostIcon{
      font-size:calc(9px * var(--hudScale));
      line-height:1;
      display:inline-block;
    }

    /* =========================================================
       TOP BUTTONS: pillola unica Home + Impostazioni (+50%)
       ========================================================= */
    .topLeftBtns{
      position:fixed;
      top:calc(5px * var(--menuScale));
      right:calc(5px * var(--menuScale));
      left:auto;
      display:flex;
      gap:calc(5px * var(--menuScale));
      z-index:30;
      pointer-events:none;
      transform:none;
      flex-direction:column;
      align-items:flex-end;
    }

    .btnGroup{
      pointer-events:auto;
      display:flex;
      align-items:center;
      gap:calc(6px * var(--menuScale));
      height:calc(16px * var(--menuScale));
      padding:0 calc(6px * var(--menuScale));
      border-radius:999px;
      border:none;
      background:transparent;
    }
    .btnSub{
      pointer-events:auto;
      cursor:pointer;
      user-select:none;
      border:none;
      background:transparent;
      padding:0;
      margin:0;

      width:calc(30px * var(--menuScale));
      height:calc(16px * var(--menuScale));
      display:flex;
      align-items:center;
      justify-content:center;
      border-radius:999px;
    }
    .btnSub .ico{
      width:calc(10px * var(--menuScale) * 1.25);
      height:calc(10px * var(--menuScale) * 1.25);
    }

    /* ===== Camera buttons (sotto Home) ===== */
    .camGroup{
      pointer-events:auto;
      display:flex;
      gap:calc(5px * var(--menuScale));
      align-items:center;
    }
    .camBtn{
      pointer-events:auto;
      border:none;
      background:transparent;
      cursor:pointer;
      user-select:none;
      height:calc(16px * var(--menuScale));
      padding:0 calc(8px * var(--menuScale));
      border-radius:999px;
      font-weight:950;
      font-size:calc(7px * var(--menuScale));
      letter-spacing:.2px;
      display:flex;
      align-items:center;
      justify-content:center;
      opacity:.92;
    }
    .camBtn.active{
      box-shadow:
        0 0 0 1px rgba(145,205,255,.30),
        0 0 12px rgba(110,175,255,.20);
      opacity:1;
    }

    /* ===== Debug button (sotto Home) ===== */
    .debugRow{
      pointer-events:auto;
      display:flex;
      align-items:center;
      gap:calc(5px * var(--menuScale));
    }
    .dbgBtn{
      pointer-events:auto;
      border:none;
      background:transparent;
      cursor:pointer;
      user-select:none;
      height:calc(16px * var(--menuScale));
      width:calc(46px * var(--menuScale));
      border-radius:999px;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .dbgBtn .ico{
      width:calc(10px * var(--menuScale) * 1.25);
      height:calc(10px * var(--menuScale) * 1.25);
    }

    /* =========================================================
       Start/Dance
       ========================================================= */
    .rightStack{
      position:fixed;
      right:calc(6px * var(--menuScale));
      bottom: calc(calc(8px * var(--menuScale)) + env(safe-area-inset-bottom, 0px) + calc(22px * var(--menuScale)));
      z-index:30;
      display:flex;
      flex-direction:column;
      gap:calc(5px * var(--menuScale));
      pointer-events:auto;
      align-items:flex-end;
    }

    .bigBtn{
      pointer-events:auto;
      position:relative;

      width:calc(70px * var(--menuScale) * 0.75);
      height:calc(20px * var(--menuScale) * 1.50);

      border-radius:999px;
      font-weight:950;
      font-size:calc(7px * var(--menuScale) * 1.125);

      letter-spacing:.25px;

      display:flex;
      align-items:center;
      justify-content:center;
      gap:0;

      color:#eaf1ff;
      background:transparent;
      border:none;
      line-height:1;
      text-align:center;
    }

    .bigBtn .centerLbl{
      width:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      line-height:1;
      text-transform:uppercase;
    }

    /* =========================================================
       Colonna cibo
       ========================================================= */
    .rightCol{
      position:fixed;
      top:calc(28px * var(--menuScale));
      right:calc(5px * var(--menuScale));
      width:calc(32px * var(--menuScale));
      display:flex; flex-direction:column; align-items:center; gap:calc(5px * var(--menuScale));
      pointer-events:none; z-index:20;
    }
    .foodStack{
      width:calc(32px * var(--menuScale));
      max-height:calc(100px * var(--menuScale));
      overflow:hidden;
      display:flex; flex-direction:column; align-items:center; gap:calc(5px * var(--menuScale));
      background:transparent; border:none; padding:0;
    }
    .foodItem{
      width:calc(27px * var(--menuScale));
      height:calc(15px * var(--menuScale));
      border-radius:999px;

      display:flex;
      align-items:center;
      justify-content:center;

      font-size:calc(8px * var(--menuScale));
      line-height:1;
    }
    .foodCount{
      width:calc(60px * var(--menuScale));
      text-align:center;
      font-weight:950;
      font-size:calc(7px * var(--menuScale));
      padding:calc(4px * var(--menuScale)) 0;
      border-radius:999px;

      display:flex;
      align-items:center;
      justify-content:center;
      gap:calc(4px * var(--menuScale));
      line-height:1;
    }
    .foodCount .icoSm{
      width:calc(9px * var(--menuScale));
      height:calc(9px * var(--menuScale));
    }

    /* =========================================================
       SETTINGS
       ========================================================= */
    .settingsOverlay{
      position:fixed; inset:0;
      display:none;
      align-items:flex-end;
      justify-content:center;
      padding:14px;
      background:radial-gradient(ellipse at center, rgba(0,0,0,.15), rgba(0,0,0,.65));
      backdrop-filter:blur(10px);
      z-index:40;
    }
    .panel{
      width:min(680px,100%);
      border-radius:18px;border:1px solid rgba(255,255,255,.16);
      background:rgba(10,14,22,.86);
      box-shadow:0 18px 60px rgba(0,0,0,.55);
      padding:14px;color:#eaf1ff;
    }
    .title{font-size:16px;font-weight:950;margin:4px 0 10px;}
    .settingsRow{display:flex;justify-content:space-between;align-items:center;gap:10px;font-size:13px;margin-top:10px;}
    .settingsRow small{opacity:.8}
    .settingsVal{font-weight:950}
    input[type="range"]{ width:100%; height:18px; accent-color: rgba(255,255,255,.85); }

    .toggle{
      display:flex;align-items:center;justify-content:space-between;
      border:1px solid rgba(255,255,255,.16);
      border-radius:14px;padding:10px 12px;background:rgba(255,255,255,.06);
      cursor:pointer;user-select:none;margin-top:10px;
    }
    .toggle label{font-weight:900;}
    .toggle span{opacity:.85;font-size:12px;}
    .switch{width:44px;height:26px;border-radius:99px;background:rgba(255,255,255,.14);position:relative;border:1px solid rgba(255,255,255,.16);}
    .switch i{position:absolute;top:3px;left:3px;width:20px;height:20px;border-radius:999px;background:rgba(255,255,255,.86);transition:transform .18s ease;}
    .switch.on{background:rgba(140,255,190,.18);border-color:rgba(140,255,190,.24);}
    .switch.on i{transform:translateX(18px);}

    /* =========================================================
       DEBUG PANEL
       ========================================================= */
    .debugPanel{
      position:fixed;
      right:calc(6px * var(--menuScale));
      top:calc(5px * var(--menuScale) + calc(16px * var(--menuScale)) + calc(16px * var(--menuScale)) + 24px);
      z-index:60;
      width:min(320px, calc(100vw - 20px));
      padding:10px 12px;
      border-radius:16px;
      display:none;
      pointer-events:auto;
      font-size:12px;
      line-height:1.35;
      color:#eaf1ff;
    }
    .dbgRow{ display:flex; justify-content:space-between; gap:10px; }
    .dbgRow b{ font-weight:950; }
    .dbgSmall{ opacity:.85; font-size:11px; }
    .dbgSep{ height:1px; background:rgba(255,255,255,.10); margin:8px 0; }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>

  <!-- ‚úÖ HUD SINISTRA -->
  <div class="hudWrap">
    <div class="hudCard">
      <div class="hudGrid">

        <!-- Score (sx) -->
        <div class="hudP pillFx hudHalf">
          <div class="hudL">
            <svg class="ico" viewBox="0 0 24 24" aria-hidden="true">
              <defs>
                <linearGradient id="gFlag" x1="0" y1="0" x2="1" y2="1">
                  <stop offset="0" stop-color="#ffffff" stop-opacity=".95"/>
                  <stop offset=".45" stop-color="#b7d9ff" stop-opacity=".9"/>
                  <stop offset="1" stop-color="#7fb4ff" stop-opacity=".85"/>
                </linearGradient>
              </defs>
              <path fill="url(#gFlag)" d="M6 3c.6 0 1 .4 1 1v1h9.4c.4 0 .7.1 1 .3l2.1 1.4c.6.4.6 1.2 0 1.6L18.4 11c-.3.2-.6.3-1 .3H7v9a1 1 0 0 1-2 0V4c0-.6.4-1 1-1Z"/>
              <path fill="rgba(255,255,255,.25)" d="M7 6h10.8l1.1.7-1.1.7H7z"/>
            </svg>
            <div class="hudT">Score</div>
          </div>
          <div class="hudV"><span id="score">0</span></div>
        </div>

        <!-- Emoji (dx) -->
        <div class="hudP pillFx hudHalf">
          <div class="hudL">
            <svg class="ico" viewBox="0 0 24 24" aria-hidden="true">
              <defs>
                <radialGradient id="gSmile" cx="30%" cy="25%" r="80%">
                  <stop offset="0" stop-color="#ffffff" stop-opacity=".95"/>
                  <stop offset=".35" stop-color="#ffe8a8" stop-opacity=".95"/>
                  <stop offset="1" stop-color="#ffb84d" stop-opacity=".95"/>
                </radialGradient>
              </defs>
              <circle cx="12" cy="12" r="9" fill="url(#gSmile)"/>
              <circle cx="9" cy="10" r="1.1" fill="rgba(0,0,0,.65)"/>
              <circle cx="15" cy="10" r="1.1" fill="rgba(0,0,0,.65)"/>
              <path d="M8.3 13.3c.9 2.5 6.5 2.5 7.4 0" fill="none" stroke="rgba(0,0,0,.55)" stroke-width="1.6" stroke-linecap="round"/>
            </svg>
            <div class="hudT">Emoji</div>
          </div>
          <div class="hudV"><span id="coins">0</span></div>
        </div>

        <!-- Rings (sx) -->
        <div class="hudP pillFx hudHalf">
          <div class="hudL">
            <svg class="ico" viewBox="0 0 24 24" aria-hidden="true">
              <defs>
                <radialGradient id="gRing" cx="35%" cy="30%" r="80%">
                  <stop offset="0" stop-color="#ffffff" stop-opacity=".9"/>
                  <stop offset=".35" stop-color="#ffb0a8" stop-opacity=".95"/>
                  <stop offset="1" stop-color="#ff3b30" stop-opacity=".95"/>
                </radialGradient>
              </defs>
              <circle cx="12" cy="12" r="7.8" fill="url(#gRing)"/>
              <circle cx="12" cy="12" r="4.6" fill="#0b0f18"/>
            </svg>
            <div class="hudT">Rings</div>
          </div>
          <div class="hudV"><span id="rings">0</span></div>
        </div>

        <!-- Vita -->
        <div class="hudP pillFx hudHalf lifePill">
          <div class="hudV"><span id="hpTxt">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏èüñ§üñ§</span></div>
        </div>

        <!-- Magnete -->
        <div class="hudP pillFx hudFull">
          <div class="hudBarRow">
            <div class="hudL">
              <svg class="ico" viewBox="0 0 24 24" aria-hidden="true">
                <defs>
                  <linearGradient id="gMag" x1="0" y1="0" x2="1" y2="1">
                    <stop offset="0" stop-color="#ffffff" stop-opacity=".95"/>
                    <stop offset=".35" stop-color="#ffd1d1" stop-opacity=".95"/>
                    <stop offset="1" stop-color="#ff3b30" stop-opacity=".95"/>
                  </linearGradient>
                </defs>
                <path fill="url(#gMag)" d="M7 3h4v9a1 1 0 0 0 2 0V3h4v9c0 3.9-3.1 7-7 7s-7-3.1-7-7V3Z"/>
                <path fill="rgba(0,0,0,.25)" d="M7 3h4v2H7V3zm10 0h-4v2h4V3z"/>
              </svg>
              <div class="hudT">Magnete</div>
            </div>
            <div class="hudBar"><i id="magBar"></i></div>
            <div class="hudV"><span id="magTxt">üß≤ 0</span></div>
          </div>
        </div>

        <!-- Boost -->
        <div class="hudP pillFx hudFull" id="pillBoost" style="display:none;">
          <div class="hudBarRow">
            <div class="hudL">
              <span id="boostIcon">‚ö°Ô∏è</span>
              <div class="hudT"><strong id="boostName">BOOST</strong></div>
            </div>
            <div class="hudBar"><i id="boostBar"></i></div>
            <div class="hudV"><span id="boostTime">0.0s</span></div>
          </div>
        </div>

        <!-- Food Boost -->
        <div class="hudP pillFx hudFull" id="foodBoostPill" style="display:none;">
          <div class="hudBarRow">
            <div class="hudL">
              <svg class="ico" viewBox="0 0 24 24" aria-hidden="true">
                <defs>
                  <linearGradient id="gFoodBoost" x1="0" y1="0" x2="1" y2="1">
                    <stop offset="0" stop-color="#ffffff" stop-opacity=".95"/>
                    <stop offset=".4" stop-color="#d6ffe9" stop-opacity=".95"/>
                    <stop offset="1" stop-color="#34c759" stop-opacity=".92"/>
                  </linearGradient>
                </defs>
                <path fill="url(#gFoodBoost)" d="M8 7c0-2.2 1.8-4 4-4s4 1.8 4 4v1h1.2c1 0 1.8.8 1.8 1.8V19c0 1-.8 1.8-1.8 1.8H6.8C5.8 20.8 5 20 5 19V9.8C5 8.8 5.8 8 6.8 8H8V7Zm2 1h4V7c0-1.1-.9-2-2-2s-2 .9-2 2v1Z"/>
                <path fill="rgba(0,0,0,.22)" d="M7 12h10v2H7v-2z"/>
              </svg>
              <div class="hudT">Cibo</div>
            </div>
            <div class="hudBar"><i id="foodBoostBar"></i></div>
            <div class="hudV"><span id="foodBoostTime">0.0s</span></div>
          </div>
        </div>

      </div>

      <span id="best" style="display:none;">0</span>
    </div>
  </div>

  <!-- ‚úÖ TOP RIGHT: Home+Impostazioni + (sotto) camera buttons + debug -->
  <div class="topLeftBtns">
    <div class="btnGroup pillFx" aria-label="Menu">
      <button class="btnSub" id="btnHome" aria-label="Home" title="Home">
        <svg class="ico" viewBox="0 0 24 24" aria-hidden="true">
          <defs>
            <linearGradient id="gHome" x1="0" y1="0" x2="1" y2="1">
              <stop offset="0" stop-color="#ffffff" stop-opacity=".95"/>
              <stop offset=".45" stop-color="#cfe6ff" stop-opacity=".95"/>
              <stop offset="1" stop-color="#7fb4ff" stop-opacity=".9"/>
            </linearGradient>
          </defs>
          <path fill="url(#gHome)" d="M12 3.2 3 10.7v1.6h2v8.5h5.6v-5.7h2.8v5.7H19v-8.5h2v-1.6L12 3.2z"/>
        </svg>
      </button>

      <button class="btnSub" id="btnSettings" aria-label="Impostazioni" title="Impostazioni">
        <svg class="ico" viewBox="0 0 24 24" aria-hidden="true">
          <defs>
            <linearGradient id="gGear" x1="0" y1="0" x2="1" y2="1">
              <stop offset="0" stop-color="#ffffff" stop-opacity=".98"/>
              <stop offset=".45" stop-color="#d8eeff" stop-opacity=".96"/>
              <stop offset="1" stop-color="#8ac0ff" stop-opacity=".92"/>
            </linearGradient>
          </defs>
          <path fill="url(#gGear)" d="M19.4 13.5c.04-.5.04-1 0-1.5l2-1.5-2-3.4-2.4 1c-.4-.33-.85-.6-1.3-.8l-.4-2.6H10l-.4 2.6c-.45.2-.9.47-1.3.8l-2.4-1-2 3.4 2 1.5c-.04.5-.04 1 0 1.5l-2 1.5 2 3.4 2.4-1c.4.33.85.6 1.3.8l.4 2.6h4.2l.4-2.6c.45-.2.9-.47 1.3-.8l2.4 1 2-3.4-2-1.5z"/>
        </svg>
      </button>
    </div>

    <!-- Camera buttons -->
    <div class="camGroup">
      <button class="camBtn pillFx" id="btnCamBack" title="Visuale dietro">BACK</button>
      <button class="camBtn pillFx" id="btnCamFPS" title="Visuale FPS">FPS</button>
      <button class="camBtn pillFx" id="btnCamFront" title="Visuale davanti">FRONT</button>
    </div>

    <!-- Debug button -->
    <div class="debugRow">
      <button class="dbgBtn pillFx" id="btnDebug" title="Debug">
        <svg class="ico" viewBox="0 0 24 24" aria-hidden="true">
          <defs>
            <linearGradient id="gBug" x1="0" y1="0" x2="1" y2="1">
              <stop offset="0" stop-color="#ffffff" stop-opacity=".98"/>
              <stop offset=".45" stop-color="#d6ffe9" stop-opacity=".96"/>
              <stop offset="1" stop-color="#34c759" stop-opacity=".92"/>
            </linearGradient>
          </defs>
          <path fill="url(#gBug)" d="M14 7.2c.6-.5 1-1.2 1-2 0-1.5-1.3-2.7-3-2.7S9 3.7 9 5.2c0 .8.4 1.5 1 2C7.7 8 6.2 10 6.2 12.4V14H5v1.6h1.2c.1.8.4 1.6.8 2.3l-1 .9 1 1.2 1.1-1c.9.7 2 .9 3.2.9s2.3-.2 3.2-.9l1.1 1 1-1.2-1-.9c.4-.7.7-1.5.8-2.3H19V14h-1.2v-1.6c0-2.4-1.5-4.4-3.8-5.2ZM8.8 14h6.4v1.6H8.8V14Zm0-3.2h6.4V12.4H8.8v-1.6Z"/>
        </svg>
      </button>
    </div>
  </div>

  <!-- Start / Dance -->
  <div class="rightStack">
    <button class="bigBtn pillFx" id="btnMain">
      <span class="centerLbl" id="mainLbl">AVVIA</span>
    </button>

    <button class="bigBtn pillFx" id="btnDance">
      <span class="centerLbl">DANCE</span>
    </button>
  </div>

  <!-- Colonna cibo -->
  <div class="rightCol">
    <div class="foodStack" id="foodStack"></div>
    <div class="foodCount pillFx">
      <svg class="icoSm" viewBox="0 0 24 24" aria-hidden="true">
        <defs>
          <linearGradient id="gBag" x1="0" y1="0" x2="1" y2="1">
            <stop offset="0" stop-color="#ffffff" stop-opacity=".95"/>
            <stop offset=".4" stop-color="#d6ffe9" stop-opacity=".95"/>
            <stop offset="1" stop-color="#34c759" stop-opacity=".92"/>
          </linearGradient>
        </defs>
        <path fill="url(#gBag)" d="M8 7c0-2.2 1.8-4 4-4s4 1.8 4 4v1h1.2c1 0 1.8.8 1.8 1.8V19c0 1-.8 1.8-1.8 1.8H6.8C5.8 20.8 5 20 5 19V9.8C5 8.8 5.8 8 6.8 8H8V7z"/>
      </svg>
      <span><span id="foodCount">0</span>/10</span>
    </div>
  </div>

  <!-- DEBUG PANEL -->
  <div class="debugPanel pillFx" id="debugPanel">
    <div class="dbgRow"><b>DEBUG</b><span class="dbgSmall" id="dbgFps">fps: --</span></div>
    <div class="dbgSep"></div>
    <div class="dbgRow"><span>camera</span><span id="dbgCam">--</span></div>
    <div class="dbgRow"><span>mode</span><span id="dbgMode">--</span></div>
    <div class="dbgRow"><span>state</span><span id="dbgState">--</span></div>
    <div class="dbgRow"><span>entities</span><span id="dbgEnt">--</span></div>
    <div class="dbgRow"><span>lane</span><span id="dbgLane">--</span></div>
    <div class="dbgRow"><span>boosts</span><span id="dbgBoosts">--</span></div>
  </div>

  <!-- SETTINGS -->
  <div class="settingsOverlay" id="settingsOverlay">
    <div class="panel">
      <div class="title">Impostazioni</div>

      <div class="settingsRow">
        <div><label>FOV</label><br><small>30‚Äì110 (base 60)</small></div>
        <div class="settingsVal" id="fovVal">60</div>
      </div>
      <input id="fovSlider" type="range" min="30" max="110" step="1" value="60" />

      <div class="settingsRow">
        <div><label>Distanza camera</label><br><small>2‚Äì15 (base 5.0)</small></div>
        <div class="settingsVal" id="camVal">5.0</div>
      </div>
      <input id="camSlider" type="range" min="2" max="15" step="0.1" value="5.0" />

      <div class="settingsRow">
        <div><label>Altezza camera</label><br><small>0=terra ‚Ä¢ 8=alto</small></div>
        <div class="settingsVal" id="camYVal">4.6</div>
      </div>
      <input id="camYSlider" type="range" min="0" max="8" step="0.1" value="4.6" />

      <div class="settingsRow">
        <div><label>Inquadratura player</label><br><small>0=alto ‚Ä¢ 1=molto in basso</small></div>
        <div class="settingsVal" id="frameVal">0.06</div>
      </div>
      <input id="frameSlider" type="range" min="0" max="1" step="0.01" value="0.06" />

      <!-- ‚úÖ Toggle FPS in impostazioni -->
      <div class="toggle" id="fpsToggle">
        <div><label>Visuale FPS</label><br/><span>Camera sugli ‚Äúocchi‚Äù (nasconde testa/maschera).</span></div>
        <div class="switch" id="fpsSwitch"><i></i></div>
      </div>

      <div class="toggle" id="audioToggle">
        <div><label>Suoni</label><br/><span>Fallback semplice (stabile su iPhone).</span></div>
        <div class="switch on" id="audioSwitch"><i></i></div>
      </div>

      <div class="toggle" id="shakeToggle">
        <div><label>Camera shake</label><br/><span>Micro shake durante i boost.</span></div>
        <div class="switch on" id="shakeSwitch"><i></i></div>
      </div>

      <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:12px;">
        <button class="btnGroup pillFx" style="height:auto;padding:10px 12px;" id="resetCam">Reset camera</button>
        <button class="btnGroup pillFx" style="height:auto;padding:10px 12px;" id="closeSettings">Chiudi</button>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    /* =========================================================
       ‚úÖ MINI FIX ‚ÄúSAFE‚Äù (anti-schermo-nero)
       ========================================================= */
    const $ = (id)=>document.getElementById(id);
    function safeOn(el, ev, fn){ if(el) el.addEventListener(ev, fn); }

    window.addEventListener('error', (e)=>{
      console.warn('JS error caught:', e?.message || e);
    });

    const IS_IOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

    // ===== UI: HUD =====
    const scoreEl = $('score');
    const coinsEl = $('coins');
    const bestEl  = $('best'); // hidden
    const ringsEl = $('rings');
    const hpTxt   = $('hpTxt');
    const magTxt  = $('magTxt');

    const pillBoost = $('pillBoost');
    const boostIcon = $('boostIcon');
    const boostName = $('boostName');
    const boostBar  = $('boostBar');

    const foodStack = $('foodStack');
    const foodCountEl = $('foodCount');

    // ===== UI: Buttons =====
    const btnHome = $('btnHome');
    const btnSettings = $('btnSettings');

    const btnMain = $('btnMain');
    const mainLbl = $('mainLbl');
    const btnDance = $('btnDance');

    // Camera buttons
    const btnCamBack  = $('btnCamBack');
    const btnCamFPS   = $('btnCamFPS');
    const btnCamFront = $('btnCamFront');

    // Debug
    const btnDebug = $('btnDebug');
    const debugPanel = $('debugPanel');
    const dbgFps = $('dbgFps');
    const dbgCam = $('dbgCam');
    const dbgMode = $('dbgMode');
    const dbgState = $('dbgState');
    const dbgEnt = $('dbgEnt');
    const dbgLane = $('dbgLane');
    const dbgBoosts = $('dbgBoosts');

    // ===== Settings overlay =====
    const settingsOverlay = $('settingsOverlay');
    const closeSettingsBtn = $('closeSettings');
    const resetCamBtn = $('resetCam');

    const audioToggle= $('audioToggle');
    const audioSwitch= $('audioSwitch');
    const shakeToggle = $('shakeToggle');
    const shakeSwitch = $('shakeSwitch');

    const fpsToggle = $('fpsToggle');
    const fpsSwitch = $('fpsSwitch');

    const fovSlider = $('fovSlider');
    const camSlider = $('camSlider');
    const camYSlider = $('camYSlider');
    const frameSlider = $('frameSlider');

    const fovVal = $('fovVal');
    const camVal = $('camVal');
    const camYVal = $('camYVal');
    const frameVal = $('frameVal');

    const rnd=(a,b)=>a+Math.random()*(b-a);
    const rndi=(a,b)=>Math.floor(rnd(a,b+1));
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp=(a,b,t)=>a+(b-a)*t;
    const damp = (current, target, lambda, dt) => current + (target-current) * (1 - Math.exp(-lambda*dt));

    // ===== SETTINGS =====
    const CAM_KEY = 'jr_cam_settings_v10';
    const DEFAULTS = {
      baseFov: 60,
      baseCamZ: 5.0,
      baseCamY: 4.6,
      framing: 0.06,
      shake: true,
      view: 'front',
      debug: false,

      // ‚úÖ opzioni FPS (salvate)
      fpsRealistic: true,   // true = bob + micro movimento, false = stabile
      fpsDynFov: true       // true = FOV dinamico SOLO in FPS
    };
    const saved = (()=>{ try{return JSON.parse(localStorage.getItem(CAM_KEY)||'{}')}catch{return {}} })();

    let baseFov  = clamp(Number(saved.baseFov ?? DEFAULTS.baseFov), 30, 110);
    let baseCamZ = clamp(Number(saved.baseCamZ ?? DEFAULTS.baseCamZ), 2, 15);
    let baseCamY = clamp(Number(saved.baseCamY ?? DEFAULTS.baseCamY), 0, 8);
    let framing  = clamp(Number(saved.framing ?? DEFAULTS.framing), 0, 1);
    let shakeEnabled = (saved.shake ?? DEFAULTS.shake) !== false;

    let viewMode = (saved.view ?? DEFAULTS.view);
    if(!['front','back','fps'].includes(viewMode)) viewMode = 'front';

    let debugOn = !!(saved.debug ?? DEFAULTS.debug);

    let fpsRealistic = (saved.fpsRealistic ?? DEFAULTS.fpsRealistic) !== false;
    let fpsDynFov    = (saved.fpsDynFov ?? DEFAULTS.fpsDynFov) !== false;

    function saveCam(){
      localStorage.setItem(CAM_KEY, JSON.stringify({
        baseFov, baseCamZ, baseCamY, framing,
        shake: !!shakeEnabled,
        view: viewMode,
        debug: !!debugOn,
        fpsRealistic: !!fpsRealistic,
        fpsDynFov: !!fpsDynFov
      }));
    }

    function setActiveCamBtns(){
      if(btnCamBack)  btnCamBack.classList.toggle('active', viewMode==='back');
      if(btnCamFPS)   btnCamFPS.classList.toggle('active', viewMode==='fps');
      if(btnCamFront) btnCamFront.classList.toggle('active', viewMode==='front');
      if(fpsSwitch)   fpsSwitch.classList.toggle('on', viewMode==='fps');
    }

    function setDebugUI(){
      if(debugPanel) debugPanel.style.display = debugOn ? 'block' : 'none';
    }

    function syncCamUI(){
      if(fovSlider){ fovSlider.value = String(Math.round(baseFov)); }
      if(fovVal){ fovVal.textContent = String(Math.round(baseFov)); }

      if(camSlider){ camSlider.value = String(baseCamZ.toFixed(1)); }
      if(camVal){ camVal.textContent = baseCamZ.toFixed(1); }

      if(camYSlider){ camYSlider.value = String(baseCamY.toFixed(1)); }
      if(camYVal){ camYVal.textContent = baseCamY.toFixed(1); }

      if(frameSlider){ frameSlider.value = String(framing.toFixed(2)); }
      if(frameVal){ frameVal.textContent = framing.toFixed(2); }

      if(shakeSwitch){ shakeSwitch.classList.toggle('on', !!shakeEnabled); }
      if(audioSwitch){ audioSwitch.classList.toggle('on', !!audioEnabled); }

      setActiveCamBtns();
      setDebugUI();
    }

    safeOn(fovSlider, 'input', ()=>{ baseFov = clamp(Number(fovSlider.value), 30, 110); if(fovVal) fovVal.textContent = String(Math.round(baseFov)); saveCam(); });
    safeOn(camSlider, 'input', ()=>{ baseCamZ = clamp(Number(camSlider.value), 2, 15); if(camVal) camVal.textContent = baseCamZ.toFixed(1); saveCam(); });
    safeOn(camYSlider,'input', ()=>{ baseCamY = clamp(Number(camYSlider.value), 0, 8); if(camYVal) camYVal.textContent = baseCamY.toFixed(1); saveCam(); });
    safeOn(frameSlider,'input', ()=>{ framing = clamp(Number(frameSlider.value), 0, 1); if(frameVal) frameVal.textContent = framing.toFixed(2); saveCam(); });

    function openSettings(){ if(settingsOverlay){ settingsOverlay.style.display='flex'; } syncCamUI(); }
    function closeSettings(){ if(settingsOverlay){ settingsOverlay.style.display='none'; } }

    safeOn(btnSettings,'click', ()=>{ initAudio(); openSettings(); });
    safeOn(closeSettingsBtn,'click', closeSettings);

    safeOn(shakeToggle,'click', ()=>{
      shakeEnabled = !shakeEnabled;
      if(shakeSwitch) shakeSwitch.classList.toggle('on', !!shakeEnabled);
      saveCam();
    });

    safeOn(resetCamBtn,'click', ()=>{
      baseFov = DEFAULTS.baseFov;
      baseCamZ = DEFAULTS.baseCamZ;
      baseCamY = DEFAULTS.baseCamY;
      framing = DEFAULTS.framing;
      shakeEnabled = DEFAULTS.shake;
      viewMode = DEFAULTS.view;
      debugOn = DEFAULTS.debug;
      fpsRealistic = DEFAULTS.fpsRealistic;
      fpsDynFov = DEFAULTS.fpsDynFov;
      saveCam(); syncCamUI();
      applyViewMode(viewMode);
    });

    // ===== Audio minimal =====
    let audioEnabled=true, audioReady=false, actx=null, master=null;
    function initAudio(){
      if(audioReady) return;
      try{
        actx = new (window.AudioContext||window.webkitAudioContext)();
        master = actx.createGain(); master.gain.value=0.55; master.connect(actx.destination);
        audioReady=true;
      }catch(e){ audioEnabled=false; }
      if(audioSwitch) audioSwitch.classList.toggle('on',!!audioEnabled);
    }
    function beep(type,freq,dur=0.06,g=0.10){
      if(!audioEnabled) return;
      initAudio(); if(!audioReady) return;
      const t0=actx.currentTime;
      const o=actx.createOscillator();
      const gg=actx.createGain();
      o.type=type; o.frequency.setValueAtTime(freq,t0);
      gg.gain.setValueAtTime(0.0001,t0);
      gg.gain.exponentialRampToValueAtTime(g,t0+0.012);
      gg.gain.exponentialRampToValueAtTime(0.0001,t0+dur);
      o.connect(gg); gg.connect(master);
      o.start(t0); o.stop(t0+dur+0.02);
    }
    const sfx = {
      coin: ()=>{ beep('triangle', 900, 0.06, 0.10); beep('sine', 1350, 0.07, 0.07); },
      food: ()=>{ beep('sine', 520, 0.06, 0.09); },
      ring: ()=>{ beep('triangle', 700, 0.06, 0.10); },
      magnet: ()=>{ beep('sawtooth', 420, 0.10, 0.09); beep('triangle', 880, 0.10, 0.07); },
      hit:  ()=>{ beep('square', 120, 0.12, 0.11); },
      lane: ()=>{ beep('sine', 160, 0.05, 0.05); },
      jump: ()=>{ beep('square', 420, 0.05, 0.08); },
      slide:()=>{ beep('sine', 220, 0.06, 0.06); },
      boost:()=>{ beep('sawtooth', 520, 0.10, 0.09); beep('triangle', 880, 0.10, 0.07); },
    };
    safeOn(audioToggle,'click', ()=>{ initAudio(); audioEnabled=!audioEnabled; if(audioSwitch) audioSwitch.classList.toggle('on',!!audioEnabled); });

    // ===== Renderer / Scene =====
    const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x08120b);
    scene.fog = IS_IOS ? new THREE.Fog(0x08120b, 26, 110) : new THREE.FogExp2(0x06110a, 0.036);

    const camera = new THREE.PerspectiveCamera(baseFov, window.innerWidth/window.innerHeight, 0.1, 320);
    camera.up.set(0,1,0);

    // lights
    const sun = new THREE.DirectionalLight(0xf3ffe6, IS_IOS ? 2.8 : 2.1);
    sun.position.set(6, 10, 6);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048,2048);
    sun.shadow.camera.near = 0.5;
    sun.shadow.camera.far = 80;
    sun.shadow.camera.left = -12;
    sun.shadow.camera.right=  12;
    sun.shadow.camera.top  =  12;
    sun.shadow.camera.bottom=-12;
    sun.shadow.bias = -0.00023;
    scene.add(sun);
    scene.add(new THREE.HemisphereLight(0xaaffdd, 0x081209, IS_IOS ? 1.05 : 0.78));
    scene.add(new THREE.AmbientLight(0xffffff, IS_IOS ? 0.6 : 0.24));
    const front = new THREE.DirectionalLight(0xffffff, IS_IOS ? 1.25 : 0.55);
    front.position.set(0, 4, 9);
    scene.add(front);

    // Contact shadow
    function makeContactShadowTexture(size=512){
      const c=document.createElement('canvas'); c.width=c.height=size;
      const g=c.getContext('2d');
      g.clearRect(0,0,size,size);
      const grd=g.createRadialGradient(size/2,size/2,0, size/2,size/2,size*0.48);
      grd.addColorStop(0,'rgba(0,0,0,0.38)');
      grd.addColorStop(0.55,'rgba(0,0,0,0.10)');
      grd.addColorStop(1,'rgba(0,0,0,0)');
      g.fillStyle=grd; g.fillRect(0,0,size,size);
      const t=new THREE.CanvasTexture(c); t.colorSpace=THREE.SRGBColorSpace;
      return t;
    }
    const contact = new THREE.Mesh(
      new THREE.PlaneGeometry(1.5,1.5),
      new THREE.MeshBasicMaterial({ map:makeContactShadowTexture(512), transparent:true, opacity:0.55, depthWrite:false })
    );
    contact.rotation.x = -Math.PI/2;
    contact.position.set(0, 0.02, 0.2);
    scene.add(contact);

    // ===== STRADA =====
    const segLen = 9.0, segCount = 10;
    const laneW = 1.35;
    const mainRoadWidth = laneW * 3;
    const shoulderWidth = 1.40;
    const totalRoadWidth = mainRoadWidth + shoulderWidth;
    const leftEdge = -totalRoadWidth/2;
    const lanesX = [
      leftEdge + laneW*0.5,
      leftEdge + laneW*1.5,
      leftEdge + laneW*2.5,
      leftEdge + mainRoadWidth + shoulderWidth*0.5
    ];

    function makeHighwayTexture(size=1024){
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const g = c.getContext('2d');
      g.fillStyle = '#2b2f35';
      g.fillRect(0,0,size,size);

      for(let i=0;i<20000;i++){
        const x = Math.random()*size, y = Math.random()*size;
        const v = Math.floor(70 + Math.random()*70);
        g.fillStyle = `rgba(${v},${v},${v},${Math.random()*0.10})`;
        g.fillRect(x,y,1,1);
      }

      const px = (worldX)=> Math.round(((worldX - leftEdge) / totalRoadWidth) * size);

      const shoulderStartX = leftEdge + mainRoadWidth;
      g.fillStyle = 'rgba(255,255,255,0.03)';
      g.fillRect(px(shoulderStartX), 0, px(leftEdge+totalRoadWidth) - px(shoulderStartX), size);

      const solidW = Math.max(6, Math.round(size * 0.008));
      const dashW  = Math.max(5, Math.round(size * 0.0065));
      const dashLen = Math.round(size * 0.180);
      const dashGap = Math.round(size * 0.999);

      g.fillStyle = '#f4f6f8';

      const xOuterL = px(leftEdge + 0.03);
      const xOuterR = px(leftEdge + totalRoadWidth - 0.03);
      const xOuterLi = Math.round(xOuterL - solidW/2);
      const xOuterRi = Math.round(xOuterR - solidW/2);
      g.fillRect(xOuterLi, 0, solidW, size);
      g.fillRect(xOuterRi, 0, solidW, size);

      const xShoulderSep = px(shoulderStartX);
      const xShoulderSepI = Math.round(xShoulderSep - solidW/2);
      g.fillRect(xShoulderSepI, 0, solidW, size);

      const xDash1 = px(leftEdge + laneW*1);
      const xDash2 = px(leftEdge + laneW*2);
      const xDash1I = Math.round(xDash1 - dashW/2);
      const xDash2I = Math.round(xDash2 - dashW/2);

      for(let y=0; y<size; y += (dashLen + dashGap)){
        const yi = Math.round(y);
        g.fillRect(xDash1I, yi, dashW, dashLen);
        g.fillRect(xDash2I, yi, dashW, dashLen);
      }

      const t = new THREE.CanvasTexture(c);
      t.colorSpace = THREE.SRGBColorSpace;
      t.wrapS = t.wrapT = THREE.RepeatWrapping;
      t.repeat.set(1.0, 10.0);
      return t;
    }

    function makePatchTexture(size=512){
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const g = c.getContext('2d');
      g.clearRect(0,0,size,size);

      const px = (worldX)=> ((worldX - leftEdge) / totalRoadWidth) * size;
      const centerLaneX = lanesX[1];
      const bandHalfW = laneW * 0.36;
      const xMin = Math.max(0, Math.floor(px(centerLaneX - bandHalfW)));
      const xMax = Math.min(size-1, Math.ceil(px(centerLaneX + bandHalfW)));

      for(let i=0;i<7000;i++){
        const x = xMin + Math.random()*(xMax-xMin);
        const y = Math.random()*size;
        const a = 0.02 + Math.random()*0.05;
        g.fillStyle = `rgba(0,0,0,${a})`;
        g.fillRect(x,y,1,1);
      }

      const stripCount = 8 + Math.floor(Math.random()*7);
      for(let i=0;i<stripCount;i++){
        const x = xMin + Math.random()*(xMax-xMin);
        const w = 14 + Math.random()*36;
        const a = 0.05 + Math.random()*0.12;

        const grad = g.createLinearGradient(x,0,x+w,0);
        grad.addColorStop(0, `rgba(0,0,0,0)`);
        grad.addColorStop(0.5, `rgba(0,0,0,${a})`);
        grad.addColorStop(1, `rgba(0,0,0,0)`);

        g.fillStyle = grad;
        g.fillRect(x, 0, w, size);
      }

      const patchCount = 6 + Math.floor(Math.random()*9);
      for(let i=0;i<patchCount;i++){
        const x = xMin + Math.random()*(xMax-xMin);
        const y = Math.random()*size;
        const w = 60 + Math.random()*170;
        const h = 8 + Math.random()*22;
        const a = 0.05 + Math.random()*0.12;
        g.fillStyle = `rgba(0,0,0,${a})`;
        g.fillRect(x,y,w,h);
      }

      const t = new THREE.CanvasTexture(c);
      t.colorSpace = THREE.SRGBColorSpace;
      t.wrapS = t.wrapT = THREE.RepeatWrapping;
      t.repeat.set(1.0, 10.0);
      return t;
    }

    const highwayTex = makeHighwayTexture(IS_IOS ? 768 : 1024);
    highwayTex.generateMipmaps = false;
    highwayTex.minFilter = THREE.NearestFilter;
    highwayTex.magFilter = THREE.NearestFilter;
    highwayTex.anisotropy = renderer.capabilities.getMaxAnisotropy();
    highwayTex.needsUpdate = true;
    highwayTex.repeat.set(1.0, 4.0);

    const patchTexPool = [
      makePatchTexture(IS_IOS ? 384 : 512),
      makePatchTexture(IS_IOS ? 384 : 512),
      makePatchTexture(IS_IOS ? 384 : 512),
    ];

    const roadMat = new THREE.MeshStandardMaterial({
      map: highwayTex,
      roughness: 0.96,
      metalness: 0.0,
      color: new THREE.Color(0xffffff)
    });

    const segments=[];
    let groupLeft = rndi(2,3);
    let groupShade = 0.94 + Math.random()*0.08;
    let groupPatch = patchTexPool[rndi(0, patchTexPool.length-1)];
    let groupPatchOpacity = 0.16 + Math.random()*0.10;

    for(let i=0;i<segCount;i++){
      const geo = new THREE.PlaneGeometry(totalRoadWidth, segLen);
      geo.rotateX(-Math.PI/2);
      const mesh = new THREE.Mesh(geo, roadMat);

      groupLeft--;
      if(groupLeft <= 0){
        groupLeft = rndi(2,3);
        groupShade = 0.94 + Math.random()*0.08;
        groupPatch = patchTexPool[rndi(0, patchTexPool.length-1)];
        groupPatchOpacity = 0.16 + Math.random()*0.10;
      }

      if(Math.abs(groupShade - 1.0) > 0.0001){
        const m = roadMat.clone();
        m.color = roadMat.color.clone().multiplyScalar(groupShade);
        mesh.material = m;
      }

      const patchGeo = new THREE.PlaneGeometry(totalRoadWidth, segLen);
      patchGeo.rotateX(-Math.PI/2);
      const patchMat = new THREE.MeshStandardMaterial({
        map: groupPatch,
        transparent: true,
        opacity: groupPatchOpacity,
        roughness: 1.0,
        metalness: 0.0,
        depthWrite: false,
        polygonOffset: true,
        polygonOffsetFactor: -1,
        polygonOffsetUnits: -1,
      });
      const patch = new THREE.Mesh(patchGeo, patchMat);
      patch.position.y = 0.003;
      mesh.add(patch);

      mesh.position.set(0, 0, -i*segLen);
      mesh.receiveShadow=true;

      scene.add(mesh);
      segments.push(mesh);
    }

    // terreno laterale
    const sideGeo = new THREE.PlaneGeometry(44, segLen*segCount);
    sideGeo.rotateX(-Math.PI/2);
    const sideMat = new THREE.MeshStandardMaterial({ color:0x0d2416, roughness:1, metalness:0 });
    const side = new THREE.Mesh(sideGeo, sideMat);
    side.position.set(0, -0.02, -segLen*segCount/2 + segLen/2);
    side.receiveShadow = true;
    scene.add(side);

    // alberi
    const jungle = new THREE.Group(); scene.add(jungle);
    function makeTree(){
      const g = new THREE.Group();
      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.11, 0.16, 1.6, 10),
        new THREE.MeshStandardMaterial({ color:0x4a3523, roughness:1, metalness:0 })
      );
      trunk.position.y=0.8; trunk.castShadow=true; trunk.receiveShadow=true; g.add(trunk);
      const crown = new THREE.Mesh(
        new THREE.ConeGeometry(0.75, 1.6, 12),
        new THREE.MeshStandardMaterial({ color:0x1c6b33, roughness:1, metalness:0 })
      );
      crown.position.y=1.9; crown.castShadow=true; crown.receiveShadow=true; g.add(crown);
      const crown2 = new THREE.Mesh(
        new THREE.ConeGeometry(0.6, 1.3, 12),
        new THREE.MeshStandardMaterial({ color:0x135226, roughness:1, metalness:0 })
      );
      crown2.position.y=2.3; crown2.castShadow=true; crown2.receiveShadow=true; g.add(crown2);
      return g;
    }
    const treeProto = makeTree();
    const treePool=[];
    const treeSpacing=2.8;
    const treeSideX = (totalRoadWidth/2) + 1.9;
    const jungleCount = Math.floor((segLen*segCount)/treeSpacing);
    for(let i=0;i<jungleCount;i++){
      const z = -i*treeSpacing;
      for(const sideSign of [-1,1]){
        const t = treeProto.clone(true);
        t.position.set(sideSign*(treeSideX + rnd(0,1.8)), 0, z);
        t.scale.setScalar(rnd(0.8,1.2));
        t.rotation.y = rnd(0,Math.PI*2);
        t.traverse(o=>{ if(o.isMesh){o.castShadow=true;o.receiveShadow=true;}});
        jungle.add(t); treePool.push(t);
      }
    }
    function loopJungle(scroll){
      const wrapZ = segLen*segCount;
      for(const obj of treePool){
        obj.position.z += scroll;
        if(obj.position.z > 10) obj.position.z -= wrapZ;
      }
    }

    // ===== Sprites =====
    function makeEmojiSprite(emoji, size=256){
      const c=document.createElement('canvas'); c.width=c.height=size;
      const g=c.getContext('2d');
      g.clearRect(0,0,size,size);
      g.globalAlpha=0.18;
      g.fillStyle='#cfefff';
      g.beginPath(); g.arc(size/2,size/2,size*0.33,0,Math.PI*2); g.fill();
      g.globalAlpha=1;
      g.font=`${size*0.55}px system-ui, Apple Color Emoji, Segoe UI Emoji`;
      g.textAlign='center'; g.textBaseline='middle';
      g.fillText(emoji, size/2, size/2+8);
      const tex=new THREE.CanvasTexture(c);
      tex.colorSpace=THREE.SRGBColorSpace;
      const mat=new THREE.SpriteMaterial({ map:tex, transparent:true });
      const spr=new THREE.Sprite(mat);
      spr.scale.set(0.78,0.78,1);
      return spr;
    }

    // ===== Entities visuals =====
    function spawnObstacleVisual(){
      const box = new THREE.Mesh(
        new THREE.BoxGeometry(rnd(0.65,0.95), rnd(0.75,1.25), rnd(0.65,0.95)),
        new THREE.MeshStandardMaterial({ color:0x6b4b2b, roughness:0.9, metalness:0.02 })
      );
      box.castShadow=true; box.receiveShadow=true;
      return box;
    }
    function makeTurtle(){
      const g = new THREE.Group();
      const shell = new THREE.Mesh(
        new THREE.SphereGeometry(0.35, 18, 14),
        new THREE.MeshStandardMaterial({ color:0x1f6a3a, roughness:0.9, metalness:0.02 })
      );
      shell.scale.set(1.2,0.75,1.0);
      shell.position.y=0.35;
      shell.castShadow=true; shell.receiveShadow=true;
      g.add(shell);
      const head = new THREE.Mesh(
        new THREE.SphereGeometry(0.16, 16, 12),
        new THREE.MeshStandardMaterial({ color:0x2f8a4d, roughness:0.9, metalness:0.02 })
      );
      head.position.set(0,0.25,0.42);
      head.castShadow=true;
      g.add(head);
      return g;
    }
    function makeVerticalRing(){
      const ring = new THREE.Mesh(
        new THREE.TorusGeometry(0.55, 0.09, 14, 44),
        new THREE.MeshStandardMaterial({
          color:0xff4444,
          roughness:0.35,
          metalness:0.05,
          emissive:0x660000,
          emissiveIntensity:0.55
        })
      );
      ring.castShadow=true; ring.receiveShadow=true;
      return ring;
    }

    // ===== Runner =====
    const runnerPivot = new THREE.Group(); scene.add(runnerPivot);
    const runnerCenter = new THREE.Group(); runnerCenter.position.set(0, 0.95, 0); runnerPivot.add(runnerCenter);
    const runnerModel = new THREE.Group(); runnerModel.position.set(0, -0.95, 0); runnerCenter.add(runnerModel);

    // Bubble
    const bubble = new THREE.Mesh(
      new THREE.SphereGeometry(0.62, 24, 18),
      new THREE.MeshStandardMaterial({
        color:0x66ffcc, roughness:0.25, metalness:0.0,
        emissive:0x33ffaa, emissiveIntensity:0.7,
        transparent:true, opacity:0.22
      })
    );
    bubble.position.set(0, 0.95, 0);
    bubble.visible=false;
    runnerPivot.add(bubble);

    // fallback dummy (se GLB manca)
    const fallbackRunner = new THREE.Group();
    const dummyBody = new THREE.Mesh(
      new THREE.CapsuleGeometry(0.22, 0.55, 8, 16),
      new THREE.MeshStandardMaterial({ color:0x9db79a, roughness:0.65, metalness:0.0 })
    );
    dummyBody.position.y=0.85; dummyBody.castShadow=true; fallbackRunner.add(dummyBody);
    const dummyHead = new THREE.Mesh(
      new THREE.SphereGeometry(0.18, 18, 14),
      new THREE.MeshStandardMaterial({ color:0xb7ccb2, roughness:0.6, metalness:0.0 })
    );
    dummyHead.position.set(0, 1.25, 0.05); dummyHead.castShadow=true; fallbackRunner.add(dummyHead);

    // ===== GLB loader + Animations =====
    const gltfLoader = new GLTFLoader();

    const RUNNER_GLB_URL = './running.glb';
    const ANIM_FILES = {
      idle: ['./DwarfIdle.glb', './WarriorIdle.glb', './HappyIdle.glb'],
      jump: './JumpOver.glb',
      flip: './RunningForwardFlip.glb',
      kick: './SoccerKick.glb',
      die:  './SideHitDie.glb',
      dance:'./HipHopDance.glb'
    };

    function setShadows(root){
      root.traverse(o=>{ if(o.isMesh){ o.castShadow=true; o.receiveShadow=true; } });
    }
    function removeBigNonSkinnedPlanes(model){
      model.traverse(o=>{
        if(!o.isMesh) return;
        const isSkinned = (o.isSkinnedMesh === true) || (o.skeleton != null);
        if(isSkinned) return;

        const box = new THREE.Box3().setFromObject(o);
        const s = new THREE.Vector3(); box.getSize(s);

        const huge = (s.x > 2.4 || s.y > 2.4 || s.z > 2.4);
        const flat = (Math.min(s.x,s.y,s.z) < 0.03 && Math.max(s.x,s.y,s.z) > 1.6);

        const name = (o.name||'').toLowerCase();
        const suspicious = name.includes('plane') || name.includes('cube') || name.includes('quad') || name.includes('ground') || name.includes('floor');

        if(huge || flat || suspicious) o.visible = false;
      });
    }
    function stripRootMotion(clip){
      const c = clip.clone();
      const TH = 0.02;
      try{
        for(const t of c.tracks){
          const name = (t.name || '').toLowerCase();
          if(!name.endsWith('.position')) continue;
          const v = t.values;
          if(!v || v.length < 6) continue;

          let minX=Infinity, maxX=-Infinity, minZ=Infinity, maxZ=-Infinity;
          for(let i=0;i<v.length;i+=3){
            const x=v[i], z=v[i+2];
            if(x<minX) minX=x; if(x>maxX) maxX=x;
            if(z<minZ) minZ=z; if(z>maxZ) maxZ=z;
          }
          const rangeX=maxX-minX, rangeZ=maxZ-minZ;
          if(rangeX>TH || rangeZ>TH){
            const baseX=v[0], baseZ=v[2];
            for(let i=0;i<v.length;i+=3){
              v[i]=baseX;
              v[i+2]=baseZ;
            }
          }
        }
      }catch(err){ console.warn('stripRootMotion fallback:', err); }
      return c;
    }

    let runnerMixer=null;
    let actions = { run:null, idles:[], jump:null, flip:null, kick:null, die:null, dance:null };
    let mixamoHips=null, mixamoRootNode=null, headBone=null;
    let hipsBaseX=0, hipsBaseZ=0, rootBaseX=0, rootBaseZ=0;

    // FPS: testa/maschera INVISIBILE ma con OMBRE corrette (shadow-only)
    let fpsHiddenMeshes = [];

    function setFpsMaskHidden(on){
      if(viewMode==='fps') bubble.visible = false;

      // ripristina tutto
      for(const it of fpsHiddenMeshes){
        const m = it.mesh;
        try{
          m.visible = it.visible;
          m.castShadow = it.castShadow;
          if(m.material){
            const mats = Array.isArray(m.material) ? m.material : [m.material];
            const saved = it.materialStates || [];
            for(let i=0;i<mats.length;i++){
              const mat = mats[i];
              const st  = saved[i];
              if(!mat || !st) continue;
              mat.transparent = st.transparent;
              mat.opacity     = st.opacity;
              mat.colorWrite  = st.colorWrite;
              mat.depthWrite  = st.depthWrite;
              mat.depthTest   = st.depthTest;
              mat.needsUpdate = true;
            }
          }
        }catch{}
      }
      fpsHiddenMeshes = [];
      if(!on) return;

      // nasconde solo head/face/hair/helmet/mask ecc‚Ä¶ ma mantiene le ombre
      runnerModel.traverse(o=>{
        if(!o.isMesh) return;

        const n = (o.name||'').toLowerCase();
        const hit =
          n.includes('head') || n.includes('face') || n.includes('hair') ||
          n.includes('helmet') || n.includes('hat') || n.includes('mask') ||
          n.includes('cap') || n.includes('hood') || n.includes('visor');

        if(!hit) return;

        const mats = o.material ? (Array.isArray(o.material) ? o.material : [o.material]) : [];
        const materialStates = mats.map(mat => mat ? ({
          transparent: mat.transparent,
          opacity: mat.opacity,
          colorWrite: mat.colorWrite,
          depthWrite: mat.depthWrite,
          depthTest: mat.depthTest
        }) : null);

        fpsHiddenMeshes.push({
          mesh: o,
          visible: o.visible,
          castShadow: o.castShadow,
          materialStates
        });

        // shadow-only: invisibile ma continua a fare ombre
        o.visible = true;
        o.castShadow = true;

        for(const mat of mats){
          if(!mat) continue;
          mat.transparent = true;
          mat.opacity = 0.0;
          mat.colorWrite = false;
          mat.depthWrite = false;
          mat.depthTest  = true;
          mat.needsUpdate = true;
        }
      });
    }

    const animState = { mode:'idle' };
    let deadSnapPending = false;

    function collectAllActions(){
      const all=[];
      if(actions.run) all.push(actions.run);
      if(actions.jump) all.push(actions.jump);
      if(actions.flip) all.push(actions.flip);
      if(actions.kick) all.push(actions.kick);
      if(actions.die)  all.push(actions.die);
      if(actions.dance)all.push(actions.dance);
      for(const a of actions.idles) all.push(a);
      return all;
    }
    function fadeTo(next, fade=0.18){
      if(!next) return;
      const all = collectAllActions();
      for(const a of all){
        if(a && a !== next){ try{ a.fadeOut(fade); }catch{} }
      }
      try{
        next.reset();
        next.enabled = true;
        next.setEffectiveWeight(1.0);
        next.fadeIn(fade);
        next.play();
      }catch{}
    }
    function playRun(){
      if(!actions.run || animState.mode==='dead') return;
      animState.mode='run';
      actions.run.setLoop(THREE.LoopRepeat, Infinity);
      actions.run.clampWhenFinished = false;
      fadeTo(actions.run, 0.12);
    }
    function pickRandomIdle(){
      if(!actions.idles.length || animState.mode==='dead') return;
      const a = actions.idles[rndi(0, actions.idles.length-1)];
      a.setLoop(THREE.LoopOnce, 1);
      a.clampWhenFinished = true;
      a.time = 0;
      animState.mode='idle';
      fadeTo(a, 0.20);
    }
    function startIdleRandom(){
      if(animState.mode==='dead') return;
      pickRandomIdle();
    }
    function playOneShot(action, fade=0.08){
      if(!action || animState.mode==='dead') return;
      animState.mode='oneShot';
      action.reset();
      action.setLoop(THREE.LoopOnce, 1);
      action.clampWhenFinished = true;
      action.enabled = true;
      action.setEffectiveWeight(1.0);
      fadeTo(action, fade);
    }
    function playDance(){
      if(!actions.dance || animState.mode==='dead') return;
      animState.mode='dance';
      actions.dance.setLoop(THREE.LoopRepeat, Infinity);
      actions.dance.clampWhenFinished = false;
      fadeTo(actions.dance, 0.18);
    }

    function snapRunnerToGround(){
      try{
        const root = runnerModel.children[0];
        if(!root) return;
        const box = new THREE.Box3().setFromObject(root);
        const dy = -box.min.y;
        if(Number.isFinite(dy) && Math.abs(dy) > 0.0001){
          root.position.y += dy;
        }
      }catch{}
    }

    function playDie(){
      if(!actions.die) return;
      animState.mode='dead';
      deadSnapPending = true;
      actions.die.reset();
      actions.die.setLoop(THREE.LoopOnce, 1);
      actions.die.clampWhenFinished = true;
      fadeTo(actions.die, 0.08);
    }

    /* ‚úÖ FIX RESTART: reset totale delle animazioni (esce da "dead") */
    function resetAnimationsToIdle(){
      animState.mode = 'idle';
      deadSnapPending = false;
      const all = collectAllActions();
      for(const a of all){
        if(!a) continue;
        try{
          a.stop();
          a.reset();
          a.enabled = true;
          a.setEffectiveWeight(0);
          a.clampWhenFinished = false;
        }catch{}
      }
      startIdleRandom();
      setFpsMaskHidden(viewMode==='fps');
    }

    async function loadAnimClip(url){
      return new Promise((resolve)=>{
        gltfLoader.load(url, (gltf)=>{
          const clips = (gltf.animations||[]).filter(c=>c && c.tracks && c.tracks.length);
          resolve(clips[0] || null);
        }, undefined, ()=>{
          console.warn('Anim load error:', url);
          resolve(null);
        });
      });
    }
    async function loadAllAnimations(){
      for(const u of ANIM_FILES.idle){
        const c = await loadAnimClip(u);
        if(c) actions.idles.push(c);
      }
      actions.jump  = await loadAnimClip(ANIM_FILES.jump);
      actions.flip  = await loadAnimClip(ANIM_FILES.flip);
      actions.kick  = await loadAnimClip(ANIM_FILES.kick);
      actions.die   = await loadAnimClip(ANIM_FILES.die);
      actions.dance = await loadAnimClip(ANIM_FILES.dance);
    }

    async function loadRunnerModel(){
      return new Promise((resolve)=>{
        gltfLoader.load(RUNNER_GLB_URL, async (gltf)=>{
          const model = gltf.scene;

          model.position.set(0,0,0);
          model.scale.setScalar(0.95);
          setShadows(model);

          model.traverse(o=>{
            if(o.isMesh && o.material){
              const mats = Array.isArray(o.material) ? o.material : [o.material];
              for(const m of mats){ if(m) m.side = THREE.DoubleSide; }
            }
          });

          removeBigNonSkinnedPlanes(model);

          {
            const box = new THREE.Box3().setFromObject(model);
            const lift = -box.min.y;
            model.position.y += lift + 0.01;
          }

          model.rotation.y = Math.PI;

          mixamoHips = null; mixamoRootNode = null; headBone = null;
          model.traverse(o=>{
            const n = (o.name||'').toLowerCase();
            if(!mixamoRootNode && (n.includes('armature') || n === 'root')) mixamoRootNode = o;
            if(o.isBone){
              if(!mixamoHips && (n==='hips' || (n.includes('mixamorig') && n.includes('hips')))) mixamoHips = o;
              if(!headBone && (n==='head' || (n.includes('mixamorig') && n.includes('head')))) headBone = o;
            }
          });
          if(mixamoHips){ hipsBaseX = mixamoHips.position.x; hipsBaseZ = mixamoHips.position.z; }
          if(mixamoRootNode){ rootBaseX = mixamoRootNode.position.x; rootBaseZ = mixamoRootNode.position.z; }

          while(runnerModel.children.length) runnerModel.remove(runnerModel.children[0]);
          runnerModel.add(model);

          runnerMixer = new THREE.AnimationMixer(model);

          await loadAllAnimations();

          const baseClips = (gltf.animations||[]).filter(c=>c && c.tracks && c.tracks.length);
          const runClip = baseClips.find(c => (c.name||'').toLowerCase().includes('run')) || baseClips[0];
          const fixedRun = runClip ? stripRootMotion(runClip) : null;
          if(fixedRun){
            actions.run = runnerMixer.clipAction(fixedRun);
            actions.run.enabled = true;
            actions.run.setEffectiveWeight(1.0);
            actions.run.setEffectiveTimeScale(1.0);
          }

          const idleActions = [];
          for(const clip of actions.idles) idleActions.push(runnerMixer.clipAction(clip));
          actions.idles = idleActions;

          if(actions.jump)  actions.jump  = runnerMixer.clipAction(actions.jump);
          if(actions.flip)  actions.flip  = runnerMixer.clipAction(actions.flip);
          if(actions.kick)  actions.kick  = runnerMixer.clipAction(actions.kick);
          if(actions.die)   actions.die   = runnerMixer.clipAction(actions.die);
          if(actions.dance) actions.dance = runnerMixer.clipAction(actions.dance);

          runnerMixer.addEventListener('finished', ()=>{
            if(animState.mode==='dead'){
              if(deadSnapPending){
                deadSnapPending = false;
                snapRunnerToGround();
              }
              return;
            }
            if(animState.mode==='oneShot'){
              if(game.started && !game.stopped && !game.paused && !game.over) playRun();
              else startIdleRandom();
              return;
            }
            if(animState.mode==='idle'){
              pickRandomIdle();
              return;
            }
          });

          startIdleRandom();
          resolve();
        }, undefined, ()=>{
          while(runnerModel.children.length) runnerModel.remove(runnerModel.children[0]);
          runnerModel.add(fallbackRunner);
          resolve();
        });
      });
    }

    // ===== Game data =====
    const EMOJIS = ["‚ú®","üçÄ","üíé","‚ö°Ô∏è","üåà","üçã","‚≠êÔ∏è","üçì","ü•ù"];
    const FOOD   = ["üçï","üçî","üçü","üåÆ","üç©","üç™","üç∞","üçú","üç£","ü•ê"];
    const HEART  = "‚ù§Ô∏è";
    const MAGNET = "üß≤";

    const BEST_KEY='jungle_runner_best_v4';
    const loadBest=()=>Number(localStorage.getItem(BEST_KEY)||'0')||0;
    const saveBest=(v)=>localStorage.setItem(BEST_KEY,String(v));

    const game = {
      lane:1,
      y:0, vy:0, jumping:false,
      sliding:false, slideT:0,
      autoSlideCooldown:0,

      baseSpeed: 12.9,
      score:0,
      coins:0,
      best: loadBest(),

      maxLives:5,
      lives:3,

      ringCount:0,
      foodCount:0,
      foodHistory:[],

      invincibleT:0,
      foodBoostT:0,
      ringBoostT:0,
      magnetT:0,
      trioT:0,

      entities:[],
      spawnT:0.30,

      paused:false,
      started:false,
      over:false,

      stopped:true,
      stopBlend:1.0,

      lastTurtleZ: [-99999, -99999, -99999],

      /* ‚úÖ info per camera FPS ‚Äúrealistica‚Äù */
      camSpeed: 0,
      grounded: true,
      vyNow: 0
    };

    if(bestEl) bestEl.textContent = String(game.best);

    function hpString(){
      let s="";
      for(let i=0;i<game.maxLives;i++) s += (i<game.lives) ? "‚ù§Ô∏è" : "üñ§";
      return s;
    }

    function refreshFoodUI(){
      if(!foodStack || !foodCountEl) return;
      foodStack.innerHTML = "";
      const show = game.foodHistory.slice(-6).reverse();
      for(const emo of show){
        const d=document.createElement('div');
        d.className = 'foodItem pillFx';
        d.textContent=emo;
        foodStack.appendChild(d);
      }
      foodCountEl.textContent = String(game.foodCount);
    }

    function setBoostUI(){
      if(!pillBoost || !boostBar || !boostIcon || !boostName) return;

      const t = Math.max(game.foodBoostT, game.ringBoostT);
      if(t <= 0){
        pillBoost.style.display='none';
        boostBar.style.width='0%';
        return;
      }
      pillBoost.style.display='flex';

      const both = (game.foodBoostT>0 && game.ringBoostT>0);
      if(both){ boostIcon.textContent='üî•'; boostName.textContent='MEGA'; }
      else if(game.foodBoostT>0){ boostIcon.textContent='üçî'; boostName.textContent='FOOD'; }
      else { boostIcon.textContent='‚≠ïÔ∏è'; boostName.textContent='RING'; }

      const dur = 10.0;
      const pct = clamp((t/dur)*100,0,100);
      boostBar.style.width = pct.toFixed(1)+'%';
    }

    function updateMainButton(){
      if(!mainLbl) return;

      if(game.over){
        mainLbl.textContent = 'RESTART';
        return;
      }
      if(!game.started){
        mainLbl.textContent = 'AVVIA';
        return;
      }
      if(game.stopped){
        mainLbl.textContent = 'AVVIA';
        return;
      }
      mainLbl.textContent = 'STOP';
    }

    function obstacleMultiplier(){
      const steps = Math.floor(game.score / 5000);
      return 1 + 0.05 * steps;
    }

    // ===== Spawn =====
    const TURTLE_VIS_Z = 70;
    const TURTLE_MIN_GAP = TURTLE_VIS_Z * 3.0;

    function canSpawnTurtle(lane, z){
      return Math.abs(z - game.lastTurtleZ[lane]) >= TURTLE_MIN_GAP;
    }

    function spawnRow(){
      const z0 = -60 - rnd(0,18);

      const blocked=new Set();
      const mult = obstacleMultiplier();

      const p0 = clamp(0.22 / mult, 0.03, 0.22);
      let oCount = 0;
      if(Math.random() >= p0){
        const p2 = clamp(0.38 * mult, 0.18, 0.95);
        oCount = (Math.random() < p2) ? 2 : 1;
      }
      while(blocked.size<oCount) blocked.add(rndi(0,2));

      const coinLanes=new Set();
      const cCount = rndi(1,2);
      while(coinLanes.size<cCount) coinLanes.add(rndi(0,2));

      blocked.forEach(l=>{
        const obj = spawnObstacleVisual();
        obj.position.set(lanesX[l], 0.65, z0);
        scene.add(obj);
        game.entities.push({ type:'obst', lane:l, z:z0, obj });
      });

      coinLanes.forEach(l=>{
        const spr = makeEmojiSprite(EMOJIS[rndi(0,EMOJIS.length-1)]);
        spr.position.set(lanesX[l], 1.10, z0 - rnd(0,2.8));
        scene.add(spr);
        game.entities.push({ type:'coin', lane:l, z:spr.position.z, obj:spr });
      });

      if(Math.random() < 0.30){
        const lane=rndi(0,2);
        const emo = FOOD[rndi(0,FOOD.length-1)];
        const spr = makeEmojiSprite(emo);
        spr.position.set(lanesX[lane], 1.15, z0 - rnd(1,6));
        spr.scale.set(0.82,0.82,1);
        scene.add(spr);
        game.entities.push({ type:'food', lane, z:spr.position.z, obj:spr, emo });
      }

      if(Math.random() < 0.10){
        const lane=rndi(0,2);
        const spr = makeEmojiSprite(MAGNET);
        spr.position.set(lanesX[lane], 1.15, z0 - rnd(1,7));
        spr.scale.set(0.90,0.90,1);
        scene.add(spr);
        game.entities.push({ type:'magnet', lane, z:spr.position.z, obj:spr });
      }

      if(game.lives < game.maxLives){
        let spawnHeart = false;
        if(game.coins>0 && game.coins % 30 === 0 && Math.random() < 0.45) spawnHeart = true;
        if(!spawnHeart && Math.random() < 0.03) spawnHeart = true;
        if(spawnHeart){
          const lane=rndi(0,2);
          const spr = makeEmojiSprite(HEART);
          spr.position.set(lanesX[lane], 1.15, z0 - rnd(1,6));
          spr.scale.set(0.92,0.92,1);
          scene.add(spr);
          game.entities.push({ type:'heart', lane, z:spr.position.z, obj:spr });
        }
      }

      if(Math.random() < 0.18){
        const lane=rndi(0,2);
        const tz = z0 - rnd(3,11);
        if(canSpawnTurtle(lane, tz)){
          const t = makeTurtle();
          t.position.set(lanesX[lane], 0, tz);
          t.traverse(o=>{ if(o.isMesh){ o.castShadow=true; o.receiveShadow=true; }});
          scene.add(t);
          game.entities.push({ type:'turtle', lane, z:tz, obj:t });
          game.lastTurtleZ[lane] = tz;
        }
      }

      if(Math.random() < 0.26){
        const lane = rndi(0,2);
        const baseZ = z0 - rnd(2,9);
        const gap = 0.82;
        for(let k=0;k<2;k++){
          const ring = makeVerticalRing();
          ring.position.set(lanesX[lane], 0.55, baseZ - k*gap);
          scene.add(ring);
          game.entities.push({ type:'ring', lane, z:ring.position.z, obj:ring });
        }
      }
    }

    // ===== Controls =====
    let tiltTarget=0, camRoll=0;

    function moveLane(dir){
      if(game.over||game.paused) return;
      if(!game.started) return;
      if(game.stopped) return;
      if(game.trioT>0) return;
      game.lane = clamp(game.lane+dir, 0, 3);
tiltTarget = clamp(tiltTarget + dir*0.18, -0.22, 0.22);

// micro kick (usato dalla camera FPS, "inerzia")
fpsLaneKick = clamp(fpsLaneKick + dir * 0.55, -1.2, 1.2);

sfx.lane();
    }

    function jump(){
      if(game.over||game.paused) return;
      if(!game.started) return;
      if(game.stopped) return;
      if(!game.jumping && game.y>=-0.001){
        game.jumping=true;
        game.vy = -7.8;
        sfx.jump();
      }
    }

    function slide(){
      if(game.over||game.paused) return;
      if(!game.started) return;
      if(game.stopped) return;
      game.sliding=true;
      game.slideT=0.55;
      sfx.slide();
    }

    window.addEventListener('keydown', (e)=>{
      const k=e.key.toLowerCase();
      if(k==='arrowleft') moveLane(-1);
      if(k==='arrowright') moveLane(1);
      if(k==='arrowup' || k===' ') jump();
      if(k==='arrowdown') slide();
      if(k==='p') togglePause();
    });

    let touchStart=null;
    renderer.domElement.addEventListener('pointerdown',(e)=>{
      initAudio();
      renderer.domElement.setPointerCapture(e.pointerId);
      touchStart={x:e.clientX,y:e.clientY,t:performance.now()};
    });
    renderer.domElement.addEventListener('pointerup',(e)=>{
      if(!touchStart) return;
      const dx=e.clientX-touchStart.x, dy=e.clientY-touchStart.y;
      const adx=Math.abs(dx), ady=Math.abs(dy);
      touchStart=null;
      const min=30;
      if(adx<min && ady<min) return;
      if(adx>ady) moveLane(dx>0?1:-1);
      else { if(dy<0) jump(); else slide(); }
    });

    // ===== View mode handling =====
    function applyViewMode(mode){
      if(!['front','back','fps'].includes(mode)) mode = 'front';
      viewMode = mode;
      saveCam();
      setActiveCamBtns();

      camera.up.set(0,1,0);

      // camera near in FPS per evitare clipping
      if(viewMode==='fps'){
        camera.near = 0.02;
      }else{
        camera.near = 0.1;
      }
      camera.updateProjectionMatrix();

      setFpsMaskHidden(viewMode==='fps');
    }

    safeOn(btnCamBack,'click', ()=>{ initAudio(); applyViewMode('back'); });
    safeOn(btnCamFront,'click',()=>{ initAudio(); applyViewMode('front'); });
    safeOn(btnCamFPS,'click',  ()=>{ initAudio(); applyViewMode('fps'); });

    safeOn(fpsToggle,'click', ()=>{
      initAudio();
      applyViewMode(viewMode==='fps' ? 'front' : 'fps');
      syncCamUI();
    });

    // Debug toggle
    safeOn(btnDebug,'click', ()=>{
      debugOn = !debugOn;
      saveCam();
      setDebugUI();
    });

    // ===== Start/Stop/Pause/Home/Dance =====
    function setStop(on){
      game.stopped = !!on;
      if(game.stopped){
        startIdleRandom();
      }else{
        if(game.started && !game.paused && !game.over) playRun();
      }
      updateMainButton();
    }

    function resetRun(){
      game.lane=1;
      runnerX = lanesX[1];
      game.y=0; game.vy=0; game.jumping=false;
      game.sliding=false; game.slideT=0.55*0;
      game.autoSlideCooldown=0;

      game.score=0; game.coins=0;
      game.ringCount=0;
      game.foodCount=0; game.foodHistory=[];
      refreshFoodUI();

      game.invincibleT=0;
      game.foodBoostT=0;
      game.ringBoostT=0;
      game.magnetT=0;
      game.trioT=0;

      bubble.visible=false;

      for(const e of game.entities) scene.remove(e.obj);
      game.entities.length=0;

      game.spawnT = 0.30;
      game.over=false;
      game.lives=3;

      game.lastTurtleZ = [-99999, -99999, -99999];

      game.started = false;
      game.paused = false;
      setStop(true);

      resetAnimationsToIdle();

      if(scoreEl) scoreEl.textContent = '0';
      if(coinsEl) coinsEl.textContent = '0';
      if(ringsEl) ringsEl.textContent = '0';
      if(hpTxt) hpTxt.textContent = hpString();
      if(magTxt) magTxt.textContent = 'üß≤ 0';
      setBoostUI();

      updateMainButton();
      startIdleRandom();
    }

    function startGame(){
      game.started = true;
      game.paused = false;
      setStop(false);
      playRun();
      updateMainButton();
    }

    function togglePause(){
      if(game.over) return;
      if(!game.started) return;

      game.paused = !game.paused;

      if(game.paused){
        startIdleRandom();
      }else{
        if(game.started && !game.stopped) playRun();
        else startIdleRandom();
      }
    }

    safeOn(btnMain,'click', ()=>{
      initAudio();

      if(game.over){
        resetRun();
        startGame();
        return;
      }
      if(!game.started){
        startGame();
        return;
      }
      if(game.paused) return;
      setStop(!game.stopped);
    });

    safeOn(btnDance,'click', ()=>{
      initAudio();
      if(game.over) return;
      if(game.started && !game.paused && !game.stopped) setStop(true);
      playDance();
    });

    safeOn(btnHome,'click', ()=>{
      initAudio();
      resetRun();
    });

    // ===== Life / pickups =====
    function loseLife(){
      if(game.invincibleT>0) return;
      game.lives = Math.max(0, game.lives-1);
      sfx.hit();
      if(game.lives<=0){
        game.over=true;
        game.started=false;
        game.paused=false;
        setStop(true);
        playDie();
        updateMainButton();
      }
    }
    function addLife(){
      game.lives = Math.min(game.maxLives, game.lives+1);
      sfx.boost();
    }

    // ===== Update loop =====
    let camZ = baseCamZ, camY = baseCamY, camFov = baseFov, camX = 0;
    let tPrev=performance.now();
    // ‚úÖ Lane smoothing (posizione X del runner ‚Äúmorbida‚Äù)
    let runnerX = lanesX[game.lane];

    // debug fps
    let fpsAcc=0, fpsN=0, fpsShow=0;
    let dbgTimer=0;

    // ‚úÖ FPS camera state (bob + sway ‚Äúreale‚Äù + spring)
    let fpsPhase = 0;
    let fpsX = 0, fpsY = 0;
    let fpsXPrev = 0;
    let fpsLandKick = 0;      // piccolo ‚Äúkick‚Äù atterraggio
    let fpsVyPrev = 0;
    let fpsGroundPrev = true;
    let fpsVelYSm = 0;
    let fpsLaneKick = 0;

    function update(dt, tNow){
      if(runnerMixer){
        runnerMixer.timeScale = 1.0;
        runnerMixer.update(dt);

        if(mixamoHips){ mixamoHips.position.x = hipsBaseX; mixamoHips.position.z = hipsBaseZ; }
        if(mixamoRootNode){ mixamoRootNode.position.x = rootBaseX; mixamoRootNode.position.z = rootBaseZ; }
      }

      const gameplayOn = game.started && !game.paused && !game.over;
      const stopTarget = game.stopped ? 1.0 : 0.0;
      game.stopBlend = damp(game.stopBlend, stopTarget, 8, dt);

      if(!gameplayOn){
        runnerPivot.position.x = lanesX[1];
        runnerPivot.position.y = 0;

        contact.position.x = runnerPivot.position.x;
        contact.scale.set(1.10, 1.10, 1);
        contact.material.opacity = 0.55;

        const breathe = Math.sin(tNow*0.0022) * 0.015;
        runnerCenter.position.y = 0.95 + breathe;
        runnerCenter.rotation.z = Math.sin(tNow*0.0016) * 0.015;

        // ‚úÖ per FPS idle/menu
        game.camSpeed = 0;
        game.grounded = true;
        game.vyNow = 0;

        return;
      }

      runnerCenter.position.y = 0.95;
      runnerCenter.rotation.z = 0;

      const trafficMul = (1.0 - game.stopBlend);
      if(game.stopped){
        // ‚úÖ STOP: niente gameplay, ma lasciamo info camera per ‚Äúbreathing sway‚Äù
        game.camSpeed = 0;
        game.grounded = true;
        game.vyNow = 0;
        return;
      }

      if(game.invincibleT>0){
        game.invincibleT = Math.max(0, game.invincibleT - dt*trafficMul);
        if(game.invincibleT<=0){
          bubble.visible=false;
        }
      }
      if(game.foodBoostT>0) game.foodBoostT = Math.max(0, game.foodBoostT - dt*trafficMul);
      if(game.ringBoostT>0) game.ringBoostT = Math.max(0, game.ringBoostT - dt*trafficMul);
      if(game.magnetT>0)    game.magnetT    = Math.max(0, game.magnetT    - dt*trafficMul);

      const anyBoost = (game.foodBoostT>0 || game.ringBoostT>0);
      if(anyBoost && game.invincibleT<0.05){
        game.invincibleT = Math.max(game.invincibleT, Math.max(game.foodBoostT, game.ringBoostT));
        bubble.visible=true;
      }

      const foodMul = (game.foodBoostT>0) ? 2.30 : 1.0;
      const ringMul = (game.ringBoostT>0) ? 3.00 : 1.0;
      const both = (game.foodBoostT>0 && game.ringBoostT>0);
      const crazyMul = both ? 1.03 : 1.0;

      const speedMul = foodMul * ringMul * crazyMul;
      const speed = game.baseSpeed * speedMul * trafficMul;

      // ‚úÖ info per camera FPS (step/bob)
      game.camSpeed = speed;
      game.grounded = (game.y === 0);
      game.vyNow = game.vy;

      const g=22.0;
      game.vy += g*dt;
      game.y  += game.vy*dt;
      if(game.y>0){ game.y=0; game.vy=0; game.jumping=false; }

      if(game.sliding){ game.slideT -= dt; if(game.slideT<=0) game.sliding=false; }

      // ‚úÖ Smooth lane follow
const laneTargetX = lanesX[ clamp(game.lane, 0, 3) ];
runnerX = damp(runnerX, laneTargetX, 14, dt);   // 14 = velocit√† ‚Äúnaturale‚Äù
runnerPivot.position.x = runnerX;

runnerPivot.position.y = (-game.y);

      const h = runnerPivot.position.y;
      const s = 1.10 + clamp(h*0.65, 0, 0.85);
      contact.position.x = runnerPivot.position.x;
      contact.scale.set(s,s,1);
      contact.material.opacity = clamp(0.55 - h*0.24, 0.10, 0.55);

      const scroll = speed*dt;
      highwayTex.offset.y -= scroll*0.085;
      for(const t of patchTexPool) t.offset.y -= scroll*0.085;

      for(const mesh of segments){
        mesh.position.z += scroll;
        if(mesh.position.z > segLen) mesh.position.z -= segLen*segCount;
      }
      loopJungle(scroll);

      game.spawnT -= dt;
      if(game.spawnT<=0){
        spawnRow();
        game.spawnT = rnd(0.40, 0.75);
      }

      const magnetOn = game.magnetT > 0;

      for(const e of game.entities){
        e.z += scroll;
        e.obj.position.z = e.z;

        if(magnetOn && (e.type==='coin'||e.type==='food'||e.type==='heart'||e.type==='magnet')){
          const dx = runnerPivot.position.x - e.obj.position.x;
          const dz = (0 - e.z);
          const dist = Math.hypot(dx*2.2, dz);
          if(dist < 12.0){
            e.obj.position.x += dx * dt * (5.6*(1-dist/12.0));
            if(e.obj.position.y < 1.1) e.obj.position.y += dt*0.6;
          }
        }
      }

      for(let i=game.entities.length-1;i>=0;i--){
        const e = game.entities[i];
        if(e.z > 6.0){
          scene.remove(e.obj);
          game.entities.splice(i,1);
        }
      }

      const px = runnerPivot.position.x;
      const py = runnerPivot.position.y + (game.sliding ? 0.70 : 0.95);

      function collide(e){
        const dz = Math.abs(e.z - 0.25);
        const dx = Math.abs(e.obj.position.x - px);
        const ey = (e.obj.position.y ?? 0);
        const dy = Math.abs(ey - py);
        return (dz < 0.75 && dx < 0.60 && dy < 1.05);
      }
      function collideTurtle(e){
        const dz = Math.abs(e.z - 0.35);
        const dx = Math.abs(e.obj.position.x - px);
        return (dz < 1.05 && dx < 0.72);
      }

      if(!game.sliding && game.y===0 && game.autoSlideCooldown<=0 && game.lane<=2){
        for(const e of game.entities){
          if(e.type!=='ring') continue;
          if(e.lane !== game.lane) continue;
          if(Math.abs(e.z - 0.25) < 2.55){
            game.sliding = true;
            game.slideT  = 0.48;
            game.autoSlideCooldown = 0.24;
            break;
          }
        }
      }
      game.autoSlideCooldown = Math.max(0, game.autoSlideCooldown - dt);

      for(let i=game.entities.length-1;i>=0;i--){
        const e=game.entities[i];

        if(e.type==='ring'){
          if(!collide(e)) continue;
          if(!game.sliding) continue;
          game.ringCount += 1;
          scene.remove(e.obj); game.entities.splice(i,1);
          sfx.ring();

          if(game.ringCount >= 50){
            game.ringBoostT = 10.0;
            game.invincibleT = Math.max(game.invincibleT, 10.0);
            bubble.visible = true;
            game.ringCount = 0;
            sfx.boost();
          }
          continue;
        }

        if(e.type==='turtle'){
          if(!collideTurtle(e)) continue;
          sfx.boost();
          scene.remove(e.obj); game.entities.splice(i,1);
          continue;
        }

        if(!collide(e)) continue;

        if(e.type==='coin'){
          game.coins += 1;
          game.score += 28;
          scene.remove(e.obj); game.entities.splice(i,1);
          sfx.coin();
          continue;
        }

        if(e.type==='food'){
          game.foodCount += 1;
          game.foodHistory.push(e.emo);
          refreshFoodUI();
          scene.remove(e.obj); game.entities.splice(i,1);
          sfx.food();

          if(game.foodCount >= 10){
            game.foodBoostT = 10.0;
            game.invincibleT = Math.max(game.invincibleT, 10.0);
            bubble.visible=true;
            game.foodCount = 0;
            game.foodHistory = [];
            refreshFoodUI();
            sfx.boost();
          }
          continue;
        }

        if(e.type==='heart'){
          if(game.lives < game.maxLives) addLife();
          scene.remove(e.obj); game.entities.splice(i,1);
          continue;
        }

        if(e.type==='magnet'){
          game.magnetT = 8.0;
          scene.remove(e.obj); game.entities.splice(i,1);
          sfx.magnet();
          continue;
        }

        if(e.type==='obst'){
          const inv = (game.invincibleT>0);
          scene.remove(e.obj); game.entities.splice(i,1);
          if(!inv) loseLife();
          continue;
        }
      }

      game.score += (18 * speedMul) * dt;

      if(game.score > game.best){
        game.best = Math.floor(game.score);
        saveBest(game.best);
      }

      if(scoreEl) scoreEl.textContent = String(Math.floor(game.score));
      if(coinsEl) coinsEl.textContent = String(game.coins);
      if(bestEl)  bestEl.textContent  = String(game.best);
      if(ringsEl) ringsEl.textContent = String(game.ringCount);
      if(hpTxt)   hpTxt.textContent   = hpString();
      if(magTxt)  magTxt.textContent  = `üß≤ ${game.magnetT>0 ? game.magnetT.toFixed(1) : '0'}`;
      setBoostUI();

      if(bubble.visible){
        bubble.material.opacity = 0.18 + 0.06*Math.sin(tNow*0.01);
      }

      tiltTarget *= 0.92;
      camRoll = damp(camRoll, tiltTarget, 10, dt);
    }
 

    function animate(tNow){
      const dt=Math.min(0.030,(tNow-tPrev)/1000);
      tPrev=tNow;

      // debug fps calc
      fpsAcc += dt; fpsN++;
      if(fpsAcc >= 0.5){
        fpsShow = fpsN / fpsAcc;
        fpsAcc = 0; fpsN = 0;
      }

      update(dt,tNow);

      const gameplayOn  = game.started && !game.paused && !game.over;
      const camDynamic  = gameplayOn && !game.stopped;

      const bothBoost = (game.foodBoostT > 0 && game.ringBoostT > 0);
      const anyBoost  = (game.foodBoostT > 0 || game.ringBoostT > 0);

      const fovBoost = bothBoost ? 7 : (anyBoost ? 5 : 0);
      const zBoost   = bothBoost ? 0.9 : (anyBoost ? 0.5 : 0.0);

      // ‚úÖ FOV dinamico SOLO in FPS se fpsDynFov=true
      const useFovBoost = (viewMode === 'fps') ? fpsDynFov : true;

      const targetFov = clamp(baseFov + (useFovBoost ? fovBoost : 0), 30, 110);
      const targetZ   = clamp(baseCamZ + zBoost, 2, 15);
      const targetY   = clamp(baseCamY + (bothBoost ? 0.10 : 0), 0.0, 12.0);

      if(!camDynamic){
        camFov  = baseFov;
        camZ    = baseCamZ;
        camY    = baseCamY;
        camX    = 0;
        camRoll = 0;
      } else {
        camFov = damp(camFov, targetFov, 8, dt);
        camZ   = damp(camZ,   targetZ,   8, dt);
        camY   = damp(camY,   targetY,   8, dt);

        const targetCamX = clamp(runnerPivot.position.x * 0.35, -1.2, 1.6);
        camX = damp(camX, targetCamX, 6, dt);
      }

      camera.fov = camFov;
      camera.updateProjectionMatrix();

      let shakeX = 0, shakeY = 0;
      if(camDynamic && anyBoost && shakeEnabled && viewMode!=='fps'){
        const intensity = bothBoost ? 0.018 : 0.011;
        shakeX = Math.sin(tNow*0.020) * intensity;
        shakeY = Math.sin(tNow*0.027) * (intensity*0.55);
      }

      const bob = camDynamic ? (Math.sin(tNow*0.0020) * 0.005) : 0;

      camera.up.set(0,1,0);

      // ===== CAMERA MODES =====
      // ===== CAMERA MODES =====
if(viewMode === 'fps'){
  camera.up.set(0,1,0);

  // ----- base eye position -----
  const eyeBaseY = 1.58;
  const eyeFwd   = 1.05;
  const eyeZ     = 0.10;

  const stoppedOrMenu = (!game.started || game.paused || game.over || game.stopped);
  const breatheAmpY = (stoppedOrMenu ? 0.010 : 0.0);
  const breatheAmpX = (stoppedOrMenu ? 0.006 : 0.0);
  const breatheY = Math.sin(tNow*0.0019) * breatheAmpY;
  const breatheX = Math.sin(tNow*0.0015) * breatheAmpX;

  // ----- grounded / landing detect -----
  const grounded = (game.y === 0 && !game.jumping);
  if(fpsGroundPrev === false && grounded === true){
    fpsLandKick = 1.0;
  }
  fpsGroundPrev = grounded;

  // smoothed vertical velocity feel
  fpsVelYSm = damp(fpsVelYSm, game.vy, 10, dt);

  // decays
  fpsLandKick = damp(fpsLandKick, 0.0, 14, dt);
  fpsLaneKick = damp(fpsLaneKick, 0.0, 12, dt);

  // ----- RUN bob -----
  if(camDynamic && fpsRealistic){
    const speedLike = 1.0 + ((game.foodBoostT>0 || game.ringBoostT>0) ? 0.35 : 0.0);
    fpsPhase += dt * (9.0 * speedLike);
  }

  const runAmpY = (camDynamic && fpsRealistic) ? 0.030 : 0.0;
  const runAmpX = (camDynamic && fpsRealistic) ? 0.014 : 0.0;
  const runY = Math.abs(Math.sin(fpsPhase)) * runAmpY;
  const runX = Math.sin(fpsPhase*0.5) * runAmpX;

  const air = grounded ? 0.0 : 1.0;
  const airFloat = (fpsRealistic ? Math.sin(tNow*0.006) * 0.008 : 0.0);

  const landY = -fpsLandKick * 0.020;

  const slideManualChin = (game.sliding ? 0.10 : 0.0);
  const yFollow = runnerPivot.position.y + eyeBaseY - slideManualChin;

  const laneKickX = fpsLaneKick * 0.030;

  const xOff = breatheX + (1-air)*runX + laneKickX;
  const yOff = breatheY + (1-air)*runY + airFloat + landY + (air * clamp(-fpsVelYSm*0.002, -0.02, 0.02));

  camera.position.set(
    runnerPivot.position.x + xOff,
    yFollow + yOff,
    eyeZ - eyeFwd
  );

  camera.lookAt(
    runnerPivot.position.x + xOff,
    yFollow + yOff,
    -10
  );

  camera.rotation.z = 0;
}
else if(viewMode === 'back'){
  const lookAtY = lerp(0.35, 1.45, framing);
  const lookAtZ = -6.5;
  camera.position.set(camX + shakeX, camY + bob + shakeY, camZ);
  camera.lookAt(camX*0.35, lookAtY, lookAtZ);
  camera.rotation.z = 0;
  camera.up.set(0,1,0);
}
else { // FRONT
  const lookAtY = lerp(0.30, 1.55, framing);
  const lookAtZ = 0.10;
  camera.position.set(camX + shakeX, camY + bob + shakeY, -camZ);
  camera.lookAt(camX*0.35, lookAtY, lookAtZ);
  camera.rotation.z = 0;
  camera.up.set(0,1,0);
}

      // ===== Debug panel update (timer) =====
      if(debugOn){
        dbgTimer += dt;
        if(dbgTimer > 0.12){
          dbgTimer = 0;
          if(dbgFps) dbgFps.textContent = `fps: ${fpsShow ? fpsShow.toFixed(0) : '--'}`;
          if(dbgCam) dbgCam.textContent = `${camera.position.x.toFixed(2)}, ${camera.position.y.toFixed(2)}, ${camera.position.z.toFixed(2)}`;
          if(dbgMode) dbgMode.textContent = viewMode;
          if(dbgState) dbgState.textContent = `started:${game.started} stopped:${game.stopped} paused:${game.paused} over:${game.over} anim:${animState.mode}`;
          if(dbgEnt) dbgEnt.textContent = String(game.entities.length);
          if(dbgLane) dbgLane.textContent = String(game.lane);
          if(dbgBoosts) dbgBoosts.textContent = `food:${game.foodBoostT.toFixed(1)} ring:${game.ringBoostT.toFixed(1)} mag:${game.magnetT.toFixed(1)}`;
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    function onResize(){
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onResize);

    // ===== Boot =====
    (async ()=>{
      refreshFoodUI();
      if(hpTxt) hpTxt.textContent = hpString();
      syncCamUI();

      await loadRunnerModel();

      game.started = false;
      game.over = false;
      game.paused = false;
      game.stopped = true;
      game.stopBlend = 1.0;
      updateMainButton();
      startIdleRandom();

      if(scoreEl) scoreEl.textContent = '0';
      if(coinsEl) coinsEl.textContent = '0';
      if(bestEl)  bestEl.textContent = String(game.best);
      if(ringsEl) ringsEl.textContent = '0';
      if(magTxt)  magTxt.textContent = 'üß≤ 0';
      setBoostUI();

      // applica modalit√† salvata
      applyViewMode(viewMode);
      setDebugUI();

      requestAnimationFrame(animate);
    })();
  </script>
</body>
</html>