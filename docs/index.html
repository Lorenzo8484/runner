<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Emoji Runner ‚Äî UE-ish (One File)</title>
  <style>
    :root { color-scheme: dark; }
    html,body{height:100%;margin:0;background:#05070c;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;overflow:hidden;}
    canvas{display:block;touch-action:none;}
    .hud{position:fixed;top:10px;left:10px;right:10px;display:flex;justify-content:space-between;gap:10px;pointer-events:none;z-index:10;}
    .card{pointer-events:none;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);border-radius:14px;padding:10px 12px;color:#eaf1ff;backdrop-filter:blur(10px);min-width:170px;}
    .row{display:flex;justify-content:space-between;gap:10px;align-items:center;}
    .small{font-size:12px;opacity:.86;line-height:1.2}
    .btn{pointer-events:auto;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.16);color:#eaf1ff;padding:10px 12px;border-radius:14px;font-weight:800;cursor:pointer;user-select:none;}
    .btn:active{transform:scale(.98);}
    .pill{display:inline-flex;align-items:center;gap:8px;margin-top:8px;padding:6px 10px;border-radius:999px;background:rgba(255,255,255,.07);border:1px solid rgba(255,255,255,.12);font-size:12px;white-space:nowrap;}
    .bar{height:6px;width:120px;border-radius:999px;background:rgba(255,255,255,.12);overflow:hidden;}
    .bar>i{display:block;height:100%;width:0%;background:rgba(255,255,255,.78);}
    .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;padding:16px;background:radial-gradient(ellipse at center, rgba(0,0,0,.55), rgba(0,0,0,.82));backdrop-filter:blur(10px);z-index:20;}
    .panel{width:min(700px,100%);border-radius:18px;border:1px solid rgba(255,255,255,.16);background:rgba(10,14,22,.84);box-shadow:0 18px 60px rgba(0,0,0,.55);padding:16px;color:#eaf1ff;}
    .title{font-size:22px;font-weight:900;margin:4px 0 6px;}
    .subtitle{opacity:.88;font-size:13px;margin:0 0 12px;line-height:1.35;}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
    .full{grid-column:1/-1;}
    .toggle{display:flex;align-items:center;justify-content:space-between;border:1px solid rgba(255,255,255,.16);border-radius:14px;padding:10px 12px;background:rgba(255,255,255,.06);cursor:pointer;user-select:none;}
    .toggle label{font-weight:800;}
    .toggle span{opacity:.85;font-size:12px;}
    .switch{width:44px;height:26px;border-radius:99px;background:rgba(255,255,255,.14);position:relative;border:1px solid rgba(255,255,255,.16);}
    .switch i{position:absolute;top:3px;left:3px;width:20px;height:20px;border-radius:999px;background:rgba(255,255,255,.86);transition:transform .18s ease;}
    .switch.on{background:rgba(140,255,190,.18);border-color:rgba(140,255,190,.24);}
    .switch.on i{transform:translateX(18px);}
    .help{position:fixed;bottom:10px;left:10px;right:10px;display:flex;justify-content:center;pointer-events:none;z-index:10;}
    .help .card{max-width:980px;text-align:center;}
    input[type="file"]{display:none;}
  </style>

  <!-- Three.js importmap -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div class="hud">
    <div class="card">
      <div class="row"><div><strong>Score</strong>: <span id="score">0</span></div><div class="small">x<span id="mult">1.0</span></div></div>
      <div class="row"><div><strong>Emoji</strong>: <span id="coins">0</span></div><div class="small">Record: <span id="best">0</span></div></div>
      <div class="small">Velocit√†: <span id="spd">1.00</span>x</div>
      <div class="pill" id="pillNone">Power-up: <strong>‚Äî</strong></div>
      <div class="pill" id="pillPower" style="display:none;">
        <span id="pEmoji">üß≤</span><strong id="pName">Magnete</strong>
        <div class="bar"><i id="pBar"></i></div>
      </div>
    </div>
    <div style="display:flex;gap:10px;">
      <button class="btn" id="pause">Pausa</button>
      <button class="btn" id="restart">Restart</button>
    </div>
  </div>

  <div class="help">
    <div class="card small">
      <strong>Comandi</strong> ‚Äî Desktop: ‚Üê ‚Üí corsia, ‚Üë salto, ‚Üì scivolata, P pausa, R restart.
      Mobile: swipe sx/dx, swipe su (salto), swipe gi√π (scivolata).
    </div>
  </div>

  <div class="overlay" id="menu">
    <div class="panel">
      <div class="title">Emoji Runner ‚Äî UE-ish (One File)</div>
      <div class="subtitle">
        Shadow + contact shadow + motion (afterimage) + bloom + suoni ‚Äúengine‚Äù. HDRI EXR: ‚ÄúShanghai Bund‚Äù (Poly Haven CC0).
      </div>

      <div class="grid">
        <button class="btn full" id="startBtn">‚ñ∂Ô∏è Inizia</button>

        <div class="toggle full" id="audioToggle">
          <div><label>Suoni</label><br/><span>Engine + SFX (WebAudio).</span></div>
          <div class="switch on" id="audioSwitch"><i></i></div>
        </div>

        <div class="toggle full" id="bloomToggle">
          <div><label>Bloom</label><br/><span>Neon glow.</span></div>
          <div class="switch on" id="bloomSwitch"><i></i></div>
        </div>

        <div class="toggle full" id="motionToggle">
          <div><label>Motion</label><br/><span>Afterimage trail.</span></div>
          <div class="switch on" id="motionSwitch"><i></i></div>
        </div>

        <div class="toggle full" id="qualityToggle">
          <div><label>Qualit√†</label><br/><span>Alto / Medio (pi√π FPS).</span></div>
          <div class="switch on" id="qualitySwitch"><i></i></div>
        </div>

        <button class="btn full" id="loadModelBtn">üì¶ Carica ostacolo reale (.glb/.gltf)</button>
        <input id="modelFile" type="file" accept=".glb,.gltf" />

        <div class="toggle full">
          <div><label>Record</label><br/><span>Salvato in locale.</span></div>
          <div style="font-weight:900;font-size:18px;" id="bestBig">0</div>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { EXRLoader } from 'three/addons/loaders/EXRLoader.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // ---------------- UI refs
    const scoreEl = document.getElementById('score');
    const coinsEl = document.getElementById('coins');
    const bestEl  = document.getElementById('best');
    const bestBig = document.getElementById('bestBig');
    const spdEl   = document.getElementById('spd');
    const multEl  = document.getElementById('mult');

    const pillNone = document.getElementById('pillNone');
    const pillPower= document.getElementById('pillPower');
    const pEmoji   = document.getElementById('pEmoji');
    const pName    = document.getElementById('pName');
    const pBar     = document.getElementById('pBar');

    const menu = document.getElementById('menu');
    const startBtn = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restart');
    const pauseBtn   = document.getElementById('pause');

    const audioToggle = document.getElementById('audioToggle');
    const audioSwitch = document.getElementById('audioSwitch');
    const bloomToggle = document.getElementById('bloomToggle');
    const bloomSwitch = document.getElementById('bloomSwitch');
    const motionToggle = document.getElementById('motionToggle');
    const motionSwitch = document.getElementById('motionSwitch');
    const qualityToggle = document.getElementById('qualityToggle');
    const qualitySwitch = document.getElementById('qualitySwitch');

    const loadModelBtn = document.getElementById('loadModelBtn');
    const modelFile = document.getElementById('modelFile');

    // ---------------- helpers
    const rnd=(a,b)=>a+Math.random()*(b-a);
    const rndi=(a,b)=>Math.floor(rnd(a,b+1));
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

    function toggleSwitch(el, on){ el.classList.toggle('on', !!on); return on; }
    function menuIsOpen(){ return menu.style.display !== 'none'; }

    // ---------------- Audio (procedural ‚Äúbetter‚Äù)
    let audioEnabled = true;
    let audioReady = false;
    let actx=null, master=null;
    let engineGain=null, engineOscA=null, engineOscB=null, engineNoise=null, engineFilter=null;

    function syncAudioUI(){ audioSwitch.classList.toggle('on', !!audioEnabled); }

    function initAudio(){
      if (audioReady) return;
      try{
        actx = new (window.AudioContext||window.webkitAudioContext)();
        master = actx.createGain();
        master.gain.value = 0.45;
        master.connect(actx.destination);

        engineGain = actx.createGain();
        engineGain.gain.value = 0.0;

        engineFilter = actx.createBiquadFilter();
        engineFilter.type = 'lowpass';
        engineFilter.frequency.value = 260;

        engineOscA = actx.createOscillator();
        engineOscA.type = 'sawtooth';
        engineOscA.frequency.value = 70;

        engineOscB = actx.createOscillator();
        engineOscB.type = 'square';
        engineOscB.frequency.value = 35;

        const noiseBuf = actx.createBuffer(1, actx.sampleRate * 2, actx.sampleRate);
        const data = noiseBuf.getChannelData(0);
        for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * 0.45;
        engineNoise = actx.createBufferSource();
        engineNoise.buffer = noiseBuf;
        engineNoise.loop = true;

        const noiseHP = actx.createBiquadFilter();
        noiseHP.type='highpass';
        noiseHP.frequency.value = 220;

        const mix = actx.createGain();
        mix.gain.value = 0.22;

        engineOscA.connect(mix);
        engineOscB.connect(mix);
        engineNoise.connect(noiseHP);
        noiseHP.connect(mix);

        mix.connect(engineFilter);
        engineFilter.connect(engineGain);
        engineGain.connect(master);

        engineOscA.start();
        engineOscB.start();
        engineNoise.start();

        audioReady = true;
      } catch(e){
        audioEnabled = false;
      }
      syncAudioUI();
    }

    function setEngine(on){
      if(!audioEnabled) return;
      initAudio(); if(!audioReady) return;
      const t = actx.currentTime;
      const target = on ? 0.22 : 0.0;
      engineGain.gain.cancelScheduledValues(t);
      engineGain.gain.setValueAtTime(engineGain.gain.value, t);
      engineGain.gain.linearRampToValueAtTime(target, t + (on ? 0.25 : 0.18));
    }

    function updateEngine(speedMul){
      if(!audioEnabled || !audioReady) return;
      const t = actx.currentTime;
      const rpm = 1 + speedMul*0.55;
      engineOscA.frequency.setValueAtTime(70 * rpm, t);
      engineOscB.frequency.setValueAtTime(35 * rpm, t);
      engineFilter.frequency.setValueAtTime(240 + 220 * rpm, t);
    }

    function envBeep(type,freq,dur=0.09,gain=0.22, pan=0){
      if(!audioEnabled) return;
      initAudio(); if(!audioReady) return;
      const t0 = actx.currentTime;
      const o = actx.createOscillator();
      const g = actx.createGain();
      const p = actx.createStereoPanner();
      p.pan.setValueAtTime(pan, t0);

      o.type = type;
      o.frequency.setValueAtTime(freq, t0);

      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(gain, t0+0.012);
      g.gain.exponentialRampToValueAtTime(0.0001, t0+dur);

      o.connect(g); g.connect(p); p.connect(master);
      o.start(t0); o.stop(t0+dur+0.02);
    }

    function noiseBurst(dur=0.11,gain=0.22){
      if(!audioEnabled) return;
      initAudio(); if(!audioReady) return;
      const t0 = actx.currentTime;
      const size = Math.floor(actx.sampleRate*dur);
      const buf = actx.createBuffer(1,size,actx.sampleRate);
      const d = buf.getChannelData(0);
      for(let i=0;i<size;i++) d[i]=(Math.random()*2-1)*(1-i/size);
      const src = actx.createBufferSource(); src.buffer=buf;
      const f = actx.createBiquadFilter(); f.type='bandpass'; f.frequency.setValueAtTime(520,t0); f.Q.value=0.9;
      const g = actx.createGain();
      g.gain.setValueAtTime(gain,t0);
      g.gain.exponentialRampToValueAtTime(0.0001,t0+dur);
      src.connect(f); f.connect(g); g.connect(master);
      src.start(t0); src.stop(t0+dur+0.02);
    }

    const SFX = {
      coin(pan=0){ envBeep('triangle', 880, 0.06, 0.16, pan); envBeep('sine', 1320, 0.07, 0.10, pan); },
      power(pan=0){ envBeep('sawtooth', 520, 0.10, 0.18, pan); envBeep('triangle', 980, 0.12, 0.12, pan); },
      jump(){ envBeep('square', 420, 0.06, 0.10, 0); envBeep('sine', 640, 0.08, 0.08, 0); },
      slide(){ envBeep('sine', 240, 0.09, 0.09, 0); },
      whoosh(pan=0){ noiseBurst(0.08, 0.14); envBeep('sine', 160, 0.10, 0.05, pan); },
      shield(){ envBeep('triangle', 320, 0.08, 0.10, 0); envBeep('sine', 720, 0.10, 0.09, 0); },
      over(){ noiseBurst(0.16, 0.26); envBeep('sawtooth', 140, 0.20, 0.14, 0); }
    };

    // ---------------- Renderer (shadows)
    const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.08;
    renderer.physicallyCorrectLights = true;

    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    document.body.appendChild(renderer.domElement);

    // ---------------- Scene / Camera
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x05070c, 0.050);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 250);
    camera.position.set(0, 2.2, 5.8);

    // ---------------- Lights
    const key = new THREE.DirectionalLight(0xcfe8ff, 2.2);
    key.position.set(4, 7, 3);
    key.castShadow = true;
    key.shadow.mapSize.set(2048, 2048);
    key.shadow.camera.near = 0.5;
    key.shadow.camera.far = 30;
    key.shadow.camera.left = -6;
    key.shadow.camera.right = 6;
    key.shadow.camera.top = 6;
    key.shadow.camera.bottom = -6;
    key.shadow.bias = -0.00035;
    scene.add(key);

    const fill = new THREE.HemisphereLight(0x7fd6ff, 0x0b0f18, 0.75);
    scene.add(fill);

    const neonL = new THREE.PointLight(0x55ddff, 18, 18, 2);
    neonL.position.set(-2.2, 1.6, 1.8);
    scene.add(neonL);

    const neonR = new THREE.PointLight(0xff4df2, 18, 18, 2);
    neonR.position.set( 2.2, 1.6, 1.8);
    scene.add(neonR);

    // ---------------- HDRI EXR + PMREM (Poly Haven)
    const HDR_EXR = 'https://dl.polyhaven.org/file/ph-assets/HDRIs/exr/4k/shanghai_bund_4k.exr';
    const pmrem = new THREE.PMREMGenerator(renderer);
    pmrem.compileEquirectangularShader();

    const exr = await new EXRLoader().loadAsync(HDR_EXR);
    exr.mapping = THREE.EquirectangularReflectionMapping;
    const envMap = pmrem.fromEquirectangular(exr).texture;
    scene.environment = envMap;
    scene.background  = envMap;
    exr.dispose();

    // ---------------- Postprocessing: Bloom + Afterimage
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));

    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      0.90, 0.55, 0.20
    );
    composer.addPass(bloomPass);

    const afterPass = new AfterimagePass();
    afterPass.uniforms['damp'].value = 0.90; // trail amount
    composer.addPass(afterPass);

    // ---------------- Contact shadow (fake)
    function makeContactShadowTexture(size=512){
      const c = document.createElement('canvas');
      c.width=c.height=size;
      const g = c.getContext('2d');
      g.clearRect(0,0,size,size);
      const grd = g.createRadialGradient(size/2,size/2,0, size/2,size/2,size*0.48);
      grd.addColorStop(0,'rgba(0,0,0,0.45)');
      grd.addColorStop(0.55,'rgba(0,0,0,0.12)');
      grd.addColorStop(1,'rgba(0,0,0,0)');
      g.fillStyle=grd;
      g.fillRect(0,0,size,size);
      const t = new THREE.CanvasTexture(c);
      t.colorSpace = THREE.SRGBColorSpace;
      return t;
    }

    const contactTex = makeContactShadowTexture(512);
    const contact = new THREE.Mesh(
      new THREE.PlaneGeometry(1.4, 1.4),
      new THREE.MeshBasicMaterial({ map: contactTex, transparent:true, opacity:0.65, depthWrite:false })
    );
    contact.rotation.x = -Math.PI/2;
    contact.position.set(0, 0.015, 0.2);
    scene.add(contact);

    // ---------------- Road (Poly Haven asphalt_02)
    const lanesX = [-1.1, 0, 1.1];
    const segLen = 8.0, segCount = 9, roadWidth = 4.0;

    const loader = new THREE.TextureLoader();
    const TEX = {
      diff:  'https://dl.polyhaven.org/file/ph-assets/Textures/jpg/2k/asphalt_02/asphalt_02_diff_2k.jpg',
      rough: 'https://dl.polyhaven.org/file/ph-assets/Textures/jpg/2k/asphalt_02/asphalt_02_rough_2k.jpg',
      nor:   'https://dl.polyhaven.org/file/ph-assets/Textures/jpg/2k/asphalt_02/asphalt_02_nor_gl_2k.jpg'
    };

    const texDiff  = await loader.loadAsync(TEX.diff);
    const texRough = await loader.loadAsync(TEX.rough);
    const texNor   = await loader.loadAsync(TEX.nor);
    texDiff.colorSpace = THREE.SRGBColorSpace;

    for (const t of [texDiff, texRough, texNor]) {
      t.wrapS = t.wrapT = THREE.RepeatWrapping;
      t.repeat.set(2.4, 8.0);
    }

    const roadMat = new THREE.MeshStandardMaterial({
      map: texDiff, roughnessMap: texRough, normalMap: texNor,
      roughness: 1.0, metalness: 0.06,
    });

    const lineMat = new THREE.MeshStandardMaterial({
      color: 0x0d1220,
      emissive: 0x45e8ff,
      emissiveIntensity: 2.1,
      roughness: 0.35,
      metalness: 0.25,
      transparent: true,
      opacity: 0.60
    });

    const segments = [];
    for (let i=0;i<segCount;i++){
      const geo = new THREE.PlaneGeometry(roadWidth, segLen); geo.rotateX(-Math.PI/2);
      const mesh = new THREE.Mesh(geo, roadMat);
      mesh.position.set(0, 0, -i*segLen);
      mesh.receiveShadow = true;
      scene.add(mesh);

      const linesGeo = new THREE.PlaneGeometry(roadWidth*0.98, segLen*0.98); linesGeo.rotateX(-Math.PI/2);
      const lines = new THREE.Mesh(linesGeo, lineMat);
      lines.position.set(0, 0.012, -i*segLen);
      scene.add(lines);

      segments.push({ mesh, lines });
    }

    const wallGeo = new THREE.BoxGeometry(0.24, 2.3, segLen*segCount);
    const wallL = new THREE.Mesh(wallGeo, new THREE.MeshStandardMaterial({
      color: 0x070a10, metalness: 0.80, roughness: 0.25, emissive: 0x2bdcff, emissiveIntensity: 0.35
    }));
    wallL.position.set(-roadWidth/2 - 0.45, 1.15, -segLen*segCount/2 + segLen/2);
    wallL.receiveShadow = true;
    scene.add(wallL);

    const wallR = new THREE.Mesh(wallGeo, new THREE.MeshStandardMaterial({
      color: 0x070a10, metalness: 0.80, roughness: 0.25, emissive: 0xff2bd6, emissiveIntensity: 0.35
    }));
    wallR.position.set( roadWidth/2 + 0.45, 1.15, -segLen*segCount/2 + segLen/2);
    wallR.receiveShadow = true;
    scene.add(wallR);

    // ---------------- Player
    const player = new THREE.Group(); scene.add(player);

    const body = new THREE.Mesh(
      new THREE.CapsuleGeometry(0.22, 0.45, 8, 16),
      new THREE.MeshStandardMaterial({
        color: 0x0f1424, metalness: 0.42, roughness: 0.22,
        emissive: 0x8fdcff, emissiveIntensity: 0.22
      })
    );
    body.position.y = 0.65;
    body.castShadow = true;
    player.add(body);

    const visor = new THREE.Mesh(
      new THREE.SphereGeometry(0.18, 24, 18),
      new THREE.MeshStandardMaterial({
        color: 0x0b0f18, roughness: 0.06,
        emissive: 0xff4df2, emissiveIntensity: 0.28
      })
    );
    visor.position.set(0, 0.78, 0.16);
    visor.castShadow = true;
    player.add(visor);

    const shieldRing = new THREE.Mesh(
      new THREE.TorusGeometry(0.42, 0.03, 10, 64),
      new THREE.MeshStandardMaterial({
        color: 0x1b2a44, metalness: 0.2, roughness: 0.15,
        emissive: 0x55ddff, emissiveIntensity: 1.25,
        transparent:true, opacity:0.65
      })
    );
    shieldRing.rotation.x = Math.PI/2;
    shieldRing.position.y = 0.7;
    shieldRing.visible = false;
    player.add(shieldRing);

    // ---------------- Emoji sprites
    function makeEmojiSprite(emoji, size=256){
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const g = c.getContext('2d');
      g.clearRect(0,0,size,size);
      g.globalAlpha = 0.18;
      g.fillStyle = '#cfefff';
      g.beginPath(); g.arc(size/2,size/2,size*0.33,0,Math.PI*2); g.fill();
      g.globalAlpha = 1;
      g.font = `${size*0.55}px system-ui, Apple Color Emoji, Segoe UI Emoji`;
      g.textAlign='center'; g.textBaseline='middle';
      g.fillText(emoji, size/2, size/2+8);

      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      const mat = new THREE.SpriteMaterial({ map: tex, transparent:true });
      const spr = new THREE.Sprite(mat);
      spr.scale.set(0.75,0.75,1);
      return spr;
    }

    // ---------------- Real obstacle via user GLB/GLTF
    let obstacleModelProto = null;
    const gltfLoader = new GLTFLoader();

    async function loadObstacleFromFile(file){
      const url = URL.createObjectURL(file);
      try{
        const gltf = await gltfLoader.loadAsync(url);
        obstacleModelProto = gltf.scene;
        obstacleModelProto.traverse(o=>{
          if(o.isMesh){
            o.castShadow = true;
            o.receiveShadow = true;
            if(o.material) o.material.envMapIntensity = 1.25;
          }
        });
      } finally {
        URL.revokeObjectURL(url);
      }
    }

    loadModelBtn.addEventListener('click', ()=> modelFile.click());
    modelFile.addEventListener('change', async (e)=>{
      const f = e.target.files?.[0];
      if(!f) return;
      await loadObstacleFromFile(f);
      loadModelBtn.textContent = "‚úÖ Modello ostacolo caricato";
    });

    function spawnObstacleVisual(){
      if(obstacleModelProto){
        const obj = obstacleModelProto.clone(true);
        obj.scale.setScalar(0.40);
        return obj;
      }
      const spr = makeEmojiSprite(["üß±","üöß","ü™®","üóëÔ∏è","ü™µ"][rndi(0,4)]);
      spr.scale.set(0.95,0.95,1);
      return spr;
    }

    // ---------------- Game data
    const EMOJIS = ["‚ú®","üçÄ","üî•","üçï","üéØ","üíé","‚ö°Ô∏è","üåà","üçã","‚≠êÔ∏è","üçì","ü•ù"];
    const POWERUPS = [
      { key:"magnet", emoji:"üß≤", name:"Magnete", dur:7.5 },
      { key:"shield", emoji:"üõ°Ô∏è", name:"Scudo",   dur:10.0 },
      { key:"double", emoji:"‚úñÔ∏è2", name:"Doppio",  dur:8.0 },
      { key:"slow",   emoji:"üê¢", name:"Slow-mo",  dur:6.0 }
    ];

    const BEST_KEY = 'emoji_runner_best_ue_onefile_v1';
    const loadBest = ()=> Number(localStorage.getItem(BEST_KEY)||'0')||0;
    const saveBest = (v)=> localStorage.setItem(BEST_KEY, String(v));

    const game = {
      lane: 1, targetLane: 1,
      y: 0, vy: 0, jumping:false,
      sliding:false, slideT:0,
      baseSpeed: 8.2, speedMul: 1.0,
      score:0, coins:0, best: loadBest(),
      over:false, paused:true,
      entities: [], spawnT: 0.28,
      active: null,
      hasShield:false, magnet:false, double:false, slow:false
    };

    bestEl.textContent = String(game.best);
    bestBig.textContent = String(game.best);

    function setActivePower(p){
      game.active = { ...p, t: p.dur };
      pillNone.style.display='none';
      pillPower.style.display='inline-flex';
      pEmoji.textContent = p.emoji;
      pName.textContent  = p.name;
    }
    function clearActivePower(){
      game.active=null;
      pillNone.style.display='inline-flex';
      pillPower.style.display='none';
      pBar.style.width='0%';
      game.magnet=false; game.double=false; game.slow=false;
    }
    function applyPowerFlags(){
      game.magnet=false; game.double=false; game.slow=false;
      if(!game.active) return;
      if(game.active.key==='magnet') game.magnet=true;
      if(game.active.key==='double') game.double=true;
      if(game.active.key==='slow')   game.slow=true;
      if(game.active.key==='shield') game.hasShield=true;
    }

    // ---------------- Spawning
    function spawnRow(){
      const blocked = new Set();
      let oCount = Math.random()<0.10 ? 2 : rndi(0,2);
      while(blocked.size<oCount) blocked.add(rndi(0,2));

      const coinLanes = new Set();
      let cCount = rndi(1,2);
      while(coinLanes.size<cCount) coinLanes.add(rndi(0,2));

      const z0 = -42 - rnd(0,18);

      blocked.forEach(l=>{
        const kind = (Math.random()<0.5?'low':'high'); // low->jump, high->slide
        const obj = spawnObstacleVisual();
        obj.position.set(lanesX[l], 0.60, z0);
        scene.add(obj);
        obj.traverse?.(o=>{ if(o.isMesh){ o.castShadow=true; o.receiveShadow=true; } });
        game.entities.push({ type:'obst', lane:l, z:z0, obj, kind });
      });

      coinLanes.forEach(l=>{
        const spr = makeEmojiSprite(EMOJIS[rndi(0,EMOJIS.length-1)]);
        spr.position.set(lanesX[l], 0.95, z0 - rnd(0,3));
        spr.scale.set(0.72,0.72,1);
        scene.add(spr);
        game.entities.push({ type:'coin', lane:l, z:spr.position.z, obj:spr });
      });

      if(Math.random()<0.10){
        const p = POWERUPS[rndi(0,POWERUPS.length-1)];
        const lane = rndi(0,2);
        const spr = makeEmojiSprite(p.emoji);
        spr.position.set(lanesX[lane], 1.05, z0 - rnd(1,5));
        spr.scale.set(0.76,0.76,1);
        scene.add(spr);
        game.entities.push({ type:'power', lane, z:spr.position.z, obj:spr, key:p.key, dur:p.dur, name:p.name, emoji:p.emoji });
      }
    }

    // ---------------- Controls + motion tilt
    let tiltTarget = 0;
    function moveLane(dir){
      if(game.over||game.paused) return;
      game.targetLane = clamp(game.targetLane+dir,0,2);
      game.lane = game.targetLane;
      tiltTarget = clamp(tiltTarget + dir*0.18, -0.22, 0.22);
      SFX.whoosh(dir>0 ? 0.35 : -0.35);
    }
    function jump(){
      if(game.over||game.paused) return;
      if(!game.jumping && game.y>=-0.001){
        game.jumping=true;
        game.vy = -7.8;
        SFX.jump();
      }
    }
    function slide(){
      if(game.over||game.paused) return;
      game.sliding=true;
      game.slideT=0.45;
      SFX.slide();
    }

    window.addEventListener('keydown', (e)=>{
      const k=e.key.toLowerCase();
      if(k==='arrowleft') moveLane(-1);
      if(k==='arrowright') moveLane(1);
      if(k==='arrowup' || k===' ') jump();
      if(k==='arrowdown') slide();
      if(k==='p') togglePause();
      if(k==='r') { initAudio(); closeMenu(); reset(); }
    });

    let touchStart=null;
    renderer.domElement.addEventListener('pointerdown',(e)=>{
      initAudio();
      renderer.domElement.setPointerCapture(e.pointerId);
      touchStart={x:e.clientX,y:e.clientY,t:performance.now()};
    });
    renderer.domElement.addEventListener('pointerup',(e)=>{
      if(!touchStart) return;
      const dx=e.clientX-touchStart.x, dy=e.clientY-touchStart.y;
      const adx=Math.abs(dx), ady=Math.abs(dy);
      touchStart=null;
      const min=30;
      if(adx<min && ady<min) return;
      if(adx>ady) moveLane(dx>0?1:-1);
      else { if(dy<0) jump(); else slide(); }
    });

    // ---------------- Menu + state
    function openMenu(){
      menu.style.display='flex';
      game.paused=true;
      bestBig.textContent=String(game.best);
      setEngine(false);
    }
    function closeMenu(){ menu.style.display='none'; }

    function reset(){
      game.lane=1; game.targetLane=1;
      game.y=0; game.vy=0; game.jumping=false;
      game.sliding=false; game.slideT=0;
      game.baseSpeed=8.2; game.speedMul=1.0;
      game.score=0; game.coins=0;
      game.over=false;
      game.spawnT=0.30;

      for(const e of game.entities) scene.remove(e.obj);
      game.entities.length=0;

      clearActivePower();
      game.hasShield=false;
      shieldRing.visible=false;

      game.paused=false;
      pauseBtn.textContent='Pausa';
      setEngine(true);
    }

    function togglePause(){
      if(game.over) return;
      game.paused = !game.paused;
      pauseBtn.textContent = game.paused ? 'Riprendi' : 'Pausa';
      setEngine(!game.paused);
    }

    startBtn.addEventListener('click', ()=>{ initAudio(); closeMenu(); reset(); });
    restartBtn.addEventListener('click', ()=>{ initAudio(); closeMenu(); reset(); });
    pauseBtn.addEventListener('click', ()=>{ initAudio(); togglePause(); });

    // toggles
    let bloomOn=true, motionOn=true, highQuality=true;
    bloomToggle.addEventListener('click', ()=>{ bloomOn=!bloomOn; toggleSwitch(bloomSwitch,bloomOn); bloomPass.enabled=bloomOn; });
    motionToggle.addEventListener('click', ()=>{ motionOn=!motionOn; toggleSwitch(motionSwitch,motionOn); afterPass.enabled=motionOn; });
    qualityToggle.addEventListener('click', ()=>{
      highQuality=!highQuality; toggleSwitch(qualitySwitch,highQuality);
      const pr = highQuality ? Math.min(2, window.devicePixelRatio||1) : 1;
      renderer.setPixelRatio(pr);
      composer.setPixelRatio(pr);
    });

    audioToggle.addEventListener('click', ()=>{
      initAudio();
      audioEnabled = !audioEnabled;
      syncAudioUI();
      setEngine(audioEnabled && !game.paused && !menuIsOpen());
      if(audioEnabled) envBeep('triangle', 660, 0.08, 0.10, 0);
      else setEngine(false);
    });
    syncAudioUI();

    // ---------------- Main update (with motion feel)
    let tPrev = performance.now();
    let camRoll = 0;
    let camShake = 0;

    function update(dt, tNow){
      if(game.paused) return;

      const timeScale = game.slow ? 0.62 : 1.0;
      dt *= timeScale;

      game.speedMul = 1 + Math.min(1.45, game.score/1700);
      const speed = game.baseSpeed * game.speedMul;

      updateEngine(game.speedMul);

      // power timer
      if(game.active){
        game.active.t -= dt;
        applyPowerFlags();
        const pct = clamp((game.active.t/game.active.dur)*100,0,100);
        pBar.style.width = pct.toFixed(1)+'%';
        if(game.active.key==='shield') shieldRing.visible = true;
        if(game.active.t<=0) clearActivePower();
      } else {
        game.magnet=false; game.double=false; game.slow=false;
      }

      // gravity
      const g = 22.0;
      game.vy += g*dt;
      game.y  += game.vy*dt;
      if(game.y>0){ game.y=0; game.vy=0; game.jumping=false; }

      // slide timer
      if(game.sliding){
        game.slideT -= dt;
        if(game.slideT<=0) game.sliding=false;
      }

      // player transform
      player.position.x = lanesX[game.lane];
      player.position.y = (-game.y);
      if(game.sliding){
        body.scale.set(1.15, 0.75, 1.15);
        body.position.y = 0.52;
      } else {
        body.scale.set(1,1,1);
        body.position.y = 0.65;
      }
      shieldRing.position.y = 0.70 + player.position.y;

      // contact shadow response to height
      const h = player.position.y;
      const s = 1.15 + clamp(h*0.65, 0, 0.85);
      contact.position.x = player.position.x;
      contact.scale.set(s, s, 1);
      contact.material.opacity = clamp(0.62 - h*0.25, 0.12, 0.62);

      // road scroll
      const scroll = speed*dt;
      texDiff.offset.y  -= scroll*0.08;
      texRough.offset.y -= scroll*0.08;
      texNor.offset.y   -= scroll*0.08;

      for(const seg of segments){
        seg.mesh.position.z += scroll;
        seg.lines.position.z += scroll;
        if(seg.mesh.position.z > segLen){
          seg.mesh.position.z -= segLen*segCount;
          seg.lines.position.z -= segLen*segCount;
        }
      }

      // spawn
      game.spawnT -= dt;
      const minGap = 0.50 / game.speedMul;
      if(game.spawnT<=0){
        spawnRow();
        game.spawnT = rnd(minGap, minGap+0.34);
      }

      // move entities
      for(const e of game.entities){
        e.z += scroll;
        e.obj.position.z = e.z;

        if(game.magnet && (e.type==='coin'||e.type==='power')){
          const dx = lanesX[game.lane] - e.obj.position.x;
          const dz = (0 - e.z);
          const dist = Math.hypot(dx*2.2, dz);
          if(dist < 6.5){
            e.obj.position.x += dx * dt * (1.6*(1-dist/6.5));
          }
        }
      }

      // despawn
      for(let i=game.entities.length-1;i>=0;i--){
        if(game.entities[i].z > 3.5){
          scene.remove(game.entities[i].obj);
          game.entities.splice(i,1);
        }
      }

      // collisions
      const px = player.position.x;
      const py = player.position.y + 0.65;

      for(let i=game.entities.length-1;i>=0;i--){
        const e = game.entities[i];
        const dz = Math.abs(e.z - 0.2);
        const dx = Math.abs(e.obj.position.x - px);
        const dy = Math.abs(e.obj.position.y - py);
        const hit = (dz < 0.65 && dx < 0.45 && dy < 0.85);
        if(!hit) continue;

        if(e.type==='coin'){
          game.coins += 1;
          game.score += 28*(game.double?2:1);
          scene.remove(e.obj); game.entities.splice(i,1);
          SFX.coin((e.obj.position.x - px) > 0 ? 0.25 : -0.25);
          continue;
        }

        if(e.type==='power'){
          const p = POWERUPS.find(p=>p.key===e.key) || POWERUPS[0];
          setActivePower(p);
          applyPowerFlags();
          if(p.key==='shield'){ game.hasShield=true; shieldRing.visible=true; }
          scene.remove(e.obj); game.entities.splice(i,1);
          SFX.power((e.obj.position.x - px) > 0 ? 0.18 : -0.18);
          continue;
        }

        if(e.type==='obst'){
          let mustHit=false;
          if(e.kind==='low'  && !game.jumping && game.y===0) mustHit=true;
          if(e.kind==='high' && !game.sliding) mustHit=true;

          if(mustHit){
            if(game.hasShield){
              game.hasShield=false;
              shieldRing.visible=false;
              scene.remove(e.obj); game.entities.splice(i,1);
              SFX.shield();
              camShake = 0.22;
            } else {
              game.over=true;
              game.paused=true;
              setEngine(false);
              SFX.over();
              if(game.score>game.best){ game.best=Math.floor(game.score); saveBest(game.best); }
              openMenu();
              startBtn.textContent='üîÅ Riprova';
            }
          }
        }
      }

      // score
      game.score += (19*game.speedMul)*dt*(game.double?2:1);
      if(game.score>game.best){ game.best=Math.floor(game.score); saveBest(game.best); }

      // HUD
      scoreEl.textContent = String(Math.floor(game.score));
      coinsEl.textContent = String(game.coins);
      bestEl.textContent  = String(game.best);
      bestBig.textContent = String(game.best);
      multEl.textContent  = (game.double?'2.0':'1.0');
      spdEl.textContent   = (game.speedMul).toFixed(2);

      // motion feel
      tiltTarget *= 0.92;
      camRoll = camRoll*0.90 + tiltTarget*0.10;
      camShake = Math.max(0, camShake - dt*0.9);
    }

    function animate(tNow){
      const dt = Math.min(0.033, (tNow - tPrev)/1000);
      tPrev = tNow;

      update(dt, tNow);

      // Camera: FOV dynamic + roll + bob + tiny shake
      const speedBoost = 1 + (game.paused ? 0 : (game.speedMul-1)*0.25);
      camera.fov = 60 + (speedBoost-1)*10;
      camera.updateProjectionMatrix();

      const bob = Math.sin(tNow*0.0026)*0.03;
      camera.position.set(0, 2.2 + bob, 5.8);

      const sx = (Math.sin(tNow*0.031) + Math.sin(tNow*0.017)) * 0.02 * camShake;
      const sy = (Math.sin(tNow*0.027)) * 0.015 * camShake;
      camera.position.x += sx;
      camera.position.y += sy;

      camera.rotation.z = camRoll;
      camera.lookAt(0, 1.15, -2.2);

      // shield pulse
      if(shieldRing.visible){
        shieldRing.material.opacity = 0.55 + 0.18*Math.sin(tNow*0.008);
        shieldRing.rotation.z += dt*1.2;
      }

      composer.render();
      requestAnimationFrame(animate);
    }

    // ---------------- Resize
    function onResize(){
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
      bloomPass.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onResize);

    // ---------------- Boot
    openMenu();
    requestAnimationFrame(animate);
  </script>
</body>
</html>
<!-- redeploy -->
