<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Jungle Emoji Runner (Three.js)</title>
  <style>
    :root { color-scheme: dark; }
    html,body{height:100%;margin:0;background:#040805;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;overflow:hidden;}
    canvas{display:block;touch-action:none;}

    .hud{
      position:fixed;top:8px;left:8px;right:8px;
      display:flex;justify-content:space-between;gap:8px;
      pointer-events:none;z-index:10;flex-wrap:wrap;align-items:flex-start;
    }
    .card{
      pointer-events:none;background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;padding:8px 10px;color:#eaf1ff;
      backdrop-filter:blur(10px);
      min-width:180px; max-width:62vw;
    }
    .row{display:flex;justify-content:space-between;gap:8px;align-items:center;}
    .small{font-size:11px;opacity:.86;line-height:1.2}
    .btn{
      pointer-events:auto;background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.16);
      color:#eaf1ff;padding:9px 11px;border-radius:12px;
      font-weight:800;cursor:pointer;user-select:none;
    }
    .btn:active{transform:scale(.98);}
    .controls{pointer-events:auto;display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end;align-items:flex-start;}

    .pill{display:inline-flex;align-items:center;gap:8px;margin-top:7px;padding:5px 9px;border-radius:999px;background:rgba(255,255,255,.07);border:1px solid rgba(255,255,255,.12);font-size:11px;white-space:nowrap;}
    .bar{height:6px;width:110px;border-radius:999px;background:rgba(255,255,255,.12);overflow:hidden;}
    .bar>i{display:block;height:100%;width:0%;background:rgba(255,255,255,.78);}

    .floatBtns{
      position:fixed; top:8px; right:8px;
      display:flex; flex-direction:row; gap:8px;
      z-index:25; pointer-events:none;
    }
    .iconBtn{
      pointer-events:auto;
      width:40px;height:40px;
      padding:0;
      border-radius:12px;
      display:flex;align-items:center;justify-content:center;
      font-size:17px;
      backdrop-filter:blur(10px);
      line-height:1;
    }

    .rightCol{
      position:fixed; top:62px; right:4px; width:56px;
      display:flex; flex-direction:column; align-items:center; gap:6px;
      pointer-events:none; z-index:10;
    }
    .foodStack{
      width:50px; max-height:210px; overflow:hidden;
      display:flex; flex-direction:column; align-items:center; gap:6px;
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.10);
      border-radius:12px;
      padding:7px 6px;
      backdrop-filter:blur(10px);
    }
    .foodItem{
      width:36px;height:36px;border-radius:11px;
      display:flex;align-items:center;justify-content:center;
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.12);
      font-size:19px;
    }
    .foodCount{
      margin-top:6px;
      width:50px;
      text-align:center;
      font-weight:900;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      border-radius:999px;
      padding:6px 0;
      font-size:12px;
    }

    /* ‚úÖ STOP button */
    .stopBtnWrap{
      position:fixed;
      right:14px;
      bottom:110px;
      z-index:30;
      pointer-events:none;
    }
    .stopBtn{
      pointer-events:auto;
      width:86px;
      height:56px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255, 80, 80, .12);
      backdrop-filter: blur(10px);
      color:#fff;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      font-weight:950;
      cursor:pointer;
      user-select:none;
    }
    .stopDot{
      width:18px;height:18px;border-radius:6px;
      background:#ff3b30;
      box-shadow:0 0 0 2px rgba(255,255,255,.12) inset;
    }
    .stopBtn.on{ background:rgba(140,255,190,.12); }
    .stopBtn.on .stopDot{ background:#34c759; }
    .stopLbl{ font-size:12px; opacity:.95; letter-spacing:.3px; }

    .help{position:fixed;bottom:8px;left:8px;right:8px;display:flex;justify-content:center;pointer-events:none;z-index:10;}
    .help .card{max-width:980px;text-align:center;}

    /* START/DANCE overlay (leggero, senza bloccare scena) */
    .startOverlay{
      position:fixed; inset:0;
      display:flex; align-items:flex-end; justify-content:center;
      padding:18px 14px 26px;
      pointer-events:none;
      z-index:40;
    }
    .startPanel{
      pointer-events:auto;
      width:min(420px, 92vw);
      background:rgba(10,14,22,.55);
      border:1px solid rgba(255,255,255,.14);
      border-radius:18px;
      padding:12px;
      backdrop-filter:blur(10px);
      box-shadow:0 18px 60px rgba(0,0,0,.45);
    }
    .startTitle{font-weight:950;font-size:16px;margin:0 0 6px;color:#eaf1ff;}
    .startSub{font-size:12px;opacity:.82;margin:0 0 10px;color:#eaf1ff;line-height:1.3}
    .startBtns{display:flex;gap:10px;flex-wrap:wrap}
    .btnWide{flex:1 1 150px; text-align:center;}

    /* Nascondo elementi finch√© non serve */
    .hidden{ display:none !important; }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>

  <div class="hud">
    <div class="card">
      <div class="row">
        <div><strong>Score</strong>: <span id="score">0</span></div>
        <div class="small">Record: <span id="best">0</span></div>
      </div>
      <div class="row">
        <div><strong>Emoji</strong>: <span id="coins">0</span></div>
        <div class="small"><span id="ringIcon">‚≠ïÔ∏è</span> <span id="rings">0</span></div>
      </div>

      <div class="row small" style="margin-top:6px;">
        <div><strong>Vita</strong>: <span id="hpTxt">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏èüñ§üñ§</span></div>
        <div><span id="magTxt">üß≤ 0</span></div>
      </div>

      <div class="pill" id="pillBoost" style="display:none;">
        <span id="boostIcon">‚ö°Ô∏è</span><strong id="boostName">BOOST</strong>
        <div class="bar"><i id="boostBar"></i></div>
      </div>
    </div>

    <!-- vecchio "Pausa" lo lasciamo ma lo nascondiamo finch√© non parte -->
    <div class="controls">
      <button class="btn hidden" id="pause">Pausa</button>
    </div>
  </div>

  <!-- vecchi bottoni ‚Äúavia‚Äù (settings/pause/home): nascosti finch√© non parte -->
  <div class="floatBtns hidden" id="floatBtns">
    <button class="btn iconBtn" id="btnSettings" aria-label="Impostazioni">‚öôÔ∏è</button>
    <button class="btn iconBtn" id="btnPause" aria-label="Pausa">‚è∏Ô∏è</button>
    <button class="btn iconBtn" id="btnHome" aria-label="Home">üè†</button>
  </div>

  <div class="rightCol">
    <div class="foodStack" id="foodStack"></div>
    <div class="foodCount"><span id="foodCount">0</span>/10</div>
  </div>

  <!-- ‚úÖ STOP -->
  <div class="stopBtnWrap hidden" id="stopWrap">
    <button class="stopBtn" id="stopBtn" aria-label="Stop traffico">
      <span class="stopDot"></span>
      <span class="stopLbl" id="stopLbl">STOP</span>
    </button>
  </div>

  <div class="help">
    <div class="card small" id="helpCard">
      <strong>Comandi</strong> ‚Äî Desktop: ‚Üê ‚Üí corsia, ‚Üë salto, ‚Üì (non usato), P pausa.
      Mobile: swipe sx/dx, swipe su (salto).
      <span style="opacity:.75">Anelli: auto-flip quando arrivano in corsia.</span>
      <span style="opacity:.75">STOP: ferma il traffico + idle random.</span>
    </div>
  </div>

  <!-- Start / Dance overlay -->
  <div class="startOverlay" id="startOverlay">
    <div class="startPanel">
      <div class="startTitle" id="startTitle">Jungle Emoji Runner</div>
      <p class="startSub" id="startSub">
        Premi <b>Start</b> per iniziare. <b>Stop</b> ferma il traffico (idle random).<br/>
        <span style="opacity:.85">Dance = HipHopDance.</span>
      </p>
      <div class="startBtns">
        <button class="btn btnWide" id="startBtn">‚ñ∂Ô∏è Start</button>
        <button class="btn btnWide" id="danceBtn">üï∫ Dance</button>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    const IS_IOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

    // UI
    const scoreEl = document.getElementById('score');
    const coinsEl = document.getElementById('coins');
    const bestEl  = document.getElementById('best');
    const ringsEl = document.getElementById('rings');
    const hpTxt   = document.getElementById('hpTxt');
    const magTxt  = document.getElementById('magTxt');

    const pillBoost = document.getElementById('pillBoost');
    const boostIcon = document.getElementById('boostIcon');
    const boostName = document.getElementById('boostName');
    const boostBar  = document.getElementById('boostBar');

    const foodStack = document.getElementById('foodStack');
    const foodCountEl = document.getElementById('foodCount');

    const pauseBtn   = document.getElementById('pause');

    const floatBtns  = document.getElementById('floatBtns');
    const btnSettings = document.getElementById('btnSettings');
    const btnHome = document.getElementById('btnHome');
    const btnPause = document.getElementById('btnPause');

    const stopWrap = document.getElementById('stopWrap');
    const stopBtn = document.getElementById('stopBtn');
    const stopLbl = document.getElementById('stopLbl');

    const startOverlay = document.getElementById('startOverlay');
    const startBtn = document.getElementById('startBtn');
    const danceBtn = document.getElementById('danceBtn');
    const startTitle = document.getElementById('startTitle');
    const startSub = document.getElementById('startSub');

    const rnd=(a,b)=>a+Math.random()*(b-a);
    const rndi=(a,b)=>Math.floor(rnd(a,b+1));
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp=(a,b,t)=>a+(b-a)*t;
    const damp = (current, target, lambda, dt) => current + (target-current) * (1 - Math.exp(-lambda*dt));

    // Audio minimal (come tuo)
    let audioEnabled=true, audioReady=false, actx=null, master=null;
    function initAudio(){
      if(audioReady) return;
      try{
        actx = new (window.AudioContext||window.webkitAudioContext)();
        master = actx.createGain(); master.gain.value=0.55; master.connect(actx.destination);
        audioReady=true;
      }catch(e){ audioEnabled=false; }
    }
    function beep(type,freq,dur=0.06,g=0.10){
      if(!audioEnabled) return;
      initAudio(); if(!audioReady) return;
      const t0=actx.currentTime;
      const o=actx.createOscillator();
      const gg=actx.createGain();
      o.type=type; o.frequency.setValueAtTime(freq,t0);
      gg.gain.setValueAtTime(0.0001,t0);
      gg.gain.exponentialRampToValueAtTime(g,t0+0.012);
      gg.gain.exponentialRampToValueAtTime(0.0001,t0+dur);
      o.connect(gg); gg.connect(master);
      o.start(t0); o.stop(t0+dur+0.02);
    }
    const sfx = {
      coin: ()=>{ beep('triangle', 900, 0.06, 0.10); beep('sine', 1350, 0.07, 0.07); },
      food: ()=>{ beep('sine', 520, 0.06, 0.09); },
      ring: ()=>{ beep('triangle', 700, 0.06, 0.10); },
      magnet: ()=>{ beep('sawtooth', 420, 0.10, 0.09); beep('triangle', 880, 0.10, 0.07); },
      hit:  ()=>{ beep('square', 120, 0.12, 0.11); },
      lane: ()=>{ beep('sine', 160, 0.05, 0.05); },
      jump: ()=>{ beep('square', 420, 0.05, 0.08); },
      slide:()=>{ beep('sine', 220, 0.06, 0.06); },
      boost:()=>{ beep('sawtooth', 520, 0.10, 0.09); beep('triangle', 880, 0.10, 0.07); },
    };

    // Renderer / Scene
    const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x08120b);
    scene.fog = IS_IOS ? new THREE.Fog(0x08120b, 26, 110) : new THREE.FogExp2(0x06110a, 0.036);

    // Camera
    const baseFov = 60;
    const baseCamZ = 5.0;
    const framing = 0.06;
    const camera = new THREE.PerspectiveCamera(baseFov, window.innerWidth/window.innerHeight, 0.1, 320);

    // lights
    const sun = new THREE.DirectionalLight(0xf3ffe6, IS_IOS ? 2.8 : 2.1);
    sun.position.set(6, 10, 6);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048,2048);
    sun.shadow.camera.near = 0.5;
    sun.shadow.camera.far = 80;
    sun.shadow.camera.left = -12;
    sun.shadow.camera.right=  12;
    sun.shadow.camera.top  =  12;
    sun.shadow.camera.bottom=-12;
    sun.shadow.bias = -0.00023;
    scene.add(sun);
    scene.add(new THREE.HemisphereLight(0xaaffdd, 0x081209, IS_IOS ? 1.05 : 0.78));
    scene.add(new THREE.AmbientLight(0xffffff, IS_IOS ? 0.6 : 0.24));
    const front = new THREE.DirectionalLight(0xffffff, IS_IOS ? 1.25 : 0.55);
    front.position.set(0, 4, 9);
    scene.add(front);

    // Contact shadow
    function makeContactShadowTexture(size=512){
      const c=document.createElement('canvas'); c.width=c.height=size;
      const g=c.getContext('2d');
      g.clearRect(0,0,size,size);
      const grd=g.createRadialGradient(size/2,size/2,0, size/2,size/2,size*0.48);
      grd.addColorStop(0,'rgba(0,0,0,0.38)');
      grd.addColorStop(0.55,'rgba(0,0,0,0.10)');
      grd.addColorStop(1,'rgba(0,0,0,0)');
      g.fillStyle=grd; g.fillRect(0,0,size,size);
      const t=new THREE.CanvasTexture(c); t.colorSpace=THREE.SRGBColorSpace;
      return t;
    }
    const contact = new THREE.Mesh(
      new THREE.PlaneGeometry(1.5,1.5),
      new THREE.MeshBasicMaterial({ map:makeContactShadowTexture(512), transparent:true, opacity:0.55, depthWrite:false })
    );
    contact.rotation.x = -Math.PI/2;
    contact.position.set(0, 0.02, 0.2);
    scene.add(contact);

    // =========================================================
    // STRADA (come tua) - versione compatta (uguale come resa)
    // =========================================================
    const segLen = 9.0, segCount = 10;

    const laneW = 1.35;
    const mainRoadWidth = laneW * 3;
    const shoulderWidth = 1.40;
    const totalRoadWidth = mainRoadWidth + shoulderWidth;

    const leftEdge = -totalRoadWidth/2;
    const lanesX = [
      leftEdge + laneW*0.5,
      leftEdge + laneW*1.5,
      leftEdge + laneW*2.5,
      leftEdge + mainRoadWidth + shoulderWidth*0.5
    ];

    function makeHighwayTexture(size=1024){
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const g = c.getContext('2d');
      g.fillStyle = '#2b2f35';
      g.fillRect(0,0,size,size);
      for(let i=0;i<20000;i++){
        const x = Math.random()*size, y = Math.random()*size;
        const v = Math.floor(70 + Math.random()*70);
        g.fillStyle = `rgba(${v},${v},${v},${Math.random()*0.10})`;
        g.fillRect(x,y,1,1);
      }
      const px = (worldX)=> Math.round(((worldX - leftEdge) / totalRoadWidth) * size);

      const shoulderStartX = leftEdge + mainRoadWidth;
      g.fillStyle = 'rgba(255,255,255,0.03)';
      g.fillRect(px(shoulderStartX), 0, px(leftEdge+totalRoadWidth) - px(shoulderStartX), size);

      const solidW = Math.max(6, Math.round(size * 0.008));
      const dashW  = Math.max(5, Math.round(size * 0.0065));
      const dashLen = Math.round(size * 0.180);
      const dashGap = Math.round(size * 0.999);

      g.fillStyle = '#f4f6f8';

      const xOuterL = px(leftEdge + 0.03);
      const xOuterR = px(leftEdge + totalRoadWidth - 0.03);
      g.fillRect(Math.round(xOuterL - solidW/2), 0, solidW, size);
      g.fillRect(Math.round(xOuterR - solidW/2), 0, solidW, size);

      const xShoulderSep = px(shoulderStartX);
      g.fillRect(Math.round(xShoulderSep - solidW/2), 0, solidW, size);

      const xDash1 = px(leftEdge + laneW*1);
      const xDash2 = px(leftEdge + laneW*2);
      const xDash1I = Math.round(xDash1 - dashW/2);
      const xDash2I = Math.round(xDash2 - dashW/2);

      for(let y=0; y<size; y += (dashLen + dashGap)){
        const yi = Math.round(y);
        g.fillRect(xDash1I, yi, dashW, dashLen);
        g.fillRect(xDash2I, yi, dashW, dashLen);
      }

      const t = new THREE.CanvasTexture(c);
      t.colorSpace = THREE.SRGBColorSpace;
      t.wrapS = t.wrapT = THREE.RepeatWrapping;
      t.repeat.set(1.0, 4.0);
      t.generateMipmaps = false;
      t.minFilter = THREE.NearestFilter;
      t.magFilter = THREE.NearestFilter;
      t.anisotropy = renderer.capabilities.getMaxAnisotropy();
      t.needsUpdate = true;
      return t;
    }

    const highwayTex = makeHighwayTexture(IS_IOS ? 768 : 1024);

    const roadMat = new THREE.MeshStandardMaterial({
      map: highwayTex,
      roughness: 0.96,
      metalness: 0.0,
      color: new THREE.Color(0xffffff)
    });

    const segments=[];
    for(let i=0;i<segCount;i++){
      const geo = new THREE.PlaneGeometry(totalRoadWidth, segLen);
      geo.rotateX(-Math.PI/2);
      const mesh = new THREE.Mesh(geo, roadMat);
      mesh.position.set(0, 0, -i*segLen);
      mesh.receiveShadow=true;
      scene.add(mesh);
      segments.push(mesh);
    }

    // terreno laterale
    const sideGeo = new THREE.PlaneGeometry(44, segLen*segCount);
    sideGeo.rotateX(-Math.PI/2);
    const sideMat = new THREE.MeshStandardMaterial({ color:0x0d2416, roughness:1, metalness:0 });
    const side = new THREE.Mesh(sideGeo, sideMat);
    side.position.set(0, -0.02, -segLen*segCount/2 + segLen/2);
    side.receiveShadow = true;
    scene.add(side);

    // alberi (come tuo, semplificato)
    const jungle = new THREE.Group(); scene.add(jungle);
    function makeTree(){
      const g = new THREE.Group();
      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.11, 0.16, 1.6, 10),
        new THREE.MeshStandardMaterial({ color:0x4a3523, roughness:1, metalness:0 })
      );
      trunk.position.y=0.8; trunk.castShadow=true; trunk.receiveShadow=true; g.add(trunk);
      const crown = new THREE.Mesh(
        new THREE.ConeGeometry(0.75, 1.6, 12),
        new THREE.MeshStandardMaterial({ color:0x1c6b33, roughness:1, metalness:0 })
      );
      crown.position.y=1.9; crown.castShadow=true; crown.receiveShadow=true; g.add(crown);
      const crown2 = new THREE.Mesh(
        new THREE.ConeGeometry(0.6, 1.3, 12),
        new THREE.MeshStandardMaterial({ color:0x135226, roughness:1, metalness:0 })
      );
      crown2.position.y=2.3; crown2.castShadow=true; crown2.receiveShadow=true; g.add(crown2);
      return g;
    }
    const treeProto = makeTree();
    const treePool=[];
    const treeSpacing=2.8;
    const treeSideX = (totalRoadWidth/2) + 1.9;
    const jungleCount = Math.floor((segLen*segCount)/treeSpacing);
    for(let i=0;i<jungleCount;i++){
      const z = -i*treeSpacing;
      for(const sideSign of [-1,1]){
        const t = treeProto.clone(true);
        t.position.set(sideSign*(treeSideX + rnd(0,1.8)), 0, z);
        t.scale.setScalar(rnd(0.8,1.2));
        t.rotation.y = rnd(0,Math.PI*2);
        t.traverse(o=>{ if(o.isMesh){o.castShadow=true;o.receiveShadow=true;}});
        jungle.add(t); treePool.push(t);
      }
    }
    function loopJungle(scroll){
      const wrapZ = segLen*segCount;
      for(const obj of treePool){
        obj.position.z += scroll;
        if(obj.position.z > 10) obj.position.z -= wrapZ;
      }
    }

    // --- Sprites / Objs
    function makeEmojiSprite(emoji, size=256){
      const c=document.createElement('canvas'); c.width=c.height=size;
      const g=c.getContext('2d');
      g.clearRect(0,0,size,size);
      g.globalAlpha=0.18;
      g.fillStyle='#cfefff';
      g.beginPath(); g.arc(size/2,size/2,size*0.33,0,Math.PI*2); g.fill();
      g.globalAlpha=1;
      g.font=`${size*0.55}px system-ui, Apple Color Emoji, Segoe UI Emoji`;
      g.textAlign='center'; g.textBaseline='middle';
      g.fillText(emoji, size/2, size/2+8);
      const tex=new THREE.CanvasTexture(c);
      tex.colorSpace=THREE.SRGBColorSpace;
      const mat=new THREE.SpriteMaterial({ map:tex, transparent:true });
      const spr=new THREE.Sprite(mat);
      spr.scale.set(0.78,0.78,1);
      return spr;
    }
    function spawnObstacleVisual(){
      const box = new THREE.Mesh(
        new THREE.BoxGeometry(rnd(0.65,0.95), rnd(0.75,1.25), rnd(0.65,0.95)),
        new THREE.MeshStandardMaterial({ color:0x6b4b2b, roughness:0.9, metalness:0.02 })
      );
      box.castShadow=true; box.receiveShadow=true;
      return box;
    }
    function makeTurtle(){
      const g = new THREE.Group();
      const shell = new THREE.Mesh(
        new THREE.SphereGeometry(0.35, 18, 14),
        new THREE.MeshStandardMaterial({ color:0x1f6a3a, roughness:0.9, metalness:0.02 })
      );
      shell.scale.set(1.2,0.75,1.0);
      shell.position.y=0.35;
      shell.castShadow=true; shell.receiveShadow=true;
      g.add(shell);
      const head = new THREE.Mesh(
        new THREE.SphereGeometry(0.16, 16, 12),
        new THREE.MeshStandardMaterial({ color:0x2f8a4d, roughness:0.9, metalness:0.02 })
      );
      head.position.set(0,0.25,0.42);
      head.castShadow=true;
      g.add(head);
      return g;
    }
    function makeVerticalRing(){
      const ring = new THREE.Mesh(
        new THREE.TorusGeometry(0.55, 0.09, 14, 44),
        new THREE.MeshStandardMaterial({
          color:0xff4444,
          roughness:0.35,
          metalness:0.05,
          emissive:0x660000,
          emissiveIntensity:0.55
        })
      );
      ring.castShadow=true; ring.receiveShadow=true;
      return ring;
    }

    // Runner groups
    const runnerPivot = new THREE.Group(); scene.add(runnerPivot);
    const runnerCenter = new THREE.Group(); runnerCenter.position.set(0, 0.95, 0); runnerPivot.add(runnerCenter);
    const runnerModel = new THREE.Group(); runnerModel.position.set(0, -0.95, 0); runnerCenter.add(runnerModel);

    // Bubble (rimane)
    const bubble = new THREE.Mesh(
      new THREE.SphereGeometry(0.62, 24, 18),
      new THREE.MeshStandardMaterial({
        color:0x66ffcc, roughness:0.25, metalness:0.0,
        emissive:0x33ffaa, emissiveIntensity:0.7,
        transparent:true, opacity:0.22
      })
    );
    bubble.position.set(0, 0.95, 0);
    bubble.visible=false;
    runnerPivot.add(bubble);

    // GLTF
    const gltfLoader = new GLTFLoader();

    // ==== ANIM URLs ====
    const RUNNER_GLB_URL = './running.glb';
    const IDLE_URLS = [
      './DwarfIdle.glb',
      './WarriorIdle.glb',
      './HappyIdle.glb'
    ];
    const JUMP_URL  = './JumpOver.glb';
    const FLIP_URL  = './RunningForwardFlip.glb';
    const KICK_URL  = './SoccerKick.glb';
    const DANCE_URL = './HipHopDance.glb';
    const DIE_URL   = './SideHitDie.glb';

    // ==== Anim util ====
    function setShadows(root){
      root.traverse(o=>{
        if(o.isMesh){ o.castShadow=true; o.receiveShadow=true; }
      });
    }
    function stripRootMotion(clip){
      const c = clip.clone();
      const TH = 0.02;
      try{
        for(const t of c.tracks){
          const name = (t.name || '').toLowerCase();
          if(!name.endsWith('.position')) continue;
          const v = t.values;
          if(!v || v.length < 6) continue;
          let minX=Infinity, maxX=-Infinity, minZ=Infinity, maxZ=-Infinity;
          for(let i=0;i<v.length;i+=3){
            const x=v[i], z=v[i+2];
            if(x<minX) minX=x; if(x>maxX) maxX=x;
            if(z<minZ) minZ=z; if(z>maxZ) maxZ=z;
          }
          const rangeX=maxX-minX, rangeZ=maxZ-minZ;
          if(rangeX>TH || rangeZ>TH){
            const baseX=v[0], baseZ=v[2];
            for(let i=0;i<v.length;i+=3){
              v[i]=baseX;
              v[i+2]=baseZ;
            }
          }
        }
      }catch(err){}
      return c;
    }

    async function loadGLB(url){
      return new Promise((resolve,reject)=>{
        gltfLoader.load(url, resolve, undefined, reject);
      });
    }

    // ==== Animation Controller ====
    const anim = {
      mixer: null,
      actions: new Map(),
      current: null,
      mode: 'idle', // idle | run | dance | dead | oneShot
      idleNames: [],
      lastIdle: null,
      busyOneShot: false,
      queuedMode: null
    };

    function action(name){ return anim.actions.get(name) || null; }

    function fadeTo(name, {fade=0.18, loop=THREE.LoopRepeat, clamp=false, timeScale=1.0, reset=true} = {}){
      const a = action(name);
      if(!a) return null;

      a.enabled = true;
      a.setEffectiveTimeScale(timeScale);
      a.setEffectiveWeight(1.0);
      a.setLoop(loop, Infinity);
      a.clampWhenFinished = clamp;

      if(reset) a.reset();

      if(anim.current && anim.current !== a){
        anim.current.fadeOut(fade);
      }
      a.fadeIn(fade);
      a.play();
      anim.current = a;
      return a;
    }

    function playOneShot(name, {fade=0.12, timeScale=1.0} = {}){
      const a = action(name);
      if(!a) return false;
      anim.busyOneShot = true;

      // loop once
      a.enabled = true;
      a.setEffectiveTimeScale(timeScale);
      a.setEffectiveWeight(1.0);
      a.setLoop(THREE.LoopOnce, 1);
      a.clampWhenFinished = true;
      a.reset();

      if(anim.current && anim.current !== a) anim.current.fadeOut(fade);
      a.fadeIn(fade);
      a.play();
      anim.current = a;

      return true;
    }

    function pickIdle(){
      if(!anim.idleNames.length) return null;
      let tries=0;
      let name = anim.idleNames[rndi(0, anim.idleNames.length-1)];
      while(name === anim.lastIdle && tries++ < 5){
        name = anim.idleNames[rndi(0, anim.idleNames.length-1)];
      }
      anim.lastIdle = name;
      return name;
    }

    function setMode(mode){
      anim.queuedMode = null;
      anim.mode = mode;

      if(mode === 'idle'){
        const n = pickIdle();
        if(n) fadeTo(n, {fade:0.22, loop:THREE.LoopRepeat, clamp:false, timeScale:1.0});
      }else if(mode === 'run'){
        fadeTo('run', {fade:0.14, loop:THREE.LoopRepeat, clamp:false, timeScale:1.0});
      }else if(mode === 'dance'){
        fadeTo('dance', {fade:0.22, loop:THREE.LoopRepeat, clamp:false, timeScale:1.0});
      }else if(mode === 'dead'){
        // lo gestiamo con oneShot die
      }
    }

    function queueModeAfterOneShot(mode){
      anim.queuedMode = mode;
    }

    function onAnimFinished(){
      anim.busyOneShot = false;
      if(anim.queuedMode){
        const m = anim.queuedMode;
        anim.queuedMode = null;
        setMode(m);
      }else{
        // se siamo in idle e finisce qualcosa, torna idle random
        if(anim.mode === 'idle') setMode('idle');
        if(anim.mode === 'run') setMode('run');
        if(anim.mode === 'dance') setMode('dance');
      }
    }

    // ==== Load character + animations ====
    async function loadCharacterAndAnims(){
      // base model + run
      const base = await loadGLB(RUNNER_GLB_URL);
      const model = base.scene;
      model.position.set(0,0,0);
      model.scale.setScalar(0.95);
      model.rotation.y = Math.PI;
      setShadows(model);

      // piedi a terra
      {
        const box = new THREE.Box3().setFromObject(model);
        const lift = -box.min.y;
        model.position.y += lift + 0.01;
      }

      while(runnerModel.children.length) runnerModel.remove(runnerModel.children[0]);
      runnerModel.add(model);

      // mixer sul model
      anim.mixer = new THREE.AnimationMixer(model);
      anim.mixer.addEventListener('finished', onAnimFinished);

      // run clip
      const runClip = (base.animations||[])[0];
      if(runClip){
        const fixed = stripRootMotion(runClip);
        const a = anim.mixer.clipAction(fixed);
        anim.actions.set('run', a);
      }

      // helper loader per un clip
      async function loadClip(url, key){
        try{
          const g = await loadGLB(url);
          const clip = (g.animations||[])[0];
          if(!clip) return;
          const fixed = stripRootMotion(clip);
          const a = anim.mixer.clipAction(fixed);
          anim.actions.set(key, a);
          return true;
        }catch(e){
          console.warn('Anim load fail', url, e);
          return false;
        }
      }

      // idles
      for(let i=0;i<IDLE_URLS.length;i++){
        const key = `idle_${i}`;
        const ok = await loadClip(IDLE_URLS[i], key);
        if(ok) anim.idleNames.push(key);
      }

      await loadClip(JUMP_URL,  'jump');
      await loadClip(FLIP_URL,  'flip');
      await loadClip(KICK_URL,  'kick');
      await loadClip(DANCE_URL, 'dance');
      await loadClip(DIE_URL,   'die');

      // start in idle
      setMode('idle');
    }

    // Game data (come tuo)
    const EMOJIS = ["‚ú®","üçÄ","üíé","‚ö°Ô∏è","üåà","üçã","‚≠êÔ∏è","üçì","ü•ù"];
    const FOOD   = ["üçï","üçî","üçü","üåÆ","üç©","üç™","üç∞","üçú","üç£","ü•ê"];
    const HEART  = "‚ù§Ô∏è";
    const MAGNET = "üß≤";

    const BEST_KEY='jungle_runner_best_v3';
    const loadBest=()=>Number(localStorage.getItem(BEST_KEY)||'0')||0;
    const saveBest=(v)=>localStorage.setItem(BEST_KEY,String(v));

    const game = {
      state: 'title', // title | running | stopped | dead
      lane:1,
      y:0, vy:0, jumping:false,

      baseSpeed: 12.9,
      score:0, coins:0, best: loadBest(),

      maxLives:5,
      lives:3,

      ringCount:0,
      foodCount:0,
      foodHistory:[],

      invincibleT:0,
      foodBoostT:0,
      ringBoostT:0,
      magnetT:0,

      entities:[],
      spawnT:0.30,

      stopped:false,
      stopBlend:0.0,

      // ring action window
      flipping:false,
      flipT:0
    };

    bestEl.textContent = String(game.best);

    function hpString(){
      let s="";
      for(let i=0;i<game.maxLives;i++) s += (i<game.lives) ? "‚ù§Ô∏è" : "üñ§";
      return s;
    }
    function refreshFoodUI(){
      foodStack.innerHTML = "";
      const show = game.foodHistory.slice(-6).reverse();
      for(const emo of show){
        const d=document.createElement('div');
        d.className='foodItem';
        d.textContent=emo;
        foodStack.appendChild(d);
      }
      foodCountEl.textContent = String(game.foodCount);
    }

    function setBoostUI(){
      const t = Math.max(game.foodBoostT, game.ringBoostT);
      if(t <= 0){
        pillBoost.style.display='none';
        boostBar.style.width='0%';
        return;
      }
      pillBoost.style.display='inline-flex';
      const both = (game.foodBoostT>0 && game.ringBoostT>0);
      if(both){ boostIcon.textContent='üî•'; boostName.textContent='MEGA'; }
      else if(game.foodBoostT>0){ boostIcon.textContent='üçî'; boostName.textContent='FOOD'; }
      else { boostIcon.textContent='‚≠ïÔ∏è'; boostName.textContent='RING'; }
      const dur = 10.0;
      const pct = clamp((t/dur)*100,0,100);
      boostBar.style.width = pct.toFixed(1)+'%';
    }

    function clearEntities(){
      for(const e of game.entities) scene.remove(e.obj);
      game.entities.length=0;
    }

    function resetRun(){
      game.lane=1;
      game.y=0; game.vy=0; game.jumping=false;

      game.score=0; game.coins=0;
      game.ringCount=0;
      game.foodCount=0; game.foodHistory=[];
      refreshFoodUI();

      game.invincibleT=0;
      game.foodBoostT=0;
      game.ringBoostT=0;
      game.magnetT=0;

      game.spawnT=0.30;
      clearEntities();

      game.lives=3;

      game.stopped = false;
      game.stopBlend = 0.0;
      stopBtn.classList.remove('on');
      stopLbl.textContent = 'STOP';

      game.flipping=false; game.flipT=0;
    }

    function enterTitleUI(){
      game.state = 'title';
      startOverlay.classList.remove('hidden');
      startTitle.textContent = 'Jungle Emoji Runner';
      startSub.innerHTML = `Premi <b>Start</b> per iniziare. <b>Stop</b> ferma il traffico (idle random).<br/><span style="opacity:.85">Dance = HipHopDance.</span>`;
      startBtn.textContent = '‚ñ∂Ô∏è Start';
      danceBtn.classList.remove('hidden');

      // nascondo bottoni gameplay
      floatBtns.classList.add('hidden');
      stopWrap.classList.add('hidden');
      pauseBtn.classList.add('hidden');

      // anim idle
      setMode('idle');
    }

    function enterRunningUI(){
      game.state = 'running';
      startOverlay.classList.add('hidden');

      floatBtns.classList.remove('hidden');
      stopWrap.classList.remove('hidden');
      pauseBtn.classList.remove('hidden');

      setMode('run');
    }

    function enterStoppedUI(){
      game.state = 'stopped';
      setMode('idle');
    }

    function enterDeadUI(){
      game.state = 'dead';
      // mostra overlay come ‚Äúrestart‚Äù
      startOverlay.classList.remove('hidden');
      startTitle.textContent = 'GAME OVER';
      startSub.innerHTML = `Hai fatto <b>${Math.floor(game.score)}</b> punti ‚Ä¢ Emoji <b>${game.coins}</b>`;
      startBtn.textContent = 'üîÅ Restart';
      danceBtn.classList.add('hidden');

      // stop diventa restart
      stopLbl.textContent = 'RESTART';

      // anim die one-shot
      if(playOneShot('die', {fade:0.10, timeScale:1.0})){
        anim.mode = 'dead';
      }
    }

    function setStop(on){
      if(game.state !== 'running' && game.state !== 'stopped') return;

      game.stopped = !!on;
      stopBtn.classList.toggle('on', game.stopped);

      if(game.stopped){
        stopLbl.textContent = 'GO';
        enterStoppedUI();
      }else{
        stopLbl.textContent = 'STOP';
        game.state = 'running';
        setMode('run');
      }
    }

    function loseLife(){
      if(game.invincibleT>0) return;
      game.lives = Math.max(0, game.lives-1);
      sfx.hit();
      if(game.lives<=0){
        if(game.score>game.best){ game.best=Math.floor(game.score); saveBest(game.best); }
        enterDeadUI();
      }
    }

    // Spawns (solo corsie 0..2) - come tuo, ring da 2 e vicini
    function spawnRow(){
      const z0 = -60 - rnd(0,18);

      const blocked=new Set();
      const p0 = 0.22;
      let oCount = 0;
      if(Math.random() >= p0){
        const p2 = 0.38;
        oCount = (Math.random() < p2) ? 2 : 1;
      }
      while(blocked.size<oCount) blocked.add(rndi(0,2));

      const coinLanes=new Set();
      const cCount = rndi(1,2);
      while(coinLanes.size<cCount) coinLanes.add(rndi(0,2));

      blocked.forEach(l=>{
        const obj = spawnObstacleVisual();
        obj.position.set(lanesX[l], 0.65, z0);
        scene.add(obj);
        game.entities.push({ type:'obst', lane:l, z:z0, obj });
      });

      coinLanes.forEach(l=>{
        const spr = makeEmojiSprite(EMOJIS[rndi(0,EMOJIS.length-1)]);
        spr.position.set(lanesX[l], 1.10, z0 - rnd(0,2.8));
        scene.add(spr);
        game.entities.push({ type:'coin', lane:l, z:spr.position.z, obj:spr });
      });

      if(Math.random() < 0.30){
        const lane=rndi(0,2);
        const emo = FOOD[rndi(0,FOOD.length-1)];
        const spr = makeEmojiSprite(emo);
        spr.position.set(lanesX[lane], 1.15, z0 - rnd(1,6));
        spr.scale.set(0.82,0.82,1);
        scene.add(spr);
        game.entities.push({ type:'food', lane, z:spr.position.z, obj:spr, emo });
      }

      if(Math.random() < 0.10){
        const lane=rndi(0,2);
        const spr = makeEmojiSprite(MAGNET);
        spr.position.set(lanesX[lane], 1.15, z0 - rnd(1,7));
        spr.scale.set(0.90,0.90,1);
        scene.add(spr);
        game.entities.push({ type:'magnet', lane, z:spr.position.z, obj:spr });
      }

      // cuori: solo se lives < 5 e pi√π rari
      if(game.lives < game.maxLives && Math.random() < 0.035){
        const lane=rndi(0,2);
        const spr = makeEmojiSprite(HEART);
        spr.position.set(lanesX[lane], 1.15, z0 - rnd(1,6));
        spr.scale.set(0.92,0.92,1);
        scene.add(spr);
        game.entities.push({ type:'heart', lane, z:spr.position.z, obj:spr });
      }

      // tartarughe: 1 per corsia massimo, distanziate ‚Äî qui semplice: poche
      if(Math.random() < 0.16){
        const lane=rndi(0,2);
        const t = makeTurtle();
        t.position.set(lanesX[lane], 0, z0 - rnd(2,10));
        t.traverse(o=>{ if(o.isMesh){ o.castShadow=true; o.receiveShadow=true; }});
        scene.add(t);
        game.entities.push({ type:'turtle', lane, z:t.position.z, obj:t, state:'idle', projT:0 });
      }

      // RING: ora 2 e pi√π vicini
      if(Math.random() < 0.26){
        const lane = rndi(0,2);
        const baseZ = z0 - rnd(2,9);
        const gap = 0.75;
        for(let k=0;k<2;k++){
          const ring = makeVerticalRing();
          ring.position.set(lanesX[lane], 0.55, baseZ - k*gap);
          scene.add(ring);
          game.entities.push({ type:'ring', lane, z:ring.position.z, obj:ring });
        }
      }
    }

    // Controls
    function moveLane(dir){
      if(game.state !== 'running') return;
      game.lane = clamp(game.lane+dir, 0, 3);
      sfx.lane();
    }

    function jump(){
      if(game.state !== 'running') return;
      if(game.stopped) return;
      if(anim.busyOneShot) return;

      if(!game.jumping && game.y>=-0.001){
        game.jumping=true;
        game.vy = -7.8;
        sfx.jump();

        // anim jump
        if(playOneShot('jump', {fade:0.08, timeScale:1.05})){
          queueModeAfterOneShot('run');
          anim.mode = 'oneShot';
        }
      }
    }

    window.addEventListener('keydown', (e)=>{
      const k=e.key.toLowerCase();
      if(k==='arrowleft') moveLane(-1);
      if(k==='arrowright') moveLane(1);
      if(k==='arrowup' || k===' ') jump();
      if(k==='p'){
        // pausa: la lasciamo semplice (non cambia stato anim)
        if(game.state === 'running'){ game.state='stopped'; setStop(true); }
        else if(game.state === 'stopped'){ setStop(false); }
      }
    });

    let touchStart=null;
    renderer.domElement.addEventListener('pointerdown',(e)=>{
      initAudio();
      renderer.domElement.setPointerCapture(e.pointerId);
      touchStart={x:e.clientX,y:e.clientY,t:performance.now()};
    });
    renderer.domElement.addEventListener('pointerup',(e)=>{
      if(!touchStart) return;
      const dx=e.clientX-touchStart.x, dy=e.clientY-touchStart.y;
      const adx=Math.abs(dx), ady=Math.abs(dy);
      touchStart=null;
      const min=30;
      if(adx<min && ady<min) return;
      if(adx>ady) moveLane(dx>0?1:-1);
      else { if(dy<0) jump(); }
    });

    // Start/Dance buttons
    startBtn.addEventListener('click', ()=>{
      initAudio();
      if(game.state === 'dead'){
        // restart
        resetRun();
        stopLbl.textContent = 'STOP';
        enterRunningUI();
        return;
      }
      if(game.state === 'title'){
        resetRun();
        enterRunningUI();
        return;
      }
      // se sei in stopped -> torna running
      if(game.state === 'stopped'){
        setStop(false);
      }
    });

    danceBtn.addEventListener('click', ()=>{
      initAudio();
      if(game.state === 'title'){
        setMode('dance');
        game.state = 'title'; // resta title ma in dance
      }
    });

    // STOP button
    stopBtn.addEventListener('click', ()=>{
      initAudio();
      if(game.state === 'dead'){
        // restart anche da qui
        resetRun();
        enterRunningUI();
        return;
      }
      if(game.state !== 'running' && game.state !== 'stopped') return;
      setStop(!game.stopped);
    });

    // Nascondo vecchi bottoni settings/pause/home (li lasciamo, ma non li usiamo qui)
    btnSettings?.addEventListener('click', ()=>{ initAudio(); });
    btnPause?.addEventListener('click', ()=>{ initAudio(); });
    btnHome?.addEventListener('click', ()=>{ initAudio(); });

    // Camera state
    let camZ = baseCamZ;
    let camY = 4.6;
    let camFov = baseFov;
    let camX = 0;
    let camRoll = 0;

    // Update loop
    let tPrev=performance.now();

    function update(dt, tNow){
      // Mixer SEMPRE aggiornato (idle anche quando non corre)
      if(anim.mixer){
        anim.mixer.update(dt);
      }

      // gestione flip window
      if(game.flipping){
        game.flipT -= dt;
        if(game.flipT <= 0){
          game.flipping = false;
        }
      }

      // se non running, niente gameplay (ma scena/anim s√¨)
      if(game.state !== 'running' && game.state !== 'stopped') return;

      const stopTarget = game.stopped ? 1.0 : 0.0;
      game.stopBlend = damp(game.stopBlend, stopTarget, 8, dt);
      const trafficMul = (1.0 - game.stopBlend);

      // timer power
      if(game.invincibleT>0) game.invincibleT = Math.max(0, game.invincibleT-dt*trafficMul);
      if(game.foodBoostT>0) game.foodBoostT = Math.max(0, game.foodBoostT-dt*trafficMul);
      if(game.ringBoostT>0) game.ringBoostT = Math.max(0, game.ringBoostT-dt*trafficMul);
      if(game.magnetT>0)   game.magnetT   = Math.max(0, game.magnetT-dt*trafficMul);

      const foodMul = (game.foodBoostT>0) ? 3.0 : 1.0;
      const ringMul = (game.ringBoostT>0) ? 3.0 : 1.0;
      const both = (game.foodBoostT>0 && game.ringBoostT>0);
      const speedMul = foodMul * ringMul * (both ? 1.06 : 1.0);
      const speed = game.baseSpeed * speedMul * trafficMul;

      // gravity
      if(!game.stopped){
        const g=22.0;
        game.vy += g*dt;
        game.y  += game.vy*dt;
        if(game.y>0){ game.y=0; game.vy=0; game.jumping=false; }
      }

      // player pos
      runnerPivot.position.x = lanesX[game.lane<=2?game.lane:2];
      runnerPivot.position.y = (-game.y);

      // contact shadow
      const h = runnerPivot.position.y;
      const s = 1.10 + clamp(h*0.65, 0, 0.85);
      contact.position.x = runnerPivot.position.x;
      contact.scale.set(s,s,1);
      contact.material.opacity = clamp(0.55 - h*0.24, 0.10, 0.55);

      // road scroll
      const scroll = speed*dt;
      highwayTex.offset.y -= scroll*0.085;

      for(const mesh of segments){
        mesh.position.z += scroll;
        if(mesh.position.z > segLen) mesh.position.z -= segLen*segCount;
      }
      loopJungle(scroll);

      // spawn
      if(!game.stopped){
        game.spawnT -= dt;
        if(game.spawnT<=0){
          spawnRow();
          game.spawnT = rnd(0.40, 0.75);
        }
      }

      // entities move
      const magnetOn = game.magnetT > 0;
      for(const e of game.entities){
        e.z += scroll;
        e.obj.position.z = e.z;

        if(e.type==='turtle' && e.state==='projectile'){
          e.projT -= dt*trafficMul;
          e.z -= (speed*3.4)*dt;
          e.obj.position.z = e.z;
          if(e.projT <= 0) e.projT = 0;
        }

        if(magnetOn && (e.type==='coin'||e.type==='food'||e.type==='heart'||e.type==='magnet')){
          const dx = lanesX[game.lane] - e.obj.position.x;
          const dz = (0 - e.z);
          const dist = Math.hypot(dx*2.2, dz);
          if(dist < 12.0){
            e.obj.position.x += dx * dt * (5.6*(1-dist/12.0));
            if(e.obj.position.y < 1.1) e.obj.position.y += dt*0.6;
          }
        }
      }

      // despawn
      for(let i=game.entities.length-1;i>=0;i--){
        const e = game.entities[i];
        if(e.type==='turtle' && e.state==='projectile' && e.projT<=0){
          scene.remove(e.obj); game.entities.splice(i,1);
          continue;
        }
        if(e.z > 6.0){
          scene.remove(e.obj);
          game.entities.splice(i,1);
        }
        if(e.type==='turtle' && e.state==='projectile' && e.z < -140){
          scene.remove(e.obj); game.entities.splice(i,1);
        }
      }

      // collisions solo se running e non stopped
      if(!game.stopped){
        const ex = lanesX[game.lane];
        const py = runnerPivot.position.y + 0.95;

        function collideAtX(e){
          const dz = Math.abs(e.z - 0.25);
          const dx = Math.abs(e.obj.position.x - ex);
          const ey = (e.obj.position.y ?? 0);
          const dy = Math.abs(ey - py);
          return (dz < 0.75 && dx < 0.60 && dy < 1.05);
        }
        function collideTurtle(e){
          const dz = Math.abs(e.z - 0.35);
          const dx = Math.abs(e.obj.position.x - ex);
          return (dz < 1.05 && dx < 0.72);
        }

        // auto-trigger flip sui ring (quando ring arriva)
        if(!game.flipping && !anim.busyOneShot && game.y===0){
          for(const e of game.entities){
            if(e.type!=='ring') continue;
            if(e.lane !== game.lane) continue;
            if(Math.abs(e.z - 0.25) < 2.35){
              // flip!
              if(playOneShot('flip', {fade:0.06, timeScale:1.08})){
                queueModeAfterOneShot('run');
                game.flipping = true;
                game.flipT = 0.55;
              }
              break;
            }
          }
        }

        // turtle projectile demolition
        for(const e of game.entities){
          if(e.type==='turtle' && e.state==='projectile'){
            for(let j=game.entities.length-1;j>=0;j--){
              const o = game.entities[j];
              if(o.type!=='obst') continue;
              if(o.lane!==e.lane) continue;
              if(Math.abs(o.z - e.z) < 1.35){
                scene.remove(o.obj);
                game.entities.splice(j,1);
              }
            }
          }
        }

        for(let i=game.entities.length-1;i>=0;i--){
          const e=game.entities[i];

          if(e.type==='ring'){
            if(!collideAtX(e)) continue;

            // ring prende solo se stai flippando
            if(!game.flipping) continue;

            game.ringCount += 1;
            scene.remove(e.obj); game.entities.splice(i,1);
            sfx.ring();
            continue;
          }

          if(e.type==='turtle' && e.state==='idle'){
            if(collideTurtle(e)){
              // kick + projectile
              if(!anim.busyOneShot){
                if(playOneShot('kick', {fade:0.08, timeScale:1.0})){
                  queueModeAfterOneShot('run');
                }
              }
              e.state='projectile';
              e.projT = 2.8;
              sfx.boost();
            }
            continue;
          }

          if(!collideAtX(e)) continue;

          if(e.type==='coin'){
            game.coins += 1;
            game.score += 28;
            scene.remove(e.obj); game.entities.splice(i,1);
            sfx.coin();
            continue;
          }

          if(e.type==='food'){
            game.foodCount += 1;
            game.foodHistory.push(e.emo);
            refreshFoodUI();
            scene.remove(e.obj); game.entities.splice(i,1);
            sfx.food();
            if(game.foodCount >= 10){
              game.foodBoostT = 10.0;
              game.invincibleT = Math.max(game.invincibleT, 10.0);
              bubble.visible=true;
              game.foodCount = 0;
              game.foodHistory = [];
              refreshFoodUI();
              sfx.boost();
            }
            continue;
          }

          if(e.type==='heart'){
            if(game.lives < game.maxLives){
              game.lives = Math.min(game.maxLives, game.lives+1);
              sfx.boost();
            }
            scene.remove(e.obj); game.entities.splice(i,1);
            continue;
          }

          if(e.type==='magnet'){
            game.magnetT = 8.0;
            scene.remove(e.obj); game.entities.splice(i,1);
            sfx.magnet();
            continue;
          }

          if(e.type==='obst'){
            const inv = (game.invincibleT>0);
            if(inv){
              scene.remove(e.obj); game.entities.splice(i,1);
            }else{
              scene.remove(e.obj); game.entities.splice(i,1);
              loseLife();
            }
            continue;
          }
        }

        // score tick
        game.score += (18 * speedMul) * dt;
        if(game.score>game.best){ game.best=Math.floor(game.score); saveBest(game.best); }
      }

      // HUD
      scoreEl.textContent = String(Math.floor(game.score));
      coinsEl.textContent = String(game.coins);
      bestEl.textContent  = String(game.best);
      ringsEl.textContent = String(game.ringCount);
      hpTxt.textContent   = hpString();
      magTxt.textContent  = `üß≤ ${game.magnetT>0 ? game.magnetT.toFixed(1) : '0'}`;

      setBoostUI();
      if(bubble.visible){ bubble.material.opacity = 0.18 + 0.06*Math.sin(tNow*0.01); }
    }

    function animate(tNow){
      const dt=Math.min(0.030,(tNow-tPrev)/1000);
      tPrev=tNow;

      update(dt,tNow);

      // camera base (come tua)
      const inAir = (game.y < -0.01) || game.jumping;
      const bothBoost = (game.foodBoostT>0 && game.ringBoostT>0);
      const anyBoost = (game.foodBoostT>0 || game.ringBoostT>0);

      const fovBoost = bothBoost ? 7 : (anyBoost ? 5 : (inAir ? -2 : 0));
      const zBoost   = bothBoost ? 0.9 : (anyBoost ? 0.5 : 0.0);

      const targetFov = clamp(baseFov + fovBoost, 30, 110);
      const targetZ   = clamp(baseCamZ + zBoost, 2, 15);

      const lookAtY = lerp(0.05, 1.45, framing);
      const lookAtZ = lerp(-22.0, -38.0, framing);
      const camYBase = lerp(3.9, 5.8, framing);

      camFov = damp(camFov, targetFov, 8, dt);
      camZ   = damp(camZ,   targetZ,   8, dt);
      camY   = damp(camY,   camYBase + (bothBoost?0.10:0), 8, dt);

      camera.fov = camFov;
      camera.updateProjectionMatrix();

      const targetCamX = clamp(runnerPivot.position.x * 0.35, -1.2, 1.6);
      camX = damp(camX, targetCamX, 6, dt);

      // micro shake boost (sempre leggero)
      let shakeX = 0, shakeY = 0;
      if(anyBoost){
        const intensity = bothBoost ? 0.020 : 0.012;
        shakeX = Math.sin(tNow*0.020) * intensity;
        shakeY = Math.sin(tNow*0.027) * (intensity*0.55);
      }

      const bob = Math.sin(tNow*0.0020) * 0.005;
      camera.position.set(camX + shakeX, camY + bob + shakeY, camZ);
      camera.rotation.z = camRoll;
      camera.lookAt(camX*0.35, lookAtY, lookAtZ);

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    function onResize(){
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onResize);

    // start
    (async ()=>{
      refreshFoodUI();
      hpTxt.textContent = hpString();

      await loadCharacterAndAnims();

      // all'avvio: scena visibile + idle random + overlay start
      resetRun();
      enterTitleUI();

      requestAnimationFrame(animate);
    })();
  </script>
</body>
</html>