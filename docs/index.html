
<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Jungle Emoji Runner (Three.js)</title>
  <style>
    :root{
      color-scheme: dark;

      /* ===== SCALE richieste ===== */
      --menuScale: 1.50; /* Home, Impostazioni, Avvia, Dance, foodCount, foodItem (+50%) */
      --hudScale:  1.40; /* Score, Emoji, Anelli, Vita, Magnete, Boost, Cibo Boost (+40%) */
      --hudW:      0.70; /* -30% larghezza (0.70) */
      --hudPillH: 12px; /* altezza base di TUTTE le pillole HUD */
      --camOffsetY: 12px; /* ‚Üì aumenta questo valore se la vuoi ancora pi√π in basso */
      /* barra base */
      --hud-bar-w: 60px;
    }

    html,body{
      height:100%;
      margin:0;
      background:#040805;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      overflow:hidden;
    }
    canvas{display:block;touch-action:none;}

    /* =========================================================
       PILL FX
       ========================================================= */
    .pillFx{
      position:relative;
      border-radius:999px;
      color:#eaf1ff;
      background: linear-gradient(180deg, rgba(60,90,140,.28), rgba(12,16,26,.64));
      border:1px solid rgba(170,210,255,.22);
      backdrop-filter: blur(6px) saturate(1.2);
      -webkit-backdrop-filter: blur(6px) saturate(1.2);
      box-shadow:
        0 7px 22px rgba(0,0,0,.50),
        0 0 0 1px rgba(95,160,255,.10),
        0 0 9px rgba(110,175,255,.18),
        inset 0 1px 0 rgba(255,255,255,.13),
        inset 0 -1px 0 rgba(0,0,0,.28);
      -webkit-tap-highlight-color: transparent;
    }
    .pillFx::after{
      content:"";
      position:absolute;
      inset:-1px;
      border-radius:999px;
      pointer-events:none;
      background: radial-gradient(120% 140% at 20% 10%,
        rgba(145,205,255,.32),
        rgba(90,150,255,.10) 38%,
        rgba(0,0,0,0) 72%
      );
      filter: blur(.55px);
      opacity:.85;
      mix-blend-mode: screen;
    }
    .pillFx::before{
      content:"";
      position:absolute;
      inset:0;
      border-radius:999px;
      pointer-events:none;
      background: linear-gradient(180deg, rgba(255,255,255,.11), rgba(255,255,255,0) 55%);
      opacity:.70;
    }
    button.pillFx:active{ transform:scale(.985); }

    /* =========================================================
       ICON BASE (poi vengono scalate per zona)
       ========================================================= */
    .ico{
      width:11px;
      height:11px;
      display:inline-block;
      flex:0 0 auto;
      filter: drop-shadow(0 5px 8px rgba(0,0,0,.55));
    }
    .icoSm{ width:9px; height:9px; }

/* =========================================================
   HUD (sinistra): +40% e -30% larghezza
   + TOP RIGHT (Home/Impostazioni) sorelle HUD
   + LIFE pill fix iOS
   ========================================================= */

/* HUD wrapper */
.hudWrap{
  position:fixed;
  top:calc(5px * var(--menuScale));
  left:calc(8px * var(--hudScale));
  z-index:28;
  pointer-events:none;

  width:min(
    calc(230px * var(--hudScale) * var(--hudW)),
    calc(100vw - calc(16px * var(--hudScale)))
  );
}

.hudCard{ pointer-events:none; background:transparent; border:none; padding:0; margin:0; }

.hudGrid{
  display:grid;
  grid-template-columns: minmax(0,1fr) minmax(0,1fr);
  gap:calc(6px * var(--hudScale));
  align-items:start;
}

/* PILL HUD base (altezza unica via --hudPillH) */
.hudP{
  pointer-events:none;
  padding:calc(4px * var(--hudScale)) calc(6px * var(--hudScale));
  border-radius:999px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:calc(5px * var(--hudScale));
  min-width:0;
  min-height:calc(var(--hudPillH) * var(--hudScale));
  line-height:1;
  overflow:hidden;
}

.hudHalf{ grid-column: span 1; }
.hudFull{ grid-column: 1 / -1; }

.hudL{
  display:flex;
  align-items:center;
  gap:calc(5px * var(--hudScale));
  min-width:0;
  line-height:1;
  overflow:hidden;
}

.hudT{
  font-weight:950;
  font-size:calc(7px * var(--hudScale));
  white-space:nowrap;
  line-height:1;
  overflow:hidden;
  text-overflow:ellipsis;
}

.hudV{
  font-weight:950;
  font-size:calc(8px * var(--hudScale));
  white-space:nowrap;
  line-height:1;

  display:flex;
  align-items:center;
  justify-content:center;
  gap:calc(3px * var(--hudScale));

  overflow:hidden;
  text-overflow:ellipsis;
}

/* icone HUD */
.hudWrap .ico{
  width:calc(11px * var(--hudScale));
  height:calc(11px * var(--hudScale));
}

/* TOP RIGHT: Home + Impostazioni = stessa altezza delle HUD */
.topLeftBtns{
  position:fixed;
  top:calc(5px * var(--menuScale));
  right:calc(8px * var(--hudScale));
  z-index:35;
  pointer-events:none;
}

.topLeftBtns .btnGroup.pillFx{
  pointer-events:auto;
  display:flex;
  align-items:center;
  justify-content:space-between;

  /* ‚úÖ stesso ‚Äúpeso‚Äù delle HUD pill */
  min-height:calc(var(--hudPillH) * var(--hudScale));
  padding:calc(4px * var(--hudScale)) calc(6px * var(--hudScale));
  box-sizing:border-box;

  /* larghezza come avevi deciso tu */
  width:calc(66px * var(--hudScale));
  flex:0 0 auto;

  gap:calc(6px * var(--hudScale));
}

.topLeftBtns .btnSub{
  pointer-events:auto;
  border:none;
  background:transparent;
  padding:0;
  margin:0;

  /* ‚úÖ stessa altezza della pillola */
  min-height:calc(var(--hudPillH) * var(--hudScale));
  height:calc(var(--hudPillH) * var(--hudScale));
  display:flex;
  align-items:center;
  justify-content:center;

  border-radius:999px;
}

/* icone +25% come volevi */
.topLeftBtns .btnSub .ico{
  width:calc(13px * var(--hudScale) * 1.25);
  height:calc(13px * var(--hudScale) * 1.25);
}

/* =========================================================
   LIFE: gemella di Rings + cuori centrati + iOS emoji fix
   ========================================================= */
.lifePill{
  display:flex;
  align-items:center;
  justify-content:center;
}

/* gemella di Rings: niente colonna sinistra */
.lifePill .hudL{ display:none; }

/* cuori centrati */
.lifePill .hudV{
  flex:1;
  width:100%;
  display:flex;
  align-items:center;
  justify-content:center;
  line-height:1;
}

/* iPhone: blocca metriche ‚Äúalte‚Äù emoji */
#hpTxt{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  width:100%;
  white-space:nowrap;
  line-height:1;
  font-size:calc(8px * var(--hudScale));
}

/* iPhone: emoji hearts hanno metriche pi√π ‚Äúalte‚Äù -> le blocchiamo */
#hpTxt{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  white-space:nowrap;
  line-height:1;

  /* chiave: non far ‚Äúalzare‚Äù la pillola */
  font-size: calc(8px * var(--hudScale));
}

/* üîí FIX DEFINITIVO: Vita gemella di Rings */
.lifePill .hudL{ 
  display:none; 
}

.lifePill .hudV{ 
  flex:1; 
}

#hpTxt{ 
  width:100%; 
  justify-content:center; 
}


    /* =========================================================
       BAR ROW (Magnete/Boost/FoodBoost) con -30% larghezza
       ========================================================= */
    .hudBarRow{
      display:grid;
      grid-template-columns: auto calc(var(--hud-bar-w) * var(--hudScale) * var(--hudW)) auto;
      align-items:center;
      gap:calc(5px * var(--hudScale));
      min-width:0;
      width:100%;
      line-height:1;
    }
    .hudBar{
      height:calc(3px * var(--hudScale));
      width:calc(var(--hud-bar-w) * var(--hudScale) * var(--hudW));
      min-width:calc(var(--hud-bar-w) * var(--hudScale) * var(--hudW));
      max-width:calc(var(--hud-bar-w) * var(--hudScale) * var(--hudW));
      border-radius:999px;
      background:rgba(255,255,255,.12);
      overflow:hidden;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08);
    }
    .hudBar>i{
      display:block;height:100%;width:0%;
      background:rgba(200,210,255,.88);
      box-shadow: 0 0 7px rgba(140,200,255,.22);
    }

    #pillBoost #boostIcon{
      font-size:calc(9px * var(--hudScale));
      line-height:1;
      display:inline-block;
    }



    /* =========================================================
   DEBUG BUTTON ‚Üí sotto Magnete
   ========================================================= */

.debugRow{
  pointer-events:auto;
  display:flex;
  justify-content:flex-start;

  margin-top:calc(6px * var(--hudScale)); /* spazio sotto Magnete */
}

.dbgBtn{
  pointer-events:auto;
  border:none;
  background:transparent;
  cursor:pointer;
  user-select:none;

  /* stessa altezza delle HUD pill */
  height:calc(var(--hudPillH) * var(--hudScale));
  padding:calc(4px * var(--hudScale)) calc(6px * var(--hudScale));

  border-radius:999px;

  display:flex;
  align-items:center;
  justify-content:center;
}
    .dbgBtn .ico{
      width:calc(10px * var(--menuScale) * 1.25);
      height:calc(10px * var(--menuScale) * 1.25);
    }

    /* =========================================================
       Start/Dance
       ========================================================= */
    .rightStack{
      position:fixed;
      right:calc(6px * var(--menuScale));
      bottom: calc(calc(8px * var(--menuScale)) + env(safe-area-inset-bottom, 0px) + calc(22px * var(--menuScale)));
      z-index:30;
      display:flex;
      flex-direction:column;
      gap:calc(5px * var(--menuScale));
      pointer-events:auto;
      align-items:flex-end;
    }

    .bigBtn{
      pointer-events:auto;
      position:relative;

      width:calc(70px * var(--menuScale) * 0.75);
      height:calc(20px * var(--menuScale) * 1.50);

      border-radius:999px;
      font-weight:950;
      font-size:calc(7px * var(--menuScale) * 1.125);

      letter-spacing:.25px;

      display:flex;
      align-items:center;
      justify-content:center;
      gap:0;

      color:#eaf1ff;
      background:transparent;
      border:none;
      line-height:1;
      text-align:center;
    }

    .bigBtn .centerLbl{
      width:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      line-height:1;
      text-transform:uppercase;
    }
    
    /* =========================================================
   BOOST ROW (conteggio + pulsante)
   ========================================================= */
.boostRow{
  display:flex;
  align-items:center;
  gap:calc(5px * var(--menuScale));
  pointer-events:auto;
}

/* pillolina stretta (stessa altezza del bigBtn) */
.miniBtn{
  pointer-events:auto;
  border:none;
  background:transparent;
  cursor:pointer;
  user-select:none;

  height:calc(20px * var(--menuScale) * 1.50);
  width:calc(28px * var(--menuScale));         /* pi√π stretta */
  border-radius:999px;

  display:flex;
  align-items:center;
  justify-content:center;

  padding:0;
  line-height:1;
}

.miniLbl{
  font-weight:950;
  font-size:calc(7px * var(--menuScale) * 1.10);
  line-height:1;
}

/* stato disabilitato (quando boost attivo) */
.isDisabled{
  opacity:.55;
  filter:saturate(.85);
  pointer-events:none;
}

/* animazione conteggio boost */
@keyframes boostPulse{
  0%   { transform:scale(1);   }
  35%  { transform:scale(1.12);}
  100% { transform:scale(1);   }
}
.boostPulse{
  animation: boostPulse .28s ease;
}

/* =========================================================
   ‚ú® MAGIC GLOW (bordo animato)
   ========================================================= */
.hasMagic{ position:relative; overflow:visible; }
.hasMagic > *{ position:relative; z-index:2; } /* testo sopra */

.magicFx{
  position:absolute;
  inset:-7px;
  border-radius:999px;
  pointer-events:none;
  z-index:1;

  /* anello ‚Äúmagico‚Äù */
  background:
    radial-gradient(60% 80% at 30% 20%, rgba(180,240,255,.55), rgba(0,0,0,0) 60%),
    conic-gradient(
      rgba(120,210,255,0),
      rgba(160,245,255,.55),
      rgba(120,210,255,0),
      rgba(145,205,255,.45),
      rgba(120,210,255,0)
    );

  filter: blur(var(--mgBlur, 2.6px));
  opacity: 0;
  transform: scale(0.98);
  mix-blend-mode: screen;

  animation:
    magicSpin var(--mgSpin, 1.9s) linear infinite,
    magicPulse var(--mgPulse, 1.1s) ease-in-out infinite;
}

/* ON/OFF */
.magicOn .magicFx{
  opacity: var(--mgOp, .35);
}

/* livelli intensit√† */
.mg1{  --mgOp:.22; --mgBlur:2.1px; --mgSpin:2.2s; --mgPulse:1.35s; }
.mg2{  --mgOp:.40; --mgBlur:2.8px; --mgSpin:1.9s; --mgPulse:1.15s; }
.mg5{  --mgOp:.78; --mgBlur:3.9px; --mgSpin:1.45s;--mgPulse:.95s; }

/* intensit√† media per boost attivo e dance attivo */
.mgMed{--mgOp:.55; --mgBlur:3.1px; --mgSpin:1.7s; --mgPulse:1.05s; }

@keyframes magicSpin{
  0%{ transform:scale(0.98) rotate(0deg); }
  100%{ transform:scale(0.98) rotate(360deg); }
}
@keyframes magicPulse{
  0%{   filter: blur(var(--mgBlur,2.6px)); }
  50%{  filter: blur(calc(var(--mgBlur,2.6px) + 1.2px)); }
  100%{ filter: blur(var(--mgBlur,2.6px)); }
}

/* animazione pulsante DANCE */
@keyframes danceWiggle{
  0%{ transform:translateX(0) rotate(0deg) scale(1); }
  18%{ transform:translateX(-1.5px) rotate(-1.6deg) scale(1.01); }
  45%{ transform:translateX(1.8px) rotate(1.8deg) scale(1.02); }
  70%{ transform:translateX(-1.2px) rotate(-1.2deg) scale(1.01); }
  100%{ transform:translateX(0) rotate(0deg) scale(1); }
}
.danceActive{
  animation: danceWiggle .32s ease;
  box-shadow:
    0 0 0 1px rgba(145,205,255,.25),
    0 0 18px rgba(110,175,255,.22),
    0 10px 26px rgba(0,0,0,.55);
}
/* =========================================================
   ‚ú® MAGIC FLY (pickup ‚Üí HUD) ‚Äî FILO DI MAGIA + BRILLANTINI
   ========================================================= */
.magicFly{
  position:fixed;
  left:0; top:0;
  width:10px; height:10px;
  border-radius:999px;
  pointer-events:none;
  z-index:9999;
  transform:translate(-50%,-50%);
  background: radial-gradient(circle at 35% 35%,
    rgba(255,255,255,.98),
    rgba(185,245,255,.78) 40%,
    rgba(120,215,255,.35) 68%,
    rgba(0,0,0,0) 78%
  );
  box-shadow:
    0 0 14px rgba(140,235,255,.55),
    0 0 26px rgba(120,220,255,.28);
  mix-blend-mode: screen;
  filter: blur(.05px);
}

/* ‚Äúfilo‚Äù morbido attorno al punto magia */
.magicFly::after{
  content:"";
  position:absolute;
  inset:-16px;
  border-radius:999px;
  background:
    radial-gradient(circle,
      rgba(175,250,255,.18),
      rgba(0,0,0,0) 70%
    );
  opacity:.9;
  filter: blur(3px);
  mix-blend-mode: screen;
}

/* brillantini della scia */
.magicSpark{
  position:fixed;
  width:5px; height:5px;
  border-radius:999px;
  pointer-events:none;
  z-index:9998;
  transform:translate(-50%,-50%);
  background: radial-gradient(circle,
    rgba(255,255,255,.95),
    rgba(180,245,255,.60) 45%,
    rgba(0,0,0,0) 72%
  );
  box-shadow:
    0 0 10px rgba(150,235,255,.35);
  mix-blend-mode: screen;
  opacity:0;
  filter: blur(.05px);
}

/* micro scintille ‚Äútaglienti‚Äù (puntini piccolissimi) */
.magicDust{
  position:fixed;
  width:2px; height:2px;
  border-radius:999px;
  pointer-events:none;
  z-index:9997;
  transform:translate(-50%,-50%);
  background: rgba(255,255,255,.95);
  box-shadow: 0 0 10px rgba(170,245,255,.45);
  mix-blend-mode: screen;
  opacity:0;
}

/* burst finale */
.magicBurst{
  position:fixed;
  width:6px; height:6px;
  border-radius:999px;
  pointer-events:none;
  z-index:9999;
  transform:translate(-50%,-50%);
  background: radial-gradient(circle,
    rgba(255,255,255,.95),
    rgba(190,250,255,.55) 55%,
    rgba(0,0,0,0) 75%
  );
  box-shadow:
    0 0 16px rgba(160,245,255,.55),
    0 0 32px rgba(120,220,255,.25);
  mix-blend-mode: screen;
  opacity:0;
}

    /* =========================================================
       Colonna cibo
       ========================================================= */
    .rightCol{
      position:fixed;
      top:calc(67px * var(--menuScale));
      right:calc(5px * var(--menuScale));
      width:calc(32px * var(--menuScale));
      display:flex; flex-direction:column; align-items:center; gap:calc(5px * var(--menuScale));
      pointer-events:none; z-index:20;
    }
    .foodStack{
      width:calc(32px * var(--menuScale));
      max-height:calc(100px * var(--menuScale));
      overflow:hidden;
      display:flex; flex-direction:column; align-items:center; gap:calc(5px * var(--menuScale));
      background:transparent; border:none; padding:0;
    }
    .foodItem{
      width:calc(27px * var(--menuScale));
      height:calc(15px * var(--menuScale));
      border-radius:999px;

      display:flex;
      align-items:center;
      justify-content:center;

      font-size:calc(8px * var(--menuScale));
      line-height:1;
    }
    .foodCount{
      width:calc(60px * var(--menuScale));
      text-align:center;
      font-weight:950;
      font-size:calc(7px * var(--menuScale));
      padding:calc(4px * var(--menuScale)) 0;
      border-radius:999px;

      display:flex;
      align-items:center;
      justify-content:center;
      gap:calc(4px * var(--menuScale));
      line-height:1;
    }
    .foodCount .icoSm{
      width:calc(9px * var(--menuScale));
      height:calc(9px * var(--menuScale));
    }

    /* =========================================================
   SETTINGS (SLEEK PILL TABS)
   ========================================================= */
.settingsOverlay{
  position:fixed;
  inset:0;
  display:none;
  align-items:flex-start;
  justify-content:center;
  padding:14px;
  background:radial-gradient(ellipse at center, rgba(0,0,0,.15), rgba(0,0,0,.72));
  backdrop-filter:blur(10px);
  z-index:40;
}
/* ‚úÖ quando trascini uno slider: niente nero / niente blur */
.settingsOverlay.focusClear{
  background: transparent !important;
  backdrop-filter: none !important;
  -webkit-backdrop-filter: none !important;
}
/* ‚úÖ quando stai usando uno slider: pannello invisibile (player visibile) */
.settingsOverlay.focusClear .panel{
  opacity: 0 !important;
  pointer-events: none !important; /* cos√¨ non blocca il gioco dietro */
  transform: translateY(-6px);
}

/* ‚úÖ mini slider: IN ALTO (non pi√π in basso) */
.focusOverlay{
  top: calc(env(safe-area-inset-top, 0px) + 10px) !important;
  bottom: auto !important;
}
/* =========================================================
   ‚úÖ SLIDER FOCUS MODE (mostra solo una riga piccola)
   ========================================================= */

.panel.sliderFocus .settingsTop,
.panel.sliderFocus .settingsFooter,
.panel.sliderFocus .tabs,
.panel.sliderFocus .title,
.panel.sliderFocus .card h3,
.panel.sliderFocus .toggle,
.panel.sliderFocus .seg,
.panel.sliderFocus .settingsRow:not(.focusRow),
.panel.sliderFocus .card:not(.focusCard){
  display:none !important;
}

/* la card resta ma super ‚Äúleggera‚Äù */
.panel.sliderFocus{
  background:rgba(10,14,22,.22);
  border-color:rgba(255,255,255,.08);
  box-shadow:0 10px 40px rgba(0,0,0,.40);
  backdrop-filter: blur(8px);
}

/* mostra SOLO la riga del singolo slider (piccola e quasi trasparente) */
.focusOverlay{
  position:fixed;
  left:50%;
  transform:translateX(-50%);
  bottom:calc(env(safe-area-inset-bottom, 0px) + 10px);
  z-index:999;
  width:min(560px, calc(100vw - 22px));
  padding:8px 10px;
  border-radius:999px;
  background:rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.10);
  backdrop-filter: blur(10px);
  pointer-events:auto;
  opacity:.85;
}

.focusOverlay .focusName{
  font-size:11px;
  font-weight:950;
  opacity:.85;
  margin-right:10px;
  white-space:nowrap;
}

.focusOverlay .focusVal{
  font-size:11px;
  font-weight:950;
  opacity:.9;
  white-space:nowrap;
  margin-left:10px;
}

.focusOverlay input[type="range"]{
  flex:1;
  height:16px;
}
/* =========================================================
   CAMERA: BACK / FPS / FRONT ‚Üí SORELLA HUD
   ========================================================= */

.camSegWrap{
  position:fixed;
  right:calc(8px * var(--hudScale));
  left:auto;

  top:calc(
    (5px * var(--menuScale)) +
    (var(--hudPillH) * var(--hudScale)) +
    (6px * var(--hudScale)) +
    var(--camOffsetY)
  );

  z-index:36;
  pointer-events:auto;

  display:flex;
  justify-content:flex-end;
  width:fit-content;
}

/* PILLOLA IDENTICA ALLE HUD */
.camSegPill{
  position:relative;
  overflow:hidden;

  padding:calc(4px * var(--hudScale)) calc(6px * var(--hudScale));
  border-radius:999px;

  display:grid;
  grid-template-columns:1fr 1fr 1fr;
  align-items:center;
  gap:0;

  width:calc(118px * var(--hudScale));
}

/* ‚úÖ FIX fondamentale: evita sfasamenti del thumb */
.camSegPill.pillFx{
  box-sizing:border-box;
  width:calc(90px * var(--hudScale)); /* üëà torna compatta */
}

/* BOTTONI INTERNI */
.camSegBtn{
  -webkit-appearance:none;
  appearance:none;
  padding:0;
  margin:0;
  width:100%;
  height:calc(var(--hudPillH) * var(--hudScale));
  pointer-events:auto;
  border:none;
  background:transparent;
  cursor:pointer;
  user-select:none;

  height:100%;
  min-height:calc(var(--hudPillH) * var(--hudScale));

  border-radius:999px;

  font-weight:950;
  font-size:calc(7px * var(--hudScale));
  letter-spacing:.25px;
  line-height:1;

  color:#eaf1ff;
  opacity:.9;

  display:flex;
  align-items:center;
  justify-content:center;
}

.camSegBtn.active{ opacity:1; }

/* SLIDER INTERNO (thumb) */
.camThumb{
  position:absolute;
  z-index:0;

  top:calc(2px * var(--hudScale));
  bottom:calc(2px * var(--hudScale));
  left:calc(2px * var(--hudScale));

  width:calc((100% - calc(4px * var(--hudScale))) / 3);
  border-radius:999px;

  box-sizing:border-box;   /* ‚úÖ fondamentale */

  background:linear-gradient(
    180deg,
    rgba(255,255,255,.12),
    rgba(255,255,255,.05)
  );

  border:none;             /* ‚úÖ evita che ‚Äúallarga‚Äù e sfora */

  box-shadow:
    inset 0 0 0 1px rgba(145,205,255,.28), /* ‚úÖ al posto della border */
    0 0 0 1px rgba(95,160,255,.12),
    0 0 12px rgba(110,175,255,.20),
    inset 0 1px 0 rgba(255,255,255,.18),
    inset 0 -1px 0 rgba(0,0,0,.25);

  transition:transform .18s ease;
}

/* Assicura che stia sopra HUD */
.camSegWrap, .topLeftBtns{ z-index:35; }

/* =========================================================
   SETTINGS PANEL
   ========================================================= */
.panel{
  width:min(740px,100%);
  border-radius:20px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(10,14,22,.88);
  box-shadow:0 18px 60px rgba(0,0,0,.60);
  padding:14px;
  color:#eaf1ff;
}

.settingsTop{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  margin-bottom:10px;
}

.title{
  font-size:16px;
  font-weight:950;
  margin:0;
}

.tabs{
  display:flex;
  gap:8px;
  padding:6px;
  border-radius:999px;
}

.tabBtn{
  border:none;
  background:transparent;
  cursor:pointer;
  user-select:none;
  padding:8px 12px;
  border-radius:999px;
  font-weight:950;
  font-size:12px;
  letter-spacing:.2px;
  opacity:.85;
}

.tabBtn.active{
  opacity:1;
  box-shadow:
    0 0 0 1px rgba(145,205,255,.28),
    0 0 16px rgba(110,175,255,.18);
}

.settingsBody{
  display:grid;
  grid-template-columns: 1fr;
  gap:10px;
}

@media (min-width:720px){
  .settingsBody{ grid-template-columns: 1fr 1fr; }
}

.card{
  border-radius:16px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(255,255,255,.05);
  padding:12px;
}

.card h3{
  margin:0 0 10px;
  font-size:12px;
  letter-spacing:.25px;
  text-transform:uppercase;
  opacity:.9;
}

.settingsRow{
  display:flex;
  justify-content:space-between;
  align-items:flex-end;
  gap:10px;
  font-size:13px;
  margin-top:10px;
}

.settingsRow small{ opacity:.8; }
.settingsVal{ font-weight:950; }

input[type="range"]{
  width:100%;
  height:18px;
  accent-color: rgba(255,255,255,.85);
}

.toggle{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  border:1px solid rgba(255,255,255,.12);
  border-radius:16px;
  padding:10px 12px;
  background:rgba(255,255,255,.04);
  cursor:pointer;
  user-select:none;
  margin-top:10px;
}

.toggle label{ font-weight:950; }
.toggle span{ opacity:.85; font-size:12px; }

.switch{
  width:44px;
  height:26px;
  border-radius:99px;
  background:rgba(255,255,255,.14);
  position:relative;
  border:1px solid rgba(255,255,255,.14);
  flex:0 0 auto;
}

.switch i{
  position:absolute;
  top:3px;
  left:3px;
  width:20px;
  height:20px;
  border-radius:999px;
  background:rgba(255,255,255,.86);
  transition:transform .18s ease;
}

.switch.on{
  background:rgba(140,255,190,.18);
  border-color:rgba(140,255,190,.22);
}

.switch.on i{ transform:translateX(18px); }

/* Segmented pill (FPS REALISTICO / STABILE) */
.seg{
  display:flex;
  gap:6px;
  padding:6px;
  border-radius:999px;
}
.segBtn{
  border:none;
  background:transparent;
  cursor:pointer;
  user-select:none;
  padding:8px 10px;
  border-radius:999px;
  font-weight:950;
  font-size:12px;
  opacity:.85;
  white-space:nowrap;
}
.segBtn.active{
  opacity:1;
  box-shadow:
    0 0 0 1px rgba(145,205,255,.30),
    0 0 14px rgba(110,175,255,.18);
}

.settingsFooter{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  margin-top:12px;
}
.settingsFooter .btnGroup{
  height:auto;
  padding:10px 12px;
}

/* ===== CLOSE SETTINGS (X) ===== */
.settingsClose{
  position:absolute;
  top:calc(env(safe-area-inset-top, 0px) + 2px);
  right:calc(env(safe-area-inset-right, 0px) + 8px);
  z-index:10;

  width:calc(22px * var(--hudScale));
  height:calc(22px * var(--hudScale));
  border-radius:999px;

  display:flex;
  align-items:center;
  justify-content:center;

  font-weight:900;
  font-size:calc(10px * var(--hudScale));
  line-height:1;

  color:#eaf1ff;
  background:linear-gradient(
    180deg,
    rgba(255,255,255,.10),
    rgba(255,255,255,.04)
  );
  border:1px solid rgba(145,205,255,.25);

  box-shadow:
    0 0 0 1px rgba(95,160,255,.10),
    0 0 10px rgba(110,175,255,.18),
    inset 0 1px 0 rgba(255,255,255,.12),
    inset 0 -1px 0 rgba(0,0,0,.22);

  cursor:pointer;
  pointer-events:auto;
}

/* feedback tap */
.settingsClose:active{
  transform:scale(.94);
}

/* Motion blur fake (solo boost) */
canvas.blurBoost{
  filter: blur(0.9px) saturate(1.03);
}

    /* =========================================================
       DEBUG PANEL
       ========================================================= */
    .debugPanel{
      position:fixed;
      right:calc(6px * var(--menuScale));
      top:calc(5px * var(--menuScale) + calc(16px * var(--menuScale)) + calc(16px * var(--menuScale)) + 80px);
      z-index:60;
      width:min(320px, calc(100vw - 20px));
      padding:10px 12px;
      border-radius:16px;
      display:none;
      pointer-events:auto;
      font-size:12px;
      line-height:1.35;
      color:#eaf1ff;
    }
    .dbgRow{ display:flex; justify-content:space-between; gap:10px; }
    .dbgRow b{ font-weight:950; }
    .dbgSmall{ opacity:.85; font-size:11px; }
    .dbgSep{ height:1px; background:rgba(255,255,255,.10); margin:8px 0; }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>

  <!-- ‚úÖ HUD SINISTRA -->
<div class="hudWrap">
  <div class="hudCard">
    <div class="hudGrid">

      <!-- Score (sx) -->
      <div class="hudP pillFx hudHalf">
        <div class="hudL">
          <svg class="ico" viewBox="0 0 24 24" aria-hidden="true">
            <defs>
              <linearGradient id="gScoreIcon" x1="0" y1="0" x2="1" y2="1">
                <stop offset="0" stop-color="#ffffff" stop-opacity=".95"/>
                <stop offset=".45" stop-color="#cfe6ff" stop-opacity=".95"/>
                <stop offset="1" stop-color="#7fb4ff" stop-opacity=".90"/>
              </linearGradient>
            </defs>
            <path fill="url(#gScoreIcon)" d="M12 13.2a4.2 4.2 0 1 0 0-8.4 4.2 4.2 0 0 0 0 8.4z"/>
            <path fill="rgba(0,0,0,.20)" d="M12 6.3a2.7 2.7 0 1 1 0 5.4 2.7 2.7 0 0 1 0-5.4z"/>
            <path fill="url(#gScoreIcon)" d="M7.2 13.1 5 21l4-2 3 2-2.1-7.9c-.9.5-1.9.8-2.7.0z" opacity=".95"/>
            <path fill="url(#gScoreIcon)" d="M16.8 13.1 19 21l-4-2-3 2 2.1-7.9c.9.5 1.9.8 2.7.0z" opacity=".95"/>
          </svg>
          <div class="hudT">Score</div>
        </div>
        <div class="hudV"><span id="score">0</span></div>
      </div>

      <!-- Emoji (dx) -->
      <div class="hudP pillFx hudHalf">
        <div class="hudL">
          <svg class="ico" viewBox="0 0 24 24" aria-hidden="true">
            <defs>
              <linearGradient id="gEmojiIcon" x1="0" y1="0" x2="1" y2="1">
                <stop offset="0" stop-color="#ffffff" stop-opacity=".95"/>
                <stop offset=".40" stop-color="#d6ffe9" stop-opacity=".95"/>
                <stop offset="1" stop-color="#34c759" stop-opacity=".92"/>
              </linearGradient>
            </defs>
            <circle cx="12" cy="12" r="8" fill="url(#gEmojiIcon)"/>
            <circle cx="9.3" cy="10.2" r="1.1" fill="rgba(0,0,0,.28)"/>
            <circle cx="14.7" cy="10.2" r="1.1" fill="rgba(0,0,0,.28)"/>
            <path d="M8.7 14.1c1 .9 2.1 1.4 3.3 1.4s2.3-.5 3.3-1.4"
                  fill="none" stroke="rgba(0,0,0,.28)" stroke-width="1.7" stroke-linecap="round"/>
          </svg>
          <div class="hudT">Emoji</div>
        </div>
        <div class="hudV"><span id="coins">0</span></div>
      </div>

      <!-- Rings (sx) -->
      <div class="hudP pillFx hudHalf">
        <div class="hudL">
          <svg class="ico" viewBox="0 0 24 24" aria-hidden="true">
            <defs>
              <linearGradient id="gRingsIcon" x1="0" y1="0" x2="1" y2="1">
                <stop offset="0" stop-color="#ffffff" stop-opacity=".95"/>
                <stop offset=".45" stop-color="#ffd1d1" stop-opacity=".95"/>
                <stop offset="1" stop-color="#ff3b30" stop-opacity=".92"/>
              </linearGradient>
            </defs>
            <path fill="url(#gRingsIcon)"
                  d="M12 4.5c-4.1 0-7.5 3.4-7.5 7.5S7.9 19.5 12 19.5s7.5-3.4 7.5-7.5S16.1 4.5 12 4.5zm0 3c2.5 0 4.5 2 4.5 4.5S14.5 16.5 12 16.5 7.5 14.5 7.5 12 9.5 7.5 12 7.5z"/>
            <path fill="rgba(255,255,255,.22)" d="M14.8 7.9c1.2.8 2 2.2 2 3.8 0 .5-.1 1-.2 1.4-.2.8-1.2.9-1.6.2-.2-.4-.3-.9-.3-1.4 0-1.1-.6-2.1-1.4-2.7-.6-.4-.3-1.7.5-1.3z"/>
          </svg>
          <div class="hudT">Rings</div>
        </div>
        <div class="hudV"><span id="rings">0</span></div>
      </div>

      <!-- Vita (GEMELLA + cuori centrati) -->
<div class="hudP pillFx hudHalf lifePill">
  <div class="hudL"></div>
  <div class="hudV">
    <span id="hpTxt">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏èüñ§üñ§</span>
  </div>
</div>

      <!-- Magnete -->
      <div class="hudP pillFx hudFull">
        <div class="hudBarRow">
          <div class="hudL">
            <svg class="ico" viewBox="0 0 24 24" aria-hidden="true">
              <defs>
                <linearGradient id="gMag" x1="0" y1="0" x2="1" y2="1">
                  <stop offset="0" stop-color="#ffffff" stop-opacity=".95"/>
                  <stop offset=".35" stop-color="#ffd1d1" stop-opacity=".95"/>
                  <stop offset="1" stop-color="#ff3b30" stop-opacity=".95"/>
                </linearGradient>
              </defs>
              <path fill="url(#gMag)" d="M7 3h4v9a1 1 0 0 0 2 0V3h4v9c0 3.9-3.1 7-7 7s-7-3.1-7-7V3Z"/>
              <path fill="rgba(0,0,0,.25)" d="M7 3h4v2H7V3zm10 0h-4v2h4V3z"/>
            </svg>
            <div class="hudT">Magnete</div>
          </div>
          <div class="hudBar"><i id="magBar"></i></div>
          <div class="hudV"><span id="magTxt">üß≤ 0</span></div>
        </div>
      </div>
      
      <!-- Debug button -->
<div class="debugRow">
  <button class="dbgBtn pillFx" id="btnDebug" title="Debug" type="button">
    <svg class="ico" viewBox="0 0 24 24" aria-hidden="true">
      <defs>
        <linearGradient id="gBug" x1="0" y1="0" x2="1" y2="1">
          <stop offset="0" stop-color="#ffffff" stop-opacity=".98"/>
          <stop offset=".45" stop-color="#d6ffe9" stop-opacity=".96"/>
          <stop offset="1" stop-color="#34c759" stop-opacity=".92"/>
        </linearGradient>
      </defs>
      <path fill="url(#gBug)"
        d="M14 7.2c.6-.5 1-1.2 1-2 0-1.5-1.3-2.7-3-2.7S9 3.7 9 5.2c0 .8.4 1.5 1 2C7.7 8 6.2 10 6.2 12.4V14H5v1.6h1.2c.1.8.4 1.6.8 2.3l-1 .9 1 1.2 1.1-1c.9.7 2 .9 3.2.9s2.3-.2 3.2-.9l1.1 1 1-1.2-1-.9c.4-.7.7-1.5.8-2.3H19V14h-1.2v-1.6c0-2.4-1.5-4.4-3.8-5.2ZM8.8 14h6.4v1.6H8.8V14Zm0-3.2h6.4V12.4H8.8v-1.6Z"/>
    </svg>
  </button>
</div>

      <!-- Boost -->
      <div class="hudP pillFx hudFull" id="pillBoost" style="display:none;">
        <div class="hudBarRow">
          <div class="hudL">
            <span id="boostIcon">‚ö°Ô∏è</span>
            <div class="hudT"><strong id="boostName">BOOST</strong></div>
          </div>
          <div class="hudBar"><i id="boostBar"></i></div>
          <div class="hudV"><span id="boostTime">0.0s</span></div>
        </div>
      </div>

      <!-- Food Boost -->
      <div class="hudP pillFx hudFull" id="foodBoostPill" style="display:none;">
        <div class="hudBarRow">
          <div class="hudL">
            <svg class="ico" viewBox="0 0 24 24" aria-hidden="true">
              <defs>
                <linearGradient id="gFoodBoost" x1="0" y1="0" x2="1" y2="1">
                  <stop offset="0" stop-color="#ffffff" stop-opacity=".95"/>
                  <stop offset=".4" stop-color="#d6ffe9" stop-opacity=".95"/>
                  <stop offset="1" stop-color="#34c759" stop-opacity=".92"/>
                </linearGradient>
              </defs>
              <path fill="url(#gFoodBoost)" d="M8 7c0-2.2 1.8-4 4-4s4 1.8 4 4v1h1.2c1 0 1.8.8 1.8 1.8V19c0 1-.8 1.8-1.8 1.8H6.8C5.8 20.8 5 20 5 19V9.8C5 8.8 5.8 8 6.8 8H8V7Zm2 1h4V7c0-1.1-.9-2-2-2s-2 .9-2 2v1Z"/>
              <path fill="rgba(0,0,0,.22)" d="M7 12h10v2H7v-2z"/>
            </svg>
            <div class="hudT">Cibo</div>
          </div>
          <div class="hudBar"><i id="foodBoostBar"></i></div>
          <div class="hudV"><span id="foodBoostTime">0.0s</span></div>
        </div>
      </div>

    </div>

       <span id="best" style="display:none;">0</span>
  </div>
</div>
   
  <!-- ‚úÖ TOP RIGHT: HOME + IMPOSTAZIONI -->
<div class="topLeftBtns">
  <div class="btnGroup pillFx">

    <button class="btnSub" id="btnHome" type="button" title="Home">
      <svg class="ico" viewBox="0 0 24 24">
        <path fill="rgba(255,255,255,.95)"
          d="M12 3.2 3 10.5v9.3c0 .6.5 1 1 1h5.3v-6.1c0-.6.4-1 1-1h3.4c.6 0 1 .4 1 1v6.1H20c.6 0 1-.4 1-1v-9.3L12 3.2z"/>
      </svg>
    </button>

    <button class="btnSub" id="btnSettings" type="button" title="Impostazioni">
      <svg class="ico" viewBox="0 0 24 24">
        <path fill="rgba(255,255,255,.95)"
          d="M19.4 13.5c.04-.5.04-1 0-1.5l2-1.6c.2-.2.25-.5.12-.75l-1.9-3.3c-.13-.25-.43-.35-.7-.26l-2.35.95a7.9 7.9 0 0 0-1.3-.75l-.36-2.5A.63.63 0 0 0 14.3 3h-3.8c-.3 0-.56.22-.6.52l-.36 2.5c-.46.2-.9.45-1.3.75L5.9 5.82c-.27-.1-.57 0-.7.26L3.3 9.38c-.13.25-.08.56.12.75l2 1.6c-.04.5-.04 1 0 1.5l-2 1.6c-.2.2-.25.5-.12.75l1.9 3.3c.13.25.43.35.7.26l2.35-.95c.4.3.84.56 1.3.75l.36 2.5c.04.3.3.52.6.52h3.8c.3 0 .56-.22.6-.52l.36-2.5c.46-.2.9-.45 1.3-.75l2.35.95c.27.1.57 0 .7-.26l1.9-3.3c.13-.25.08-.56-.12-.75l-2-1.6z"/>
      </svg>
    </button>

  </div>
</div>


  <!-- Camera BACK / FPS / FRONT (UNICA) -->
  <div class="camSegWrap">
    <div class="camSegPill pillFx" aria-label="Camera">
      <span class="camThumb" id="camThumb"></span>
      <button class="camSegBtn" id="btnCamBack"  type="button">BACK</button>
      <button class="camSegBtn" id="btnCamFPS"   type="button">FPS</button>
      <button class="camSegBtn" id="btnCamFront" type="button">FRONT</button>
    </div>
  </div>

  <!-- live FPS toggle (nascosto, serve al JS) -->
  <button class="camBtn pillFx" id="btnFpsLive" style="display:none;" type="button">
    FPS: REAL
  </button>


<!-- Start / Dance / Boost -->
<div class="rightStack">

  <!-- ‚úÖ BOOST (sopra Avvia) -->
  <div class="boostRow" id="boostRow" style="display:none;">
    <!-- pillolina pi√π stretta col conteggio -->
    <button class="miniBtn pillFx" id="btnBoostCount" type="button" aria-label="Boost disponibili">
      <span class="miniLbl" id="boostCountLbl">0</span>
    </button>

    <!-- pulsante boost senza conteggio -->
    <button class="bigBtn pillFx" id="btnFoodBoost" type="button">
      <span class="centerLbl" id="foodBoostLbl">BOOST</span>
    </button>
  </div>

  <!-- START -->
  <button class="bigBtn pillFx" id="btnMain" type="button">
    <span class="centerLbl" id="mainLbl">AVVIA</span>
  </button>

  <!-- DANCE (in basso) -->
  <button class="bigBtn pillFx" id="btnDance" type="button">
    <span class="centerLbl">DANCE</span>
  </button>
</div>



  <!-- Colonna cibo -->
  <div class="rightCol">
    <div class="foodStack" id="foodStack"></div>
    <div class="foodCount pillFx">
      <svg class="icoSm" viewBox="0 0 24 24" aria-hidden="true">
        <defs>
          <linearGradient id="gBag" x1="0" y1="0" x2="1" y2="1">
            <stop offset="0" stop-color="#ffffff" stop-opacity=".95"/>
            <stop offset=".4" stop-color="#d6ffe9" stop-opacity=".95"/>
            <stop offset="1" stop-color="#34c759" stop-opacity=".92"/>
          </linearGradient>
        </defs>
        <path fill="url(#gBag)" d="M8 7c0-2.2 1.8-4 4-4s4 1.8 4 4v1h1.2c1 0 1.8.8 1.8 1.8V19c0 1-.8 1.8-1.8 1.8H6.8C5.8 20.8 5 20 5 19V9.8C5 8.8 5.8 8 6.8 8H8V7z"/>
      </svg>
      <span><span id="foodCount">0</span>/10</span>
    </div>
  </div>

  <!-- DEBUG PANEL -->
  <div class="debugPanel pillFx" id="debugPanel">
    <div class="dbgRow"><b>DEBUG</b><span class="dbgSmall" id="dbgFps">fps: --</span></div>
    <div class="dbgSep"></div>
    <div class="dbgRow"><span>camera</span><span id="dbgCam">--</span></div>
    <div class="dbgRow"><span>mode</span><span id="dbgMode">--</span></div>
    <div class="dbgRow"><span>state</span><span id="dbgState">--</span></div>
    <div class="dbgRow"><span>entities</span><span id="dbgEnt">--</span></div>
    <div class="dbgRow"><span>lane</span><span id="dbgLane">--</span></div>
    <div class="dbgRow"><span>boosts</span><span id="dbgBoosts">--</span></div>
  </div>

  <!-- SETTINGS -->
<div class="settingsOverlay" id="settingsOverlay">
  <div class="panel pillFx">
    
    <!-- ‚úÖ MINI SLIDER OVERLAY (visibile solo mentre trascini) -->
<div class="focusOverlay pillFx" id="focusOverlay" style="display:none;">
  <span class="focusName" id="focusName">FOV</span>
  <input type="range" id="focusRange" min="0" max="1" step="0.01" value="0">
  <span class="focusVal" id="focusVal">0</span>
</div>

    <!-- ‚ùå X CHIUSURA (PUNTO 1) -->
    <button class="settingsClose pillFx" id="btnCloseSettings" aria-label="Chiudi impostazioni">
      ‚úï
    </button>

    <div class="settingsTop">
      <div class="title">Impostazioni</div>
      <div class="tabs pillFx" aria-label="Tabs impostazioni">
        <button class="tabBtn active" id="tabCam">CAMERA</button>
        <button class="tabBtn" id="tabVisual">VISUAL</button>
        <button class="tabBtn" id="tabAudio">AUDIO</button>
      </div>
    </div>

    <div class="settingsBody" id="settingsBody">

      <!-- CAMERA TAB -->
      <div class="card" data-tab="cam">
        <h3>Camera</h3>

         <!-- ‚úÖ Sotto-tabs: FRONT / BACK -->
<div class="seg pillFx" id="camProfileSeg" style="margin-bottom:10px;">
  <button class="segBtn active" id="btnCamProfFront" type="button">FRONT</button>
  <button class="segBtn" id="btnCamProfBack" type="button">BACK</button>
</div>
        <div class="settingsRow">
          <div><label>FOV</label><br><small>30‚Äì110 (base 60)</small></div>
          <div class="settingsVal" id="fovVal">60</div>
        </div>
        <input id="fovSlider" type="range" min="30" max="110" step="1" value="60" />

        <div class="settingsRow">
          <div><label>Distanza camera</label><br><small>2‚Äì15 (base 5.0)</small></div>
          <div class="settingsVal" id="camVal">5.0</div>
        </div>
        <input id="camSlider" type="range" min="2" max="15" step="0.1" value="5.0" />

        <div class="settingsRow">
          <div><label>Altezza camera</label><br><small>0=terra ‚Ä¢ 8=alto</small></div>
          <div class="settingsVal" id="camYVal">4.6</div>
        </div>
        <input id="camYSlider" type="range" min="0" max="8" step="0.1" value="4.6" />

        <div class="settingsRow">
          <div><label>Inquadratura player</label><br><small>0=alto ‚Ä¢ 1=molto in basso</small></div>
          <div class="settingsVal" id="frameVal">0.06</div>
        </div>
        <input id="frameSlider" type="range" min="0" max="1" step="0.01" value="0.06" />
      </div>

      <!-- VISUAL TAB -->
      <div class="card" data-tab="visual" style="display:none;">
        <h3>Visual (FPS)</h3>

        <!-- FPS Realistico / Stabile -->
        <div class="toggle" id="fpsModeToggle">
          <div>
            <label>FPS</label><br/>
            <span>Realistico: bob + elasticit√†. Stabile: camera ‚Äúferma‚Äù.</span>
          </div>
          <div class="seg pillFx" id="fpsSeg">
            <button class="segBtn" id="btnFpsReal">REALISTICO</button>
            <button class="segBtn" id="btnFpsStable">STABILE</button>
          </div>
        </div>

        <!-- Motion blur -->
        <div class="toggle" id="motionToggle">
          <div>
            <label>Motion blur</label><br/>
            <span>Fake blur solo durante i boost (leggero).</span>
          </div>
          <div class="switch" id="motionSwitch"><i></i></div>
        </div>

        <!-- FOV dinamico solo in FPS -->
        <div class="toggle" id="dynFovToggle">
          <div>
            <label>FOV dinamico (FPS)</label><br/>
            <span>Aumenta il FOV solo in boost quando sei in FPS.</span>
          </div>
          <div class="switch on" id="dynFovSwitch"><i></i></div>
        </div>

        <div class="toggle" id="shakeToggle">
          <div><label>Camera shake</label><br/><span>Micro shake durante i boost (non in FPS).</span></div>
          <div class="switch on" id="shakeSwitch"><i></i></div>
        </div>
      </div>

      <!-- AUDIO TAB -->
      <div class="card" data-tab="audio" style="display:none;">
        <h3>Audio</h3>

        <div class="toggle" id="audioToggle">
          <div><label>Suoni</label><br/><span>Fallback semplice (stabile su iPhone).</span></div>
          <div class="switch on" id="audioSwitch"><i></i></div>
        </div>
      </div>

    </div>

    <div class="settingsFooter">
      <button class="btnGroup pillFx" id="resetCam">Reset</button>
    </div>
  </div>
</div>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    /* =========================================================
       ‚úÖ MINI FIX ‚ÄúSAFE‚Äù (anti-schermo-nero)
       ========================================================= */
    const $ = (id)=>document.getElementById(id);
    function safeOn(el, ev, fn){ if(el) el.addEventListener(ev, fn); }
    // ===============================
// ‚úÖ UTILITIES MANCANTI (FIX CRASH)
// ===============================
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const lerp  = (a, b, t) => a + (b - a) * t;
const damp  = (x, y, lambda, dt) => lerp(x, y, 1 - Math.exp(-lambda * dt));

const rnd  = (a, b) => a + Math.random() * (b - a);
const rndi = (a, b) => Math.floor(rnd(a, b + 1));
// =========================================================
// ‚ú® MAGIC FLY (world ‚Üí HUD)
// =========================================================
function worldToScreen(x,y,z){
  const v = new THREE.Vector3(x,y,z);
  v.project(camera);
  const r = renderer.domElement.getBoundingClientRect();
  return {
    x: r.left + (v.x * 0.5 + 0.5) * r.width,
    y: r.top  + (-v.y * 0.5 + 0.5) * r.height
  };
}

function pulseHUD(el, cls='hudPulse'){
  if(!el) return;
  el.classList.remove(cls);
  void el.offsetWidth;
  el.classList.add(cls);
  setTimeout(()=>el.classList.remove(cls), 320);
}

// =========================================================
// ‚ú® MAGIC FLY (Canvas ultra leggero - NO LAG) ‚úÖ FIX
// =========================================================
function magicFly(fromWorld, toEl, opt = {}){
  if(!toEl) return;

  const canvas = document.getElementById('magicCanvas');
  if(!canvas) return;

  const ctx = canvas.getContext('2d');
  if(!ctx) return;

  const dpr = window.devicePixelRatio || 1;

  canvas.width  = window.innerWidth * dpr;
  canvas.height = window.innerHeight * dpr;
  canvas.style.width  = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';

  const start = worldToScreen(fromWorld.x, fromWorld.y, fromWorld.z);
  const r = toEl.getBoundingClientRect();
  const end = { x: r.left + r.width/2, y: r.top + r.height/2 };

  const duration = opt.dur ?? 450;
  const startTime = performance.now();

  function animate(now){
    const t = Math.min((now - startTime)/duration, 1);

    const x = start.x + (end.x - start.x) * t;
    const y = start.y + (end.y - start.y) * t;

    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // pallina
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = 'rgba(120,220,255,0.95)';
    ctx.beginPath();
    ctx.arc(x*dpr, y*dpr, 4.2*dpr, 0, Math.PI*2);
    ctx.fill();

    // alone
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = 'rgba(120,220,255,0.25)';
    ctx.beginPath();
    ctx.arc(x*dpr, y*dpr, 12*dpr, 0, Math.PI*2);
    ctx.fill();

    if(t < 1){
      requestAnimationFrame(animate);
    }else{
      ctx.clearRect(0,0,canvas.width,canvas.height);
      pulseHUD(toEl);
    }
  }

  requestAnimationFrame(animate);
}

  

  // end (HUD element center)
  const tr = toEl.getBoundingClientRect();
  const s1 = { x: tr.left + tr.width/2, y: tr.top + tr.height/2 };

  // curva pi√π ‚Äúnaturale‚Äù (doppio controllo)
  const c1 = {
    x: s0.x + rnd(-50, 50),
    y: s0.y - rnd(40, 95)
  };
  const c2 = {
    x: s1.x + rnd(-35, 35),
    y: s1.y - rnd(35, 85)
  };

  // orb
  const orb = document.createElement('div');
  orb.className = 'magicFly';
  document.body.appendChild(orb);

  // trail pool (spark)
  const sparkEls = [];
  for(let i=0;i<sparks;i++){
    const sp = document.createElement('div');
    sp.className = 'magicSpark';
    document.body.appendChild(sp);
    sparkEls.push({
      el: sp,
      t: -i * (0.55 / sparks),   // scia gi√† ‚Äúdietro‚Äù
      life: rnd(0.22, 0.32),
      sway: rnd(0.6, 1.25),
      driftX: rnd(-22, 22),
      driftY: rnd(-16, 16)
    });
  }

  // micro dust (puntini piccoli)
  const dustEls = [];
  for(let i=0;i<dust;i++){
    const d = document.createElement('div');
    d.className = 'magicDust';
    document.body.appendChild(d);
    dustEls.push({
      el: d,
      t: -i * (0.60 / dust),
      life: rnd(0.16, 0.26),
      driftX: rnd(-28, 28),
      driftY: rnd(-24, 24)
    });
  }

  function cubicBezier(t,a,b,c,d){
    const u = 1-t;
    const tt = t*t, uu = u*u;
    const uuu = uu*u;
    const ttt = tt*t;
    return {
      x: uuu*a.x + 3*uu*t*b.x + 3*u*tt*c.x + ttt*d.x,
      y: uuu*a.y + 3*uu*t*b.y + 3*u*tt*c.y + ttt*d.y
    };
  }

  // easing super ‚Äúmorbido‚Äù
  const ease = (t)=> (t<0.5) ? (4*t*t*t) : (1 - Math.pow(-2*t+2,3)/2);

  const startT = performance.now();

  function spawnBurst(x,y){
    // scintille che si ‚Äúspargono‚Äù al punto finale
    const parts = [];
    const n = burst;

    for(let i=0;i<n;i++){
      const p = document.createElement('div');
      p.className = 'magicBurst';
      p.style.left = x+'px';
      p.style.top  = y+'px';
      document.body.appendChild(p);

      const ang = rnd(0, Math.PI*2);
      const spd = rnd(90, 220); // px/sec
      parts.push({
        el: p,
        vx: Math.cos(ang)*spd + rnd(-40,40),
        vy: Math.sin(ang)*spd - rnd(40,120),
        t: 0,
        life: rnd(0.26, 0.42),
        s0: rnd(0.55, 1.15)
      });
    }

    const t0 = performance.now();
    function tickBurst(now){
      const dt = Math.min(0.030, (now - t0)/1000); // micro stabilit√†
      let alive = 0;

      for(const p of parts){
        p.t += dt;
        const k = clamp(p.t / p.life, 0, 1);

        // gravit√† leggera
        p.vy += 520 * dt;

        const dx = p.vx * dt;
        const dy = p.vy * dt;

        const r = p.el.getBoundingClientRect();
        const cx = (r.left + r.width/2) + dx;
        const cy = (r.top  + r.height/2) + dy;

        p.el.style.left = cx + 'px';
        p.el.style.top  = cy + 'px';

        const op = (1-k) * 0.95;
        const sc = p.s0 * (1 + k*0.55);

        p.el.style.opacity = op.toFixed(3);
        p.el.style.transform = `translate(-50%,-50%) scale(${sc.toFixed(3)})`;

        if(k < 1) alive++;
        else p.el.remove();
      }

      if(alive > 0) requestAnimationFrame(tickBurst);
    }
    requestAnimationFrame(tickBurst);
  }

  function tick(now){
    const t = clamp((now - startT)/dur, 0, 1);
    const e = ease(t);

    const p = cubicBezier(e, s0, c1, c2, s1);

    // orb principale
    const scl = lerp(1.12, 0.55, e);
    const op  = (t < 0.88) ? 1 : lerp(1, 0, (t-0.88)/0.12);

    orb.style.left = p.x + 'px';
    orb.style.top  = p.y + 'px';
    orb.style.opacity = op.toFixed(3);
    orb.style.transform = `translate(-50%,-50%) scale(${scl.toFixed(3)})`;

    // scia: ogni particella insegue un punto ‚Äúdietro‚Äù la curva
    // + lieve swirl (filo di magia)
    const time = now * 0.001;

    for(const s of sparkEls){
      s.t += (1/dur) * 16;                 // scorre dietro
      const tt = clamp(e - Math.max(0, s.t)*0.08, 0, 1);

      const pp = cubicBezier(tt, s0, c1, c2, s1);

      const swirl = Math.sin((time*6.5) + s.driftX*0.02) * (6.0 * s.sway);
      const spreadX = (e * 14) + swirl;
      const spreadY = (e * 10) - swirl*0.35;

      const jx = (Math.random()*2-1) * (3 + spreadX*0.35) + (s.driftX * (0.08 + e*0.12));
      const jy = (Math.random()*2-1) * (3 + spreadY*0.28) + (s.driftY * (0.06 + e*0.10));

      // fade (vive attorno al punto dietro)
      const local = clamp(1 - Math.abs(tt - (e-0.10)) * (1/0.18), 0, 1);
      const a = local * 0.65;

      s.el.style.left = (pp.x + jx) + 'px';
      s.el.style.top  = (pp.y + jy) + 'px';
      s.el.style.opacity = a.toFixed(3);

      const ss = lerp(0.45, 1.05, a/0.65);
      s.el.style.transform = `translate(-50%,-50%) scale(${ss.toFixed(3)})`;
    }

    // micro dust: pi√π fine, pi√π ‚Äúmagico‚Äù
    for(const d of dustEls){
      d.t += (1/dur) * 18;
      const tt = clamp(e - Math.max(0, d.t)*0.10, 0, 1);
      const pp = cubicBezier(tt, s0, c1, c2, s1);

      const jx = rnd(-1,1) * (6 + e*14) + d.driftX*(0.06 + e*0.10);
      const jy = rnd(-1,1) * (6 + e*12) + d.driftY*(0.06 + e*0.10);

      const local = clamp(1 - Math.abs(tt - (e-0.12)) * (1/0.22), 0, 1);
      const a = local * 0.55;

      d.el.style.left = (pp.x + jx) + 'px';
      d.el.style.top  = (pp.y + jy) + 'px';
      d.el.style.opacity = a.toFixed(3);
    }

    if(t < 1){
      requestAnimationFrame(tick);
    }else{
      // burst finale ‚Äúartificio‚Äù
      spawnBurst(s1.x, s1.y);

      orb.remove();
      for(const s of sparkEls) s.el.remove();
      for(const d of dustEls) d.el.remove();

      pulseHUD(toEl);
    }
  }

  requestAnimationFrame(tick);
}
    window.addEventListener('error', (e)=>{
      console.warn('JS error caught:', e?.message || e);
    });

    const IS_IOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

    // ===== UI: HUD =====
    const scoreEl = $('score');
    const coinsEl = $('coins');
    const bestEl  = $('best'); // hidden
    const ringsEl = $('rings');
    const hpTxt   = $('hpTxt');
    const magTxt  = $('magTxt');

    const pillBoost = $('pillBoost');
    const boostIcon = $('boostIcon');
    const boostName = $('boostName');
    const boostBar  = $('boostBar');

    const foodStack = $('foodStack');
    const foodCountEl = $('foodCount');

    // ===== UI: Buttons =====
    const btnHome = $('btnHome');
    const btnSettings = $('btnSettings');
    const btnFoodBoost = $('btnFoodBoost');
const foodBoostLbl = $('foodBoostLbl');

const boostRow = $('boostRow');
const btnBoostCount = $('btnBoostCount');
const boostCountLbl = $('boostCountLbl');

    const btnMain = $('btnMain');
    const mainLbl = $('mainLbl');
    const btnDance = $('btnDance');
    
    // =========================================================
// ‚ú® MAGIC HELPERS
// =========================================================
function ensureMagic(el){
  if(!el) return;
  if(el.classList.contains('hasMagic')) return;
  el.classList.add('hasMagic');
  const fx = document.createElement('span');
  fx.className = 'magicFx';
  fx.setAttribute('aria-hidden','true');
  el.appendChild(fx);
}

function setMagicLevel(el, level){ 
  if(!el) return;

  // pulizia classi
  el.classList.remove('magicOn','mg1','mg2','mg5','mgMed');

  if(!level){ 
    return; 
  }

  ensureMagic(el);
  el.classList.add('magicOn');

  // level pu√≤ essere: "1" "2" "5" "med"
  if(level === 'med') el.classList.add('mgMed');
  else if(level >= 5) el.classList.add('mg5');
  else if(level >= 2) el.classList.add('mg2');
  else el.classList.add('mg1');
}

// crea overlay subito (cos√¨ non ‚Äúsalta‚Äù al primo toggle)
ensureMagic(btnBoostCount);
ensureMagic(btnFoodBoost);
ensureMagic(btnDance);

    // Camera buttons
    const btnCamBack  = $('btnCamBack');
    const btnCamFPS   = $('btnCamFPS');
    const btnCamFront = $('btnCamFront');

    // Debug
    const btnDebug = $('btnDebug');
    const debugPanel = $('debugPanel');
    const dbgFps = $('dbgFps');
    const dbgCam = $('dbgCam');
    const dbgMode = $('dbgMode');
    const dbgState = $('dbgState');
    const dbgEnt = $('dbgEnt');
    const dbgLane = $('dbgLane');
    const dbgBoosts = $('dbgBoosts');

// ===== Settings overlay (FIX) =====
const settingsOverlay  = $('settingsOverlay');
const closeSettingsBtn = $('btnCloseSettings');
const resetCamBtn      = $('resetCam');

// Tabs
const tabCam    = $('tabCam');
const tabVisual = $('tabVisual');
const tabAudio  = $('tabAudio');

// (opzionale) metti la X un po' pi√π in alto via JS (se vuoi farlo in CSS, vedi sotto)
if (closeSettingsBtn) {
  closeSettingsBtn.style.top = '2px';   // <-- pi√π in alto (prima era 8px * scale)
}

// Tabs switch
function setSettingsTab(tab){
  if(!settingsOverlay) return;

  const cards = settingsOverlay.querySelectorAll('.card');
  for(const c of cards){
    const t = c.getAttribute('data-tab');
    c.style.display = (t === tab) ? 'block' : 'none';
  }

  if(tabCam)    tabCam.classList.toggle('active', tab === 'cam');
  if(tabVisual) tabVisual.classList.toggle('active', tab === 'visual');
  if(tabAudio)  tabAudio.classList.toggle('active', tab === 'audio');
}

// Open / Close (UNA SOLA VOLTA)
function openSettings(){
  if(!settingsOverlay) return;
  settingsOverlay.style.display = 'flex';

  // evita crash se syncCamUI non esiste ancora per qualche motivo
  try { syncCamUI && syncCamUI(); } catch(e){ console.warn('syncCamUI error:', e); }

  setSettingsTab('cam');
}
function closeSettings(){
  if(!settingsOverlay) return;
  settingsOverlay.style.display = 'none';
}

// Event listeners
safeOn(tabCam,    'click', ()=>setSettingsTab('cam'));
safeOn(tabVisual, 'click', ()=>setSettingsTab('visual'));
safeOn(tabAudio,  'click', ()=>setSettingsTab('audio'));

safeOn(btnSettings,      'click', ()=>{ initAudio(); openSettings(); });
safeOn(closeSettingsBtn, 'click', (e)=>{ e.preventDefault(); closeSettings(); });

// (comodo) ESC per chiudere
window.addEventListener('keydown', (e)=>{
  if(e.key === 'Escape' && settingsOverlay && settingsOverlay.style.display === 'flex'){
    closeSettings();
  }
});

// (comodo) click fuori dal pannello per chiudere
safeOn(settingsOverlay, 'pointerdown', (e)=>{
  if(e.target === settingsOverlay) closeSettings();
});

// Toggles / UI refs
const audioToggle  = $('audioToggle');
const audioSwitch  = $('audioSwitch');

const shakeToggle  = $('shakeToggle');
const shakeSwitch  = $('shakeSwitch');

const btnFpsReal   = $('btnFpsReal');
const btnFpsStable = $('btnFpsStable');
const btnFpsLive   = $('btnFpsLive');

const motionToggle = $('motionToggle');
const motionSwitch = $('motionSwitch');

const dynFovToggle = $('dynFovToggle');
const dynFovSwitch = $('dynFovSwitch');

    const fovSlider = $('fovSlider');
    const btnCamProfFront = $('btnCamProfFront');
    const btnCamProfBack  = $('btnCamProfBack');
    const camSlider = $('camSlider');
    const camYSlider = $('camYSlider');
    const frameSlider = $('frameSlider');
    // ‚úÖ valori a destra degli slider (mancavano -> crash)
const fovVal   = $('fovVal');
const camVal   = $('camVal');
const camYVal  = $('camYVal');
const frameVal = $('frameVal');
    // =========================================================
// ‚úÖ Focus slider: mentre trascini, mostra mini barra e NON rompe il drag
// =========================================================
const panelEl = settingsOverlay ? settingsOverlay.querySelector('.panel') : null;
const focusOverlay = $('focusOverlay');
const focusName = $('focusName');
const focusRange = $('focusRange');
const focusValEl = $('focusVal');

let focusActive = false;
let focusReleaseTimer = null;

// riferimenti correnti (slider ‚Äúvero‚Äù + suoi elementi UI)
let _activeSlider = null;
let _activeRow = null;
let _activeCard = null;
let _fmtActive = (v)=>String(v);

function setFocus(on){
  focusActive = !!on;

  // ‚úÖ rende invisibile il pannello mentre usi lo slider
  if(settingsOverlay){
    settingsOverlay.classList.toggle('focusClear', focusActive);
  }

  // mostra / nasconde mini slider overlay
  if(focusOverlay){
    focusOverlay.style.display = focusActive ? 'flex' : 'none';
  }

  // sicurezza: disabilita click sul pannello mentre regoli
  if(panelEl){
    panelEl.style.pointerEvents = focusActive ? 'none' : '';
  }
}

function attachFocusMarks(sliderEl){
  // row = la .settingsRow subito prima dello slider
  const row = sliderEl?.previousElementSibling;
  const card = sliderEl?.closest?.('.card');

  _activeRow = (row && row.classList?.contains('settingsRow')) ? row : null;
  _activeCard = card || null;

  if(_activeRow) _activeRow.classList.add('focusRow');
  if(_activeCard) _activeCard.classList.add('focusCard');
}

function detachFocusMarks(){
  if(_activeRow) _activeRow.classList.remove('focusRow');
  if(_activeCard) _activeCard.classList.remove('focusCard');
  _activeRow = null;
  _activeCard = null;
}

function syncMiniFrom(sliderEl, label){
  if(!focusRange || !sliderEl) return;

  focusRange.min   = sliderEl.min;
  focusRange.max   = sliderEl.max;
  focusRange.step  = sliderEl.step;
  focusRange.value = sliderEl.value;

  if(focusName) focusName.textContent = label;
  if(focusValEl) focusValEl.textContent = _fmtActive(sliderEl.value);
}

function bindFocusToSlider(sliderEl, label, formatFn){
  if(!sliderEl || !focusRange) return;

  const fmt = formatFn || ((v)=>String(v));

  function start(e){
  if(!settingsOverlay || settingsOverlay.style.display !== 'flex') return;

  clearTimeout(focusReleaseTimer);

  _activeSlider = sliderEl;
  _fmtActive = fmt;

  attachFocusMarks(sliderEl);
  syncMiniFrom(sliderEl, label);

  focusRange.disabled = false;
setFocus(true);

// ‚úÖ porta subito focus al mini slider
setTimeout(()=>{
  try{ focusRange.focus({preventScroll:true}); }catch{}
},0);

  // ‚úÖ NON bloccare l‚Äôevento: su iPhone rompe il range
  // try{ e.preventDefault(); }catch{}
}

  function end(){
    clearTimeout(focusReleaseTimer);
    focusReleaseTimer = setTimeout(()=>{
      setFocus(false);
      focusRange.disabled = true;
      _activeSlider = null;
      detachFocusMarks();
    }, 140);
  }

  // start drag
  safeOn(sliderEl, 'pointerdown', start);
  safeOn(sliderEl, 'touchstart', start);

  // se muovi lo slider originale, aggiorna mini
  safeOn(sliderEl, 'input', ()=>{
    if(!focusActive) return;
    syncMiniFrom(sliderEl, label);
  });

  // end drag (originale)
  safeOn(sliderEl, 'pointerup', end);
  safeOn(sliderEl, 'pointercancel', end);
  safeOn(sliderEl, 'touchend', end);
  safeOn(sliderEl, 'change', end);
}

// ‚úÖ quando trascini il mini slider, aggiorna lo slider vero
if(focusRange){
  focusRange.disabled = true;

  focusRange.addEventListener('input', ()=>{
    if(!_activeSlider) return;

    _activeSlider.value = focusRange.value;

    // aggiorna valore numerico e scatena la tua logica (fovVal/camVal ecc)
    _activeSlider.dispatchEvent(new Event('input', { bubbles:true }));

    if(focusValEl) focusValEl.textContent = _fmtActive(focusRange.value);
  });

  // quando molli il mini slider
  focusRange.addEventListener('pointerup', ()=>{ if(focusActive) { /* end gestito dal change */ }});
  focusRange.addEventListener('change', ()=>{
    if(!focusActive) return;
    // chiude con delay come sopra
    clearTimeout(focusReleaseTimer);
    focusReleaseTimer = setTimeout(()=>{
      setFocus(false);
      focusRange.disabled = true;
      _activeSlider = null;
      detachFocusMarks();
    }, 140);
  });
}

// formati valori
bindFocusToSlider(fovSlider,  'FOV',      (v)=>String(Math.round(Number(v))));
bindFocusToSlider(camSlider,  'Distanza', (v)=>Number(v).toFixed(1));
bindFocusToSlider(camYSlider, 'Altezza',  (v)=>Number(v).toFixed(1));
bindFocusToSlider(frameSlider,'Frame',    (v)=>Number(v).toFixed(2));

    // ===== SETTINGS =====
const CAM_KEY = 'jr_cam_settings_v11';

/* ‚úÖ Default ‚Äúdi fabbrica‚Äù (usati solo se non esiste nulla) */
const FACTORY = {
  front: { fov: 60, dist: 5.0, y: 4.6, framing: 0.06 },
  back:  { fov: 60, dist: 5.0, y: 4.6, framing: 0.06 }
};

const saved = (()=>{ try{return JSON.parse(localStorage.getItem(CAM_KEY)||'{}')}catch{return {}} })();

/* ‚úÖ MIGRAZIONE: se vieni dalla v10 (baseFov/baseCamZ/baseCamY/framing)
   allora salviamo quelle impostazioni come STANDARD FRONT (una sola volta). */
const hasStd = saved.std && saved.std.front && saved.std.back;
const oldV10 = (saved.baseFov != null || saved.baseCamZ != null || saved.baseCamY != null || saved.framing != null);

function clampNum(v,a,b){ v=Number(v); return Math.max(a, Math.min(b, v)); }

let std = hasStd ? saved.std : null;
let cam = saved.cam ? saved.cam : null;

/* Se non ho standard, lo creo.
   - Se esiste vecchia v10: STANDARD FRONT = valori attuali (quelli che hai ora)
   - BACK lo metto uguale al FRONT per partire */
if(!std){
  const frontFromOld = {
    fov: clampNum(saved.baseFov ?? FACTORY.front.fov, 30,110),
    dist: clampNum(saved.baseCamZ ?? FACTORY.front.dist, 2,15),
    y: clampNum(saved.baseCamY ?? FACTORY.front.y, 0,8),
    framing: clampNum(saved.framing ?? FACTORY.front.framing, 0,1),
  };
  std = {
    front: { ...frontFromOld },
    back:  { ...frontFromOld }
  };
}

/* Valori correnti (modificabili dagli slider) */
if(!cam){
  cam = {
    front: { ...std.front },
    back:  { ...std.back }
  };
}

/* Flag extra (come prima) */
let shakeEnabled = (saved.shake ?? true) !== false;
let motionBlurEnabled = (saved.motionBlur ?? true) !== false;

let viewMode = (saved.view ?? 'front');
if(!['front','back','fps'].includes(viewMode)) viewMode = 'front';

let debugOn = !!(saved.debug ?? false);

let fpsRealistic = (saved.fpsRealistic ?? true) !== false;
let fpsDynFov    = (saved.fpsDynFov ?? true) !== false;

/* ‚úÖ tab attivo nel menu camera (quale profilo stai modificando) */
let camProfile = 'front'; // 'front' | 'back'

function saveCam(){
  localStorage.setItem(CAM_KEY, JSON.stringify({
    std,
    cam,
    shake: !!shakeEnabled,
    motionBlur: !!motionBlurEnabled,
    view: viewMode,
    debug: !!debugOn,
    fpsRealistic: !!fpsRealistic,
    fpsDynFov: !!fpsDynFov
  }));
}

/* helper: profilo corrente in base a FRONT/BACK selezionato */
function prof(){
  return (camProfile === 'back') ? cam.back : cam.front;
}

/* helper: profilo da usare per la view attuale (front/back/fps) */
function profForView(){
  if(viewMode === 'back') return cam.back;
  return cam.front; // front e fps usano il profilo FRONT
}


    const camThumb = $('camThumb');

function setCamThumb(mode){
  if(!camThumb) return;
  const idx = (mode==='back') ? 0 : (mode==='fps') ? 1 : 2;
  camThumb.style.transform = `translateX(${idx*100}%)`;
}

function setActiveCamBtns(){
  if(btnCamBack)  btnCamBack.classList.toggle('active', viewMode==='back');
  if(btnCamFPS)   btnCamFPS.classList.toggle('active', viewMode==='fps');
  if(btnCamFront) btnCamFront.classList.toggle('active', viewMode==='front');

  // thumb che scorre: 0 = back, 1 = fps, 2 = front
  const thumb = document.getElementById('camThumb');
  if(thumb){
    const idx = (viewMode==='back') ? 0 : (viewMode==='fps' ? 1 : 2);
    thumb.style.transform = `translateX(${idx * 100}%)`;
  }
}

    function setDebugUI(){
      if(debugPanel) debugPanel.style.display = debugOn ? 'block' : 'none';
    }

    function syncCamUI(){
  const p = prof(); // usa camProfile (front/back)

  if(fovSlider){ fovSlider.value = String(Math.round(p.fov)); }
  if(fovVal){ fovVal.textContent = String(Math.round(p.fov)); }

  if(camSlider){ camSlider.value = String(p.dist.toFixed(1)); }
  if(camVal){ camVal.textContent = p.dist.toFixed(1); }

  if(camYSlider){ camYSlider.value = String(p.y.toFixed(1)); }
  if(camYVal){ camYVal.textContent = p.y.toFixed(1); }

  if(frameSlider){ frameSlider.value = String(p.framing.toFixed(2)); }
  if(frameVal){ frameVal.textContent = p.framing.toFixed(2); }

  if(shakeSwitch){ shakeSwitch.classList.toggle('on', !!shakeEnabled); }
  if(audioSwitch){ audioSwitch.classList.toggle('on', !!audioEnabled); }

  if(btnFpsReal)   btnFpsReal.classList.toggle('active', !!fpsRealistic);
  if(btnFpsStable) btnFpsStable.classList.toggle('active', !fpsRealistic);

  if(motionSwitch) motionSwitch.classList.toggle('on', !!motionBlurEnabled);
  if(dynFovSwitch) dynFovSwitch.classList.toggle('on', !!fpsDynFov);

  if(btnFpsLive) btnFpsLive.style.display = 'none';

  // profilo FRONT/BACK UI
  if(btnCamProfFront) btnCamProfFront.classList.toggle('active', camProfile==='front');
  if(btnCamProfBack)  btnCamProfBack.classList.toggle('active', camProfile==='back');

  setActiveCamBtns();
  setDebugUI();
}

// ===== CAMERA PROFILE (FRONT / BACK) =====
function setCamProfile(p){
  camProfile = (p === 'back') ? 'back' : 'front';

  if(btnCamProfFront)
    btnCamProfFront.classList.toggle('active', camProfile === 'front');

  if(btnCamProfBack)
    btnCamProfBack.classList.toggle('active', camProfile === 'back');

  syncCamUI();
}

safeOn(btnCamProfFront, 'click', ()=>{
  initAudio();
  setCamProfile('front');
});

safeOn(btnCamProfBack, 'click', ()=>{
  initAudio();
  setCamProfile('back');
});


safeOn(fovSlider, 'input', ()=>{
  const p = prof();
  p.fov = clamp(Number(fovSlider.value), 30, 110);
  if(fovVal) fovVal.textContent = String(Math.round(p.fov));
  saveCam();
});

safeOn(camSlider, 'input', ()=>{
  const p = prof();
  p.dist = clamp(Number(camSlider.value), 2, 15);
  if(camVal) camVal.textContent = p.dist.toFixed(1);
  saveCam();
});

safeOn(camYSlider,'input', ()=>{
  const p = prof();
  p.y = clamp(Number(camYSlider.value), 0, 8);
  if(camYVal) camYVal.textContent = p.y.toFixed(1);
  saveCam();
});

safeOn(frameSlider,'input', ()=>{
  const p = prof();
  p.framing = clamp(Number(frameSlider.value), 0, 1);
  if(frameVal) frameVal.textContent = p.framing.toFixed(2);
  saveCam();
});
  
    

    function setFpsMode(real){
  fpsRealistic = !!real;
  saveCam();
  syncCamUI();
}

safeOn(btnFpsReal,'click', ()=>{ initAudio(); setFpsMode(true); });
safeOn(btnFpsStable,'click',()=>{ initAudio(); setFpsMode(false); });

safeOn(btnFpsLive,'click', ()=>{
  initAudio();
  setFpsMode(!fpsRealistic);
});

    safeOn(shakeToggle,'click', ()=>{
      shakeEnabled = !shakeEnabled;
      if(shakeSwitch) shakeSwitch.classList.toggle('on', !!shakeEnabled);
      saveCam();
    });

    safeOn(motionToggle,'click', ()=>{
  initAudio();
  motionBlurEnabled = !motionBlurEnabled;
  if(motionSwitch) motionSwitch.classList.toggle('on', !!motionBlurEnabled);
  saveCam();
});

safeOn(dynFovToggle,'click', ()=>{
  initAudio();
  fpsDynFov = !fpsDynFov;
  if(dynFovSwitch) dynFovSwitch.classList.toggle('on', !!fpsDynFov);
  saveCam();
});
    safeOn(resetCamBtn,'click', ()=>{
  if(camProfile === 'back'){
    cam.back = { ...std.back };
  }else{
    cam.front = { ...std.front };
  }

  saveCam();
  syncCamUI();

  // aggiorna subito se stai usando quella view
  applyViewMode(viewMode);
});

    // ===== Audio minimal =====
    let audioEnabled=true, audioReady=false, actx=null, master=null;
    function initAudio(){
      if(audioReady) return;
      try{
        actx = new (window.AudioContext||window.webkitAudioContext)();
        master = actx.createGain(); master.gain.value=0.55; master.connect(actx.destination);
        audioReady=true;
      }catch(e){ audioEnabled=false; }
      if(audioSwitch) audioSwitch.classList.toggle('on',!!audioEnabled);
    }
    function beep(type,freq,dur=0.06,g=0.10){
      if(!audioEnabled) return;
      initAudio(); if(!audioReady) return;
      const t0=actx.currentTime;
      const o=actx.createOscillator();
      const gg=actx.createGain();
      o.type=type; o.frequency.setValueAtTime(freq,t0);
      gg.gain.setValueAtTime(0.0001,t0);
      gg.gain.exponentialRampToValueAtTime(g,t0+0.012);
      gg.gain.exponentialRampToValueAtTime(0.0001,t0+dur);
      o.connect(gg); gg.connect(master);
      o.start(t0); o.stop(t0+dur+0.02);
    }
    const sfx = {
      coin: ()=>{ beep('triangle', 900, 0.06, 0.10); beep('sine', 1350, 0.07, 0.07); },
      food: ()=>{ beep('sine', 520, 0.06, 0.09); },
      ring: ()=>{ beep('triangle', 700, 0.06, 0.10); },
      magnet: ()=>{ beep('sawtooth', 420, 0.10, 0.09); beep('triangle', 880, 0.10, 0.07); },
      hit:  ()=>{ beep('square', 120, 0.12, 0.11); },
      lane: ()=>{ beep('sine', 160, 0.05, 0.05); },
      jump: ()=>{ beep('square', 420, 0.05, 0.08); },
      slide:()=>{ beep('sine', 220, 0.06, 0.06); },
      boost:()=>{ beep('sawtooth', 520, 0.10, 0.09); beep('triangle', 880, 0.10, 0.07); },
    };
    safeOn(audioToggle,'click', ()=>{ initAudio(); audioEnabled=!audioEnabled; if(audioSwitch) audioSwitch.classList.toggle('on',!!audioEnabled); });

    // ===== Renderer / Scene =====
    const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x08120b);
    scene.fog = IS_IOS ? new THREE.Fog(0x08120b, 26, 110) : new THREE.FogExp2(0x06110a, 0.036);
    // ‚úÖ FIX: valori base camera (prima erano in v10, ora li ricaviamo dai profili)
const baseFov  = cam.front.fov;
const baseCamZ = cam.front.dist;
const baseCamY = cam.front.y;
    const camera = new THREE.PerspectiveCamera(baseFov, window.innerWidth/window.innerHeight, 0.1, 320);
    camera.up.set(0,1,0);
    
    // ‚úÖ evita flip strani quando tocchi rotation dopo lookAt
camera.rotation.order = 'YXZ';

// ‚úÖ helper per FPS: azzera roll senza rompere quaternion
const _camEuler = new THREE.Euler(0,0,0,'YXZ');

    // lights
    const sun = new THREE.DirectionalLight(0xf3ffe6, IS_IOS ? 2.8 : 2.1);
    sun.position.set(6, 10, 6);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048,2048);
    sun.shadow.camera.near = 0.5;
    sun.shadow.camera.far = 80;
    sun.shadow.camera.left = -12;
    sun.shadow.camera.right=  12;
    sun.shadow.camera.top  =  12;
    sun.shadow.camera.bottom=-12;
    sun.shadow.bias = -0.00023;
    scene.add(sun);
    scene.add(new THREE.HemisphereLight(0xaaffdd, 0x081209, IS_IOS ? 1.05 : 0.78));
    scene.add(new THREE.AmbientLight(0xffffff, IS_IOS ? 0.6 : 0.24));
    const front = new THREE.DirectionalLight(0xffffff, IS_IOS ? 1.25 : 0.55);
    front.position.set(0, 4, 9);
    scene.add(front);

    // Contact shadow
    function makeContactShadowTexture(size=512){
      const c=document.createElement('canvas'); c.width=c.height=size;
      const g=c.getContext('2d');
      g.clearRect(0,0,size,size);
      const grd=g.createRadialGradient(size/2,size/2,0, size/2,size/2,size*0.48);
      grd.addColorStop(0,'rgba(0,0,0,0.38)');
      grd.addColorStop(0.55,'rgba(0,0,0,0.10)');
      grd.addColorStop(1,'rgba(0,0,0,0)');
      g.fillStyle=grd; g.fillRect(0,0,size,size);
      const t=new THREE.CanvasTexture(c); t.colorSpace=THREE.SRGBColorSpace;
      return t;
    }
    const contact = new THREE.Mesh(
      new THREE.PlaneGeometry(1.5,1.5),
      new THREE.MeshBasicMaterial({ map:makeContactShadowTexture(512), transparent:true, opacity:0.55, depthWrite:false })
    );
    contact.rotation.x = -Math.PI/2;
    contact.position.set(0, 0.02, 0.2);
    scene.add(contact);

    // ===== STRADA =====
    const segLen = 9.0, segCount = 10;
    const laneW = 1.35;
    const mainRoadWidth = laneW * 3;
    const shoulderWidth = 1.40;
    const totalRoadWidth = mainRoadWidth + shoulderWidth;
    const leftEdge = -totalRoadWidth/2;
    const lanesX = [
      leftEdge + laneW*0.5,
      leftEdge + laneW*1.5,
      leftEdge + laneW*2.5,
      leftEdge + mainRoadWidth + shoulderWidth*0.5
    ];

    function makeHighwayTexture(size=1024){
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const g = c.getContext('2d');
      g.fillStyle = '#2b2f35';
      g.fillRect(0,0,size,size);

      for(let i=0;i<20000;i++){
        const x = Math.random()*size, y = Math.random()*size;
        const v = Math.floor(70 + Math.random()*70);
        g.fillStyle = `rgba(${v},${v},${v},${Math.random()*0.10})`;
        g.fillRect(x,y,1,1);
      }

      const px = (worldX)=> Math.round(((worldX - leftEdge) / totalRoadWidth) * size);

      const shoulderStartX = leftEdge + mainRoadWidth;
      g.fillStyle = 'rgba(255,255,255,0.03)';
      g.fillRect(px(shoulderStartX), 0, px(leftEdge+totalRoadWidth) - px(shoulderStartX), size);

      const solidW = Math.max(6, Math.round(size * 0.008));
      const dashW  = Math.max(5, Math.round(size * 0.0065));
      const dashLen = Math.round(size * 0.180);
      const dashGap = Math.round(size * 0.999);

      g.fillStyle = '#f4f6f8';

      const xOuterL = px(leftEdge + 0.03);
      const xOuterR = px(leftEdge + totalRoadWidth - 0.03);
      const xOuterLi = Math.round(xOuterL - solidW/2);
      const xOuterRi = Math.round(xOuterR - solidW/2);
      g.fillRect(xOuterLi, 0, solidW, size);
      g.fillRect(xOuterRi, 0, solidW, size);

      const xShoulderSep = px(shoulderStartX);
      const xShoulderSepI = Math.round(xShoulderSep - solidW/2);
      g.fillRect(xShoulderSepI, 0, solidW, size);

      const xDash1 = px(leftEdge + laneW*1);
      const xDash2 = px(leftEdge + laneW*2);
      const xDash1I = Math.round(xDash1 - dashW/2);
      const xDash2I = Math.round(xDash2 - dashW/2);

      for(let y=0; y<size; y += (dashLen + dashGap)){
        const yi = Math.round(y);
        g.fillRect(xDash1I, yi, dashW, dashLen);
        g.fillRect(xDash2I, yi, dashW, dashLen);
      }

      const t = new THREE.CanvasTexture(c);
      t.colorSpace = THREE.SRGBColorSpace;
      t.wrapS = t.wrapT = THREE.RepeatWrapping;
      t.repeat.set(1.0, 10.0);
      return t;
    }

    function makePatchTexture(size=512){
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const g = c.getContext('2d');
      g.clearRect(0,0,size,size);

      const px = (worldX)=> ((worldX - leftEdge) / totalRoadWidth) * size;
      const centerLaneX = lanesX[1];
      const bandHalfW = laneW * 0.36;
      const xMin = Math.max(0, Math.floor(px(centerLaneX - bandHalfW)));
      const xMax = Math.min(size-1, Math.ceil(px(centerLaneX + bandHalfW)));

      for(let i=0;i<7000;i++){
        const x = xMin + Math.random()*(xMax-xMin);
        const y = Math.random()*size;
        const a = 0.02 + Math.random()*0.05;
        g.fillStyle = `rgba(0,0,0,${a})`;
        g.fillRect(x,y,1,1);
      }

      const stripCount = 8 + Math.floor(Math.random()*7);
      for(let i=0;i<stripCount;i++){
        const x = xMin + Math.random()*(xMax-xMin);
        const w = 14 + Math.random()*36;
        const a = 0.05 + Math.random()*0.12;

        const grad = g.createLinearGradient(x,0,x+w,0);
        grad.addColorStop(0, `rgba(0,0,0,0)`);
        grad.addColorStop(0.5, `rgba(0,0,0,${a})`);
        grad.addColorStop(1, `rgba(0,0,0,0)`);

        g.fillStyle = grad;
        g.fillRect(x, 0, w, size);
      }

      const patchCount = 6 + Math.floor(Math.random()*9);
      for(let i=0;i<patchCount;i++){
        const x = xMin + Math.random()*(xMax-xMin);
        const y = Math.random()*size;
        const w = 60 + Math.random()*170;
        const h = 8 + Math.random()*22;
        const a = 0.05 + Math.random()*0.12;
        g.fillStyle = `rgba(0,0,0,${a})`;
        g.fillRect(x,y,w,h);
      }

      const t = new THREE.CanvasTexture(c);
      t.colorSpace = THREE.SRGBColorSpace;
      t.wrapS = t.wrapT = THREE.RepeatWrapping;
      t.repeat.set(1.0, 10.0);
      return t;
    }

    const highwayTex = makeHighwayTexture(IS_IOS ? 768 : 1024);
    highwayTex.generateMipmaps = false;
    highwayTex.minFilter = THREE.NearestFilter;
    highwayTex.magFilter = THREE.NearestFilter;
    highwayTex.anisotropy = renderer.capabilities.getMaxAnisotropy();
    highwayTex.needsUpdate = true;
    highwayTex.repeat.set(1.0, 4.0);

    const patchTexPool = [
      makePatchTexture(IS_IOS ? 384 : 512),
      makePatchTexture(IS_IOS ? 384 : 512),
      makePatchTexture(IS_IOS ? 384 : 512),
    ];

    const roadMat = new THREE.MeshStandardMaterial({
      map: highwayTex,
      roughness: 0.96,
      metalness: 0.0,
      color: new THREE.Color(0xffffff)
    });

    const segments=[];
    let groupLeft = rndi(2,3);
    let groupShade = 0.94 + Math.random()*0.08;
    let groupPatch = patchTexPool[rndi(0, patchTexPool.length-1)];
    let groupPatchOpacity = 0.16 + Math.random()*0.10;

    for(let i=0;i<segCount;i++){
      const geo = new THREE.PlaneGeometry(totalRoadWidth, segLen);
      geo.rotateX(-Math.PI/2);
      const mesh = new THREE.Mesh(geo, roadMat);

      groupLeft--;
      if(groupLeft <= 0){
        groupLeft = rndi(2,3);
        groupShade = 0.94 + Math.random()*0.08;
        groupPatch = patchTexPool[rndi(0, patchTexPool.length-1)];
        groupPatchOpacity = 0.16 + Math.random()*0.10;
      }

      if(Math.abs(groupShade - 1.0) > 0.0001){
        const m = roadMat.clone();
        m.color = roadMat.color.clone().multiplyScalar(groupShade);
        mesh.material = m;
      }

      const patchGeo = new THREE.PlaneGeometry(totalRoadWidth, segLen);
      patchGeo.rotateX(-Math.PI/2);
      const patchMat = new THREE.MeshStandardMaterial({
        map: groupPatch,
        transparent: true,
        opacity: groupPatchOpacity,
        roughness: 1.0,
        metalness: 0.0,
        depthWrite: false,
        polygonOffset: true,
        polygonOffsetFactor: -1,
        polygonOffsetUnits: -1,
      });
      const patch = new THREE.Mesh(patchGeo, patchMat);
      patch.position.y = 0.003;
      mesh.add(patch);

      const roadHalf = (segLen * segCount) * 0.5;
mesh.position.set(0, 0, (i * segLen) - roadHalf);
      mesh.receiveShadow=true;

      scene.add(mesh);
      segments.push(mesh);
    }

    // terreno laterale
    const sideGeo = new THREE.PlaneGeometry(44, segLen*segCount);
    sideGeo.rotateX(-Math.PI/2);
    const sideMat = new THREE.MeshStandardMaterial({ color:0x0d2416, roughness:1, metalness:0 });
    const side = new THREE.Mesh(sideGeo, sideMat);
    side.position.set(0, -0.02, 0); // ‚úÖ centrato
    side.receiveShadow = true;
    scene.add(side);

    // alberi
    const jungle = new THREE.Group(); scene.add(jungle);
    function makeTree(){
      const g = new THREE.Group();
      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.11, 0.16, 1.6, 10),
        new THREE.MeshStandardMaterial({ color:0x4a3523, roughness:1, metalness:0 })
      );
      trunk.position.y=0.8; trunk.castShadow=true; trunk.receiveShadow=true; g.add(trunk);
      const crown = new THREE.Mesh(
        new THREE.ConeGeometry(0.75, 1.6, 12),
        new THREE.MeshStandardMaterial({ color:0x1c6b33, roughness:1, metalness:0 })
      );
      crown.position.y=1.9; crown.castShadow=true; crown.receiveShadow=true; g.add(crown);
      const crown2 = new THREE.Mesh(
        new THREE.ConeGeometry(0.6, 1.3, 12),
        new THREE.MeshStandardMaterial({ color:0x135226, roughness:1, metalness:0 })
      );
      crown2.position.y=2.3; crown2.castShadow=true; crown2.receiveShadow=true; g.add(crown2);
      return g;
    }
    const treeProto = makeTree();
    const treePool=[];
    const treeSpacing=2.8;
    const treeSideX = (totalRoadWidth/2) + 1.9;
    const jungleCount = Math.floor((segLen*segCount)/treeSpacing);
    for(let i=0;i<jungleCount;i++){
      const wrapZ = segLen * segCount;
const z = (i*treeSpacing) - (wrapZ*0.5);  // ‚úÖ centrati come la strada
      for(const sideSign of [-1,1]){
        const t = treeProto.clone(true);
        t.position.set(sideSign*(treeSideX + rnd(0,1.8)), 0, z);
        t.scale.setScalar(rnd(0.8,1.2));
        t.rotation.y = rnd(0,Math.PI*2);
        t.traverse(o=>{ if(o.isMesh){o.castShadow=true;o.receiveShadow=true;}});
        jungle.add(t); treePool.push(t);
      }
    }
    function loopJungle(scroll){
  const wrapZ = segLen*segCount;
  const halfZ = wrapZ * 0.5;

  for(const obj of treePool){
    obj.position.z += scroll;

    // ‚úÖ wrap bidirezionale come la strada
    if(obj.position.z >  halfZ) obj.position.z -= wrapZ;
    if(obj.position.z < -halfZ) obj.position.z += wrapZ;
  }
}

    // ===== Sprites =====
    function makeEmojiSprite(emoji, size=256){
      const c=document.createElement('canvas'); c.width=c.height=size;
      const g=c.getContext('2d');
      g.clearRect(0,0,size,size);
      g.globalAlpha=0.18;
      g.fillStyle='#cfefff';
      g.beginPath(); g.arc(size/2,size/2,size*0.33,0,Math.PI*2); g.fill();
      g.globalAlpha=1;
      g.font=`${size*0.55}px system-ui, Apple Color Emoji, Segoe UI Emoji`;
      g.textAlign='center'; g.textBaseline='middle';
      g.fillText(emoji, size/2, size/2+8);
      const tex=new THREE.CanvasTexture(c);
      tex.colorSpace=THREE.SRGBColorSpace;
      const mat=new THREE.SpriteMaterial({ map:tex, transparent:true });
      const spr=new THREE.Sprite(mat);
      spr.scale.set(0.78,0.78,1);
      return spr;
    }

    // ‚úÖ OSTACOLI: dimensioni fisse + appoggiati a terra
const OBST_W = 0.85;
const OBST_H = 0.95;
const OBST_D = 0.85;

function spawnObstacleVisual(){
  const box = new THREE.Mesh(
    new THREE.BoxGeometry(OBST_W, OBST_H, OBST_D),
    new THREE.MeshStandardMaterial({ color:0x6b4b2b, roughness:0.9, metalness:0.02 })
  );
  box.castShadow = true;
  box.receiveShadow = true;
  return box;
}
    function makeTurtle(){
  const g = new THREE.Group();
  const shell = new THREE.Mesh(
    new THREE.SphereGeometry(0.35, 18, 14),
    new THREE.MeshStandardMaterial({ color:0x1f6a3a, roughness:0.9, metalness:0.02 })
  );
  shell.scale.set(1.2,0.75,1.0);
  shell.position.y=0.35;
  g.add(shell);

  const head = new THREE.Mesh(
    new THREE.SphereGeometry(0.16, 16, 12),
    new THREE.MeshStandardMaterial({ color:0x2f8a4d, roughness:0.9, metalness:0.02 })
  );
  head.position.set(0,0.25,0.42);
  g.add(head);

  // ‚úÖ per cambiare colore dopo il colpo
  g.userData.mats = [shell.material, head.material];

  return g;
}
    
    // =========================================================
// ‚úÖ TURTLE EXPLOSION FX (flash + particles + shockwave)
// =========================================================
function makeRadialTex(size=256){
  const c=document.createElement('canvas'); c.width=c.height=size;
  const g=c.getContext('2d');
  g.clearRect(0,0,size,size);
  const grd=g.createRadialGradient(size/2,size/2,0, size/2,size/2,size*0.5);
  grd.addColorStop(0,'rgba(255,255,255,0.95)');
  grd.addColorStop(0.2,'rgba(255,210,120,0.55)');
  grd.addColorStop(0.55,'rgba(255,70,50,0.22)');
  grd.addColorStop(1,'rgba(0,0,0,0)');
  g.fillStyle=grd;
  g.fillRect(0,0,size,size);
  const t=new THREE.CanvasTexture(c);
  t.colorSpace = THREE.SRGBColorSpace;
  return t;
}

const _explTex = makeRadialTex(256);

function makeDustTex(size=256){
  const c=document.createElement('canvas'); c.width=c.height=size;
  const g=c.getContext('2d');
  g.clearRect(0,0,size,size);

  const grd=g.createRadialGradient(size/2,size/2,0, size/2,size/2,size*0.48);
  grd.addColorStop(0,'rgba(200,200,200,0.55)');
  grd.addColorStop(0.35,'rgba(160,160,160,0.22)');
  grd.addColorStop(1,'rgba(0,0,0,0)');
  g.fillStyle=grd;
  g.fillRect(0,0,size,size);

  const t=new THREE.CanvasTexture(c);
  t.colorSpace = THREE.SRGBColorSpace;
  return t;
}

const _dustTex = makeDustTex(256);

function makeShockTex(size=256){
  const c=document.createElement('canvas'); c.width=c.height=size;
  const g=c.getContext('2d');
  g.clearRect(0,0,size,size);

  // anello morbido
  const grd=g.createRadialGradient(size/2,size/2,size*0.20, size/2,size/2,size*0.48);
  grd.addColorStop(0.00,'rgba(255,255,255,0)');
  grd.addColorStop(0.35,'rgba(255,255,255,0.00)');
  grd.addColorStop(0.55,'rgba(255,255,255,0.55)');
  grd.addColorStop(0.70,'rgba(255,255,255,0.18)');
  grd.addColorStop(1.00,'rgba(255,255,255,0)');
  g.fillStyle=grd;
  g.fillRect(0,0,size,size);

  const t=new THREE.CanvasTexture(c);
  t.colorSpace = THREE.SRGBColorSpace;
  return t;
}
const _shockTex = makeShockTex(256);

function spawnDust(x, z){
  // sprite a terra, leggerissimo
  const spr = new THREE.Sprite(new THREE.SpriteMaterial({
    map:_dustTex,
    transparent:true,
    opacity:0.35,
    depthWrite:false
  }));
  spr.position.set(
    x + rnd(-0.12, 0.12),
    0.05,
    z + rnd(-0.10, 0.10)
  );

  const s0 = rnd(0.45, 0.70);
  spr.scale.set(s0, s0, 1);
  scene.add(spr);

  game.effects.push({
    type:'dust',
    spr,
    t:0,
    life: rnd(0.35, 0.55),
    s0,
    sGrow: rnd(0.80, 1.35),
    maxOp: rnd(0.22, 0.40),
    vx: rnd(-0.12, 0.12),
    vy: rnd(0.15, 0.35),
    vz: rnd(0.05, 0.22)
  });
}

function spawnTurtleExplosion(x, z){
  const g = new THREE.Group();
  g.position.set(x, 0.02, z);

  // FLASH (sempre visibile sopra la strada)
const flashMat = new THREE.SpriteMaterial({
  map:_explTex,
  transparent:true,
  opacity:0.95,
  depthWrite:false,
  depthTest:false,                      // ‚úÖ non viene nascosto dalla strada
  blending:THREE.AdditiveBlending
});
const flash = new THREE.Sprite(flashMat);
flash.renderOrder = 999;                // ‚úÖ priorit√† render
flash.scale.set(2.6, 2.6, 1);
flash.position.y = 0.85;                // leggermente pi√π alto
g.add(flash);

    // SHOCKWAVE (ORIZZONTALE A TERRA)
  const waveMat = new THREE.MeshBasicMaterial({
    map: _shockTex,
    transparent: true,
    opacity: 0.85,
    depthWrite: false,
    depthTest: false,                 // ‚úÖ sempre visibile sopra la strada
    blending: THREE.AdditiveBlending,
    side: THREE.DoubleSide
  });

  const waveGeo = new THREE.PlaneGeometry(1, 1); // verr√† scalata
  const wave = new THREE.Mesh(waveGeo, waveMat);
  wave.renderOrder = 998;

  wave.rotation.x = -Math.PI / 2;     // ‚úÖ orizzontale (a terra)
  wave.position.y = 0.03;             // ‚úÖ appena sopra il terreno/strada (evita z-fighting)
  wave.scale.set(0.35, 0.35, 1);

  g.add(wave);

  // PARTICELLE (piccoli sprite)
  const parts = [];
  const n = IS_IOS ? 22 : 34;
  for(let i=0;i<n;i++){
    const p = new THREE.Sprite(new THREE.SpriteMaterial({
      map:_explTex,
      transparent:true,
      opacity:0.85,
      depthWrite:false
    }));
    p.scale.set(0.35, 0.35, 1);
    p.position.set(rnd(-0.15,0.15), rnd(0.25,0.85), rnd(-0.15,0.15));
    g.add(p);

    parts.push({
      spr:p,
      vx:rnd(-1.8,1.8),
      vy:rnd(1.2,3.2),
      vz:rnd(-2.2,1.0),
      spin:rnd(-5,5)
    });
  }

  scene.add(g);

  // registra come ‚Äúeffect‚Äù aggiornabile
  game.effects.push({
    type:'turtleExpl',
    g,
    t:0,
    flash,
    wave,
    parts
  });

  // piccolo SFX
  try{ sfx.hit(); }catch{}
}

function updateEffects(dt){
  if(!game.effects || game.effects.length===0) return;

  for(let i=game.effects.length-1; i>=0; i--){
    const fx = game.effects[i];
    fx.t += dt;

    // ===============================
    // TURTLE EXPLOSION
    // ===============================
    if(fx.type === 'turtleExpl'){
      const t = fx.t;

      // FLASH
      const fLife = 0.18;
      const fP = clamp(t / fLife, 0, 1);
      fx.flash.material.opacity = (1 - fP) * 0.95;
      const fS = 2.6 + fP * 2.2;
      fx.flash.scale.set(fS, fS, 1);

      // SHOCKWAVE (anello)
            // SHOCKWAVE (sprite)
      const wLife = 0.55;
      const wP = clamp(t / wLife, 0, 1);

      const wS = 0.35 + wP * 4.2;           // cresce molto
      fx.wave.scale.set(wS, wS, 1);

      // fade + leggero ‚Äúsoft pulse‚Äù
      fx.wave.material.opacity = (1 - wP) * 0.85;

      // PARTICELLE
      for(const p of fx.parts){
        const s = p.spr;
        p.vy -= 6.8 * dt;
        s.position.x += p.vx * dt;
        s.position.y += p.vy * dt;
        s.position.z += p.vz * dt;

        const k = 1 + Math.sin((t*12) + p.spin) * 0.12;
        s.scale.set(0.28*k, 0.28*k, 1);
        s.material.opacity = clamp(0.85 - t*1.4, 0, 0.85);
      }

      if(t > 0.9){
        scene.remove(fx.g);
        game.effects.splice(i,1);
      }
      continue;
    }

    // ===============================
    // DUST
    // ===============================
    if(fx.type === 'dust'){
      const t = fx.t;
      const life = fx.life;

      // espansione + fade
      const p = clamp(t / life, 0, 1);
      fx.spr.material.opacity = (1 - p) * fx.maxOp;
      const s = fx.s0 + p * fx.sGrow;
      fx.spr.scale.set(s, s, 1);

      // drift leggero
      fx.spr.position.x += fx.vx * dt;
      fx.spr.position.y += fx.vy * dt;
      fx.spr.position.z += fx.vz * dt;

      // ‚Äúcade‚Äù un pelo
      fx.vy -= 1.2 * dt;

      if(t > life){
        scene.remove(fx.spr);
        game.effects.splice(i,1);
      }
      continue;
    }
  }
}
    function makeVerticalRing(){
      const ring = new THREE.Mesh(
        new THREE.TorusGeometry(0.55, 0.09, 14, 44),
        new THREE.MeshStandardMaterial({
          color:0xff4444,
          roughness:0.35,
          metalness:0.05,
          emissive:0x660000,
          emissiveIntensity:0.55
        })
      );
      ring.castShadow=true; ring.receiveShadow=true;
      return ring;
    }

    // ===== Runner =====
    const runnerPivot = new THREE.Group(); scene.add(runnerPivot);
    const runnerCenter = new THREE.Group(); runnerCenter.position.set(0, 0.95, 0); runnerPivot.add(runnerCenter);
    const runnerModel = new THREE.Group(); runnerModel.position.set(0, -0.95, 0); runnerCenter.add(runnerModel);

    // Bubble
    const bubble = new THREE.Mesh(
      new THREE.SphereGeometry(0.62, 24, 18),
      new THREE.MeshStandardMaterial({
        color:0x66ffcc, roughness:0.25, metalness:0.0,
        emissive:0x33ffaa, emissiveIntensity:0.7,
        transparent:true, opacity:0.22
      })
    );
    bubble.position.set(0, 0.95, 0);
    bubble.visible=false;
    runnerPivot.add(bubble);

    // fallback dummy (se GLB manca)
    const fallbackRunner = new THREE.Group();
    const dummyBody = new THREE.Mesh(
      new THREE.CapsuleGeometry(0.22, 0.55, 8, 16),
      new THREE.MeshStandardMaterial({ color:0x9db79a, roughness:0.65, metalness:0.0 })
    );
    dummyBody.position.y=0.85; dummyBody.castShadow=true; fallbackRunner.add(dummyBody);
    const dummyHead = new THREE.Mesh(
      new THREE.SphereGeometry(0.18, 18, 14),
      new THREE.MeshStandardMaterial({ color:0xb7ccb2, roughness:0.6, metalness:0.0 })
    );
    dummyHead.position.set(0, 1.25, 0.05); dummyHead.castShadow=true; fallbackRunner.add(dummyHead);

    // ===== GLB loader + Animations =====
    const gltfLoader = new GLTFLoader();

    const RUNNER_GLB_URL = './running.glb';
    const ANIM_FILES = {
      idle: ['./DwarfIdle.glb', './WarriorIdle.glb', './HappyIdle.glb'],
      jump: './JumpOver.glb',
      flip: './RunningForwardFlip.glb',
      kick: './SoccerKick.glb',
      die:  './SideHitDie.glb',
      dance:'./HipHopDance.glb'
    };

    function setShadows(root){
      root.traverse(o=>{ if(o.isMesh){ o.castShadow=true; o.receiveShadow=true; } });
    }
    function removeBigNonSkinnedPlanes(model){
      model.traverse(o=>{
        if(!o.isMesh) return;
        const isSkinned = (o.isSkinnedMesh === true) || (o.skeleton != null);
        if(isSkinned) return;

        const box = new THREE.Box3().setFromObject(o);
        const s = new THREE.Vector3(); box.getSize(s);

        const huge = (s.x > 2.4 || s.y > 2.4 || s.z > 2.4);
        const flat = (Math.min(s.x,s.y,s.z) < 0.03 && Math.max(s.x,s.y,s.z) > 1.6);

        const name = (o.name||'').toLowerCase();
        const suspicious = name.includes('plane') || name.includes('cube') || name.includes('quad') || name.includes('ground') || name.includes('floor');

        if(huge || flat || suspicious) o.visible = false;
      });
    }
    function stripRootMotion(clip){
      const c = clip.clone();
      const TH = 0.02;
      try{
        for(const t of c.tracks){
          const name = (t.name || '').toLowerCase();
          if(!name.endsWith('.position')) continue;
          const v = t.values;
          if(!v || v.length < 6) continue;

          let minX=Infinity, maxX=-Infinity, minZ=Infinity, maxZ=-Infinity;
          for(let i=0;i<v.length;i+=3){
            const x=v[i], z=v[i+2];
            if(x<minX) minX=x; if(x>maxX) maxX=x;
            if(z<minZ) minZ=z; if(z>maxZ) maxZ=z;
          }
          const rangeX=maxX-minX, rangeZ=maxZ-minZ;
          if(rangeX>TH || rangeZ>TH){
            const baseX=v[0], baseZ=v[2];
            for(let i=0;i<v.length;i+=3){
              v[i]=baseX;
              v[i+2]=baseZ;
            }
          }
        }
      }catch(err){ console.warn('stripRootMotion fallback:', err); }
      return c;
    }

    let runnerMixer=null;
    let actions = { run:null, idles:[], jump:null, flip:null, kick:null, die:null, dance:null };
    let mixamoHips=null, mixamoRootNode=null, headBone=null;
    let hipsBaseX=0, hipsBaseZ=0, rootBaseX=0, rootBaseZ=0;

    // FPS: testa/maschera INVISIBILE ma con OMBRE corrette (shadow-only)
    let fpsHiddenMeshes = [];

    function setFpsMaskHidden(on){
      if(viewMode==='fps') bubble.visible = false;

      // ripristina tutto
      for(const it of fpsHiddenMeshes){
        const m = it.mesh;
        try{
          m.visible = it.visible;
          m.castShadow = it.castShadow;
          if(m.material){
            const mats = Array.isArray(m.material) ? m.material : [m.material];
            const saved = it.materialStates || [];
            for(let i=0;i<mats.length;i++){
              const mat = mats[i];
              const st  = saved[i];
              if(!mat || !st) continue;
              mat.transparent = st.transparent;
              mat.opacity     = st.opacity;
              mat.colorWrite  = st.colorWrite;
              mat.depthWrite  = st.depthWrite;
              mat.depthTest   = st.depthTest;
              mat.needsUpdate = true;
            }
          }
        }catch{}
      }
      fpsHiddenMeshes = [];
      if(!on) return;

      // nasconde solo head/face/hair/helmet/mask ecc‚Ä¶ ma mantiene le ombre
      runnerModel.traverse(o=>{
        if(!o.isMesh) return;

        const n = (o.name||'').toLowerCase();
        const hit =
          n.includes('head') || n.includes('face') || n.includes('hair') ||
          n.includes('helmet') || n.includes('hat') || n.includes('mask') ||
          n.includes('cap') || n.includes('hood') || n.includes('visor');

        if(!hit) return;

        const mats = o.material ? (Array.isArray(o.material) ? o.material : [o.material]) : [];
        const materialStates = mats.map(mat => mat ? ({
          transparent: mat.transparent,
          opacity: mat.opacity,
          colorWrite: mat.colorWrite,
          depthWrite: mat.depthWrite,
          depthTest: mat.depthTest
        }) : null);

        fpsHiddenMeshes.push({
          mesh: o,
          visible: o.visible,
          castShadow: o.castShadow,
          materialStates
        });

        // shadow-only: invisibile ma continua a fare ombre
        o.visible = true;
        o.castShadow = true;

        for(const mat of mats){
          if(!mat) continue;
          mat.transparent = true;
          mat.opacity = 0.0;
          mat.colorWrite = false;
          mat.depthWrite = false;
          mat.depthTest  = true;
          mat.needsUpdate = true;
        }
      });
    }

    const animState = { mode:'idle' };
    let deadSnapPending = false;

    function collectAllActions(){
      const all=[];
      if(actions.run) all.push(actions.run);
      if(actions.jump) all.push(actions.jump);
      if(actions.flip) all.push(actions.flip);
      if(actions.kick) all.push(actions.kick);
      if(actions.die)  all.push(actions.die);
      if(actions.dance)all.push(actions.dance);
      for(const a of actions.idles) all.push(a);
      return all;
    }
    function fadeTo(next, fade=0.18){
      if(!next) return;
      const all = collectAllActions();
      for(const a of all){
        if(a && a !== next){ try{ a.fadeOut(fade); }catch{} }
      }
      try{
        next.reset();
        next.enabled = true;
        next.setEffectiveWeight(1.0);
        next.fadeIn(fade);
        next.play();
      }catch{}
    }
    function playRun(){
      if(!actions.run || animState.mode==='dead') return;
      animState.mode='run';
      actions.run.setLoop(THREE.LoopRepeat, Infinity);
      actions.run.clampWhenFinished = false;
      fadeTo(actions.run, 0.12);
    }
    function pickRandomIdle(){
      if(!actions.idles.length || animState.mode==='dead') return;
      const a = actions.idles[rndi(0, actions.idles.length-1)];
      a.setLoop(THREE.LoopOnce, 1);
      a.clampWhenFinished = true;
      a.time = 0;
      animState.mode='idle';
      fadeTo(a, 0.20);
    }
    function startIdleRandom(){
      if(animState.mode==='dead') return;
      pickRandomIdle();
    }
    function playOneShot(action, fade=0.08){
      if(!action || animState.mode==='dead') return;
      animState.mode='oneShot';
      action.reset();
      action.setLoop(THREE.LoopOnce, 1);
      action.clampWhenFinished = true;
      action.enabled = true;
      action.setEffectiveWeight(1.0);
      fadeTo(action, fade);
    }
    function playDance(){
      if(!actions.dance || animState.mode==='dead') return;
      animState.mode='dance';
      actions.dance.setLoop(THREE.LoopRepeat, Infinity);
      actions.dance.clampWhenFinished = false;
      fadeTo(actions.dance, 0.18);
    }

    function snapRunnerToGround(){
      try{
        const root = runnerModel.children[0];
        if(!root) return;
        const box = new THREE.Box3().setFromObject(root);
        const dy = -box.min.y;
        if(Number.isFinite(dy) && Math.abs(dy) > 0.0001){
          root.position.y += dy;
        }
      }catch{}
    }

    function playDie(){
      if(!actions.die) return;
      animState.mode='dead';
      deadSnapPending = true;
      actions.die.reset();
      actions.die.setLoop(THREE.LoopOnce, 1);
      actions.die.clampWhenFinished = true;
      fadeTo(actions.die, 0.08);
    }

    /* ‚úÖ FIX RESTART: reset totale delle animazioni (esce da "dead") */
    function resetAnimationsToIdle(){
      animState.mode = 'idle';
      deadSnapPending = false;
      const all = collectAllActions();
      for(const a of all){
        if(!a) continue;
        try{
          a.stop();
          a.reset();
          a.enabled = true;
          a.setEffectiveWeight(0);
          a.clampWhenFinished = false;
        }catch{}
      }
      startIdleRandom();
      setFpsMaskHidden(viewMode==='fps');
    }

    async function loadAnimClip(url){
      return new Promise((resolve)=>{
        gltfLoader.load(url, (gltf)=>{
          const clips = (gltf.animations||[]).filter(c=>c && c.tracks && c.tracks.length);
          resolve(clips[0] || null);
        }, undefined, ()=>{
          console.warn('Anim load error:', url);
          resolve(null);
        });
      });
    }
    async function loadAllAnimations(){
      for(const u of ANIM_FILES.idle){
        const c = await loadAnimClip(u);
        if(c) actions.idles.push(c);
      }
      actions.jump  = await loadAnimClip(ANIM_FILES.jump);
      actions.flip  = await loadAnimClip(ANIM_FILES.flip);
      actions.kick  = await loadAnimClip(ANIM_FILES.kick);
      actions.die   = await loadAnimClip(ANIM_FILES.die);
      actions.dance = await loadAnimClip(ANIM_FILES.dance);
    }

    async function loadRunnerModel(){
      return new Promise((resolve)=>{
        gltfLoader.load(RUNNER_GLB_URL, async (gltf)=>{
          const model = gltf.scene;

          model.position.set(0,0,0);
          model.scale.setScalar(0.95);
          setShadows(model);

          model.traverse(o=>{
            if(o.isMesh && o.material){
              const mats = Array.isArray(o.material) ? o.material : [o.material];
              for(const m of mats){ if(m) m.side = THREE.DoubleSide; }
            }
          });

          removeBigNonSkinnedPlanes(model);

          {
            const box = new THREE.Box3().setFromObject(model);
            const lift = -box.min.y;
            model.position.y += lift + 0.01;
          }

          model.rotation.y = Math.PI;

          mixamoHips = null; mixamoRootNode = null; headBone = null;
          model.traverse(o=>{
            const n = (o.name||'').toLowerCase();
            if(!mixamoRootNode && (n.includes('armature') || n === 'root')) mixamoRootNode = o;
            if(o.isBone){
              if(!mixamoHips && (n==='hips' || (n.includes('mixamorig') && n.includes('hips')))) mixamoHips = o;
              if(!headBone && (n==='head' || (n.includes('mixamorig') && n.includes('head')))) headBone = o;
            }
          });
          if(mixamoHips){ hipsBaseX = mixamoHips.position.x; hipsBaseZ = mixamoHips.position.z; }
          if(mixamoRootNode){ rootBaseX = mixamoRootNode.position.x; rootBaseZ = mixamoRootNode.position.z; }

          while(runnerModel.children.length) runnerModel.remove(runnerModel.children[0]);
          runnerModel.add(model);

          runnerMixer = new THREE.AnimationMixer(model);

          await loadAllAnimations();

          const baseClips = (gltf.animations||[]).filter(c=>c && c.tracks && c.tracks.length);
          const runClip = baseClips.find(c => (c.name||'').toLowerCase().includes('run')) || baseClips[0];
          const fixedRun = runClip ? stripRootMotion(runClip) : null;
          if(fixedRun){
            actions.run = runnerMixer.clipAction(fixedRun);
            actions.run.enabled = true;
            actions.run.setEffectiveWeight(1.0);
            actions.run.setEffectiveTimeScale(1.0);
          }

          const idleActions = [];
          for(const clip of actions.idles) idleActions.push(runnerMixer.clipAction(clip));
          actions.idles = idleActions;

          if(actions.jump)  actions.jump  = runnerMixer.clipAction(actions.jump);
          if(actions.flip)  actions.flip  = runnerMixer.clipAction(actions.flip);
          if(actions.kick)  actions.kick  = runnerMixer.clipAction(actions.kick);
          if(actions.die)   actions.die   = runnerMixer.clipAction(actions.die);
          if(actions.dance) actions.dance = runnerMixer.clipAction(actions.dance);

          runnerMixer.addEventListener('finished', ()=>{
            if(animState.mode==='dead'){
              if(deadSnapPending){
                deadSnapPending = false;
                snapRunnerToGround();
              }
              return;
            }
            if(animState.mode==='oneShot'){
              if(game.started && !game.stopped && !game.paused && !game.over) playRun();
              else startIdleRandom();
              return;
            }
            if(animState.mode==='idle'){
              pickRandomIdle();
              return;
            }
          });

          startIdleRandom();
          resolve();
        }, undefined, ()=>{
          while(runnerModel.children.length) runnerModel.remove(runnerModel.children[0]);
          runnerModel.add(fallbackRunner);
          resolve();
        });
      });
    }

    // ===== Game data =====
    const EMOJIS = ["‚ú®","üçÄ","üíé","‚ö°Ô∏è","üåà","üçã","‚≠êÔ∏è","üçì","ü•ù"];
    const FOOD   = ["üçï","üçî","üçü","üåÆ","üç©","üç™","üç∞","üçú","üç£","ü•ê"];
    const HEART  = "‚ù§Ô∏è";
    const MAGNET = "üß≤";
    // ===== MAGNET PULL =====
    const MAGNET_RADIUS = 4.2;   // raggio attrazione (pi√π alto = pi√π potente)
    const MAGNET_PULL   = 14.0;  // forza attrazione

    const BEST_KEY='jungle_runner_best_v4';
    const loadBest=()=>Number(localStorage.getItem(BEST_KEY)||'0')||0;
    const saveBest=(v)=>localStorage.setItem(BEST_KEY,String(v));

    const game = {
      lane:1,
      y:0, vy:0, jumping:false,
      sliding:false, slideT:0,
      autoSlideCooldown:0,

      baseSpeed: 12.9,
      score:0,
      coins:0,
      best: loadBest(),

      maxLives:5,
      lives:3,

      ringCount:0,
      foodCount:0,
      foodHistory:[],
      foodBoostCharges: 0,

      invincibleT:0,
      foodBoostT:0,
      ringBoostT:0,
      magnetT:0,
      trioT:0,

      entities:[],
      effects: [],
      spawnT:0.30,
      // distanza percorsa (per blocchi spawn)
runDist: 0,

// dopo aver raccolto MAGNETE o VITA, blocca entrambi per un po'
noMagHeartUntil: 0,

      paused:false,
      started:false,
      over:false,

      stopped:true,
      stopBlend:1.0,

      lastTurtleZ: [-99999, -99999, -99999],

      /* ‚úÖ info per camera FPS ‚Äúrealistica‚Äù */
      camSpeed: 0,
      grounded: true,
      vyNow: 0
    };

    if(bestEl) bestEl.textContent = String(game.best);

    function hpString(){
      let s="";
      for(let i=0;i<game.maxLives;i++) s += (i<game.lives) ? "‚ù§Ô∏è" : "üñ§";
      return s;
    }

    function pulseBoostCount(){
  if(!btnBoostCount) return;
  btnBoostCount.classList.remove('boostPulse');
  // reflow per riattivare l'animazione
  void btnBoostCount.offsetWidth;
  btnBoostCount.classList.add('boostPulse');
}

function setFoodBoostButtonsEnabled(on){
  if(btnFoodBoost)   btnFoodBoost.classList.toggle('isDisabled', !on);
  if(btnBoostCount)  btnBoostCount.classList.toggle('isDisabled', !on);
}

function updateFoodBoostButton(){
  if(!boostRow || !btnFoodBoost || !foodBoostLbl || !boostCountLbl) return;

  const hasCharges = game.foodBoostCharges > 0;
  const active = game.foodBoostT > 0;

  // ‚úÖ mostra la riga se ho cariche O se il boost √® attivo (cos√¨ si vede ‚Äúbloccato‚Äù)
  boostRow.style.display = (hasCharges || active) ? 'flex' : 'none';

  // ‚úÖ etichette
  foodBoostLbl.textContent = 'BOOST';
  boostCountLbl.textContent = String(game.foodBoostCharges);
    // ‚ú® MAGIA: conteggio cariche
  const c = game.foodBoostCharges;

  if(c <= 0){
    setMagicLevel(btnBoostCount, 0);
  }else if(c === 1){
    setMagicLevel(btnBoostCount, 1);      // magia poca
  }else if(c === 2){
    setMagicLevel(btnBoostCount, 2);      // aumenta
  }else if(c >= 5){
    setMagicLevel(btnBoostCount, 5);      // fortissima (anche >5)
  }else{
    // 3-4: mettiamo intensit√† ‚Äúcome 2‚Äù (aumentata ma non max)
    setMagicLevel(btnBoostCount, 2);
  }
  
    // ‚ú® MAGIA: pulsante BOOST mentre attivo (intensit√† media)
  setMagicLevel(btnFoodBoost, (game.foodBoostT > 0) ? 'med' : 0);

  // ‚úÖ blocco utilizzo finch√© boost attivo
  setFoodBoostButtonsEnabled(!active);
}

function refreshFoodUI(){
  if(!foodStack || !foodCountEl) return;

  foodStack.innerHTML = "";
  const show = game.foodHistory.slice(-6).reverse();
  for(const emo of show){
    const d=document.createElement('div');
    d.className = 'foodItem pillFx';
    d.textContent=emo;
    foodStack.appendChild(d);
  }
  // ‚úÖ pop sull‚Äôultima pillola creata (quando raccogli)
if(game._foodPop){
  const first = foodStack.firstElementChild; // perch√© reverse()
  if(first) {
    first.classList.remove('foodPop');
    void first.offsetWidth;
    first.classList.add('foodPop');
  }
  game._foodPop = false;
}
  foodCountEl.textContent = String(game.foodCount);

  // ‚úÖ cos√¨ rimane sempre coerente anche il bottone
  updateFoodBoostButton();
}

    function setBoostUI(){
      if(!pillBoost || !boostBar || !boostIcon || !boostName) return;

      const t = Math.max(game.foodBoostT, game.ringBoostT);
      if(t <= 0){
        pillBoost.style.display='none';
        boostBar.style.width='0%';
        return;
      }
      pillBoost.style.display='flex';

      const both = (game.foodBoostT>0 && game.ringBoostT>0);
      if(both){ boostIcon.textContent='üî•'; boostName.textContent='MEGA'; }
      else if(game.foodBoostT>0){ boostIcon.textContent='üçî'; boostName.textContent='FOOD'; }
      else { boostIcon.textContent='‚≠ïÔ∏è'; boostName.textContent='RING'; }

      const dur = 10.0;
      const pct = clamp((t/dur)*100,0,100);
      boostBar.style.width = pct.toFixed(1)+'%';
    }

    function updateMainButton(){
      if(!mainLbl) return;

      if(game.over){
        mainLbl.textContent = 'RESTART';
        return;
      }
      if(!game.started){
        mainLbl.textContent = 'AVVIA';
        return;
      }
      if(game.stopped){
        mainLbl.textContent = 'AVVIA';
        return;
      }
      mainLbl.textContent = 'STOP';
    }

    function obstacleMultiplier(){
      const steps = Math.floor(game.score / 5000);
      return 1 + 0.05 * steps;
    }

    // ===== Spawn =====
    const TURTLE_VIS_Z = 70;
    // ‚Äúdistanza visibile‚Äù usata per blocco spawn (2x)
const VISIBLE_ROAD_DIST = TURTLE_VIS_Z;        // 70 (coerente col tuo tuning)
const MAGHEART_BLOCK_DIST = VISIBLE_ROAD_DIST * 2; // ‚úÖ 2xd
const TURTLE_MIN_GAP = TURTLE_VIS_Z * 1.0;

// ‚úÖ range realistico: distrugge SOLO ostacoli vicini davanti a lei
// ‚úÖ pi√π stretto: smasha solo DAVVERO vicino
const TURTLE_SMASH_RANGE = 6.5;     // era 18
const TURTLE_SMASH_FRONT = 0.30;    // era 0.45
const TURTLE_SMASH_MARGIN = 0.55;   // tolleranza ‚Äúfisica‚Äù

    function canSpawnTurtle(lane, z){
      return Math.abs(z - game.lastTurtleZ[lane]) >= TURTLE_MIN_GAP;
    }

    function spawnRow(){
      const z0 = -60 - rnd(0,18);
            // ‚úÖ anti-overlap: blocca spawn troppo vicini nella stessa corsia
      const laneMarks = [[], [], []];
      const canPlace = (lane, z, minDz) => laneMarks[lane].every(v => Math.abs(v - z) > minDz);
      const markPlace = (lane, z) => laneMarks[lane].push(z);

      const blocked=new Set();
      const mult = obstacleMultiplier();

      const p0 = clamp(0.22 / mult, 0.03, 0.22);
      let oCount = 0;
      if(Math.random() >= p0){
        const p2 = clamp(0.38 * mult, 0.18, 0.95);
        oCount = (Math.random() < p2) ? 2 : 1;
      }
      while(blocked.size<oCount) blocked.add(rndi(0,2));

      const coinLanes=new Set();
      const cCount = rndi(1,2);
      while(coinLanes.size<cCount) coinLanes.add(rndi(0,2));

      blocked.forEach(l=>{
  if(!canPlace(l, z0, 2.2)) return;
  const obj = spawnObstacleVisual();
  obj.position.set(lanesX[l], (OBST_H * 0.5) + 0.01, z0);
  scene.add(obj);
  game.entities.push({ type:'obst', lane:l, z:z0, obj });
  markPlace(l, z0);
});

      coinLanes.forEach(l=>{
  const zc = z0 - rnd(0, 5.2);              // prima era 0..2.8 (troppo vicine)
  if(!canPlace(l, zc, 1.3)) return;

  const spr = makeEmojiSprite(EMOJIS[rndi(0,EMOJIS.length-1)]);
  spr.position.set(lanesX[l], 1.10, zc);
  scene.add(spr);
  game.entities.push({ type:'coin', lane:l, z:zc, obj:spr });
  markPlace(l, zc);
});

      if(Math.random() < 0.30){
  const lane=rndi(0,2);
  const zf = z0 - rnd(1, 7.0);
  if(canPlace(lane, zf, 1.4)){
    const emo = FOOD[rndi(0,FOOD.length-1)];
    const spr = makeEmojiSprite(emo);
    spr.position.set(lanesX[lane], 1.15, zf);
    spr.scale.set(0.82,0.82,1);
    scene.add(spr);
    game.entities.push({ type:'food', lane, z:zf, obj:spr, emo });
    markPlace(lane, zf);
  }
}

      if(game.runDist >= game.noMagHeartUntil && Math.random() < 0.08){
  const lane = rndi(0,2);
  const zm = z0 - rnd(1, 7.0);

  if(canPlace(lane, zm, 1.4)){
    const spr = makeEmojiSprite(MAGNET);
    spr.position.set(lanesX[lane], 1.15, zm);
    spr.scale.set(0.90, 0.90, 1);
    scene.add(spr);
    game.entities.push({ type:'magnet', lane, z: zm, obj:spr });

    markPlace(lane, zm);
  }
}

      // ===== HEART (solo se ti manca vita) + cooldown dopo magnete/vita =====
if (game.lives < game.maxLives) {

  // se siamo nel cooldown, non spawnare cuore
  if (game.runDist >= game.noMagHeartUntil) {

    let spawnHeart = false;
    if (game.coins > 0 && game.coins % 30 === 0 && Math.random() < 0.45) spawnHeart = true;
    if (!spawnHeart && Math.random() < 0.03) spawnHeart = true;

    if (spawnHeart) {
      const lane = rndi(0, 2);
      const zh = z0 - rnd(1, 6.0);

      if (canPlace(lane, zh, 1.4)) {
        const spr = makeEmojiSprite(HEART);
        spr.position.set(lanesX[lane], 1.15, zh);
        spr.scale.set(0.92, 0.92, 1);
        scene.add(spr);
        game.entities.push({ type: 'heart', lane, z: zh, obj: spr });
        markPlace(lane, zh);
      }
    }

  }
}

      if(Math.random() < 0.22){
  const lane = rndi(0,2);
  const tz   = z0 - rnd(3,11);

  // ‚úÖ evita che spawnino dentro ostacoli/ring/coin ecc nella stessa corsia
  // (turtle √® ‚Äúgrossa‚Äù, quindi un minDz pi√π alto)
  if(canSpawnTurtle(lane, tz) && canPlace(lane, tz, 2.6)){
    const t = makeTurtle();
    t.position.set(lanesX[lane], 0, tz);
    t.traverse(o=>{ if(o.isMesh){ o.castShadow=true; o.receiveShadow=true; }});
    scene.add(t);

    game.entities.push({
      type:'turtle',
      lane,
      z:tz,
      obj:t,

      hit:false,
      slideV:0,
      slideT:0,
      spinV:0,

      destroyedAny:false,
      hitAge:0,
      exploding:false,
      explodeT:0,
      _initialSlideV:-200
    });

    game.lastTurtleZ[lane] = tz;

    // ‚úÖ IMPORTANTISSIMO: ‚Äúprenota‚Äù quella posizione nella corsia
    markPlace(lane, tz);
  }
}

      if(Math.random() < 0.26){
  const lane = rndi(0,2);
  const baseZ = z0 - rnd(2, 10.0);
  const gap = 0.90;

  // controlla tutte le posizioni prima
  const z1 = baseZ;
  const z2 = baseZ - gap;

  if(canPlace(lane, z1, 1.2) && canPlace(lane, z2, 1.2)){
    for(let k=0;k<2;k++){
      const ring = makeVerticalRing();
      const zr = baseZ - k*gap;
      ring.position.set(lanesX[lane], 0.55, zr);
      scene.add(ring);
      game.entities.push({ type:'ring', lane, z:zr, obj:ring });
      markPlace(lane, zr);
    }
  }
}
} // ‚úÖ CHIUDE spawnRow()

    // ===== Controls =====
    let tiltTarget=0, camRoll=0;

    function moveLane(dir){
      if(game.over||game.paused) return;
      if(!game.started) return;
      if(game.stopped) return;
      if(game.trioT>0) return;
      game.lane = clamp(game.lane+dir, 0, 3);
tiltTarget = clamp(tiltTarget + dir*0.18, -0.22, 0.22);

// micro kick (usato dalla camera FPS, "inerzia")
fpsLaneKick = clamp(fpsLaneKick + dir * 0.55, -1.2, 1.2);

sfx.lane();
    }

    function jump(){
      if(game.over||game.paused) return;
      if(!game.started) return;
      if(game.stopped) return;
      if(!game.jumping && game.y>=-0.001){
        game.jumping=true;
        game.vy = -7.8;
        sfx.jump();
      }
    }

    function slide(){
      if(game.over||game.paused) return;
      if(!game.started) return;
      if(game.stopped) return;
      game.sliding=true;
      game.slideT=0.55;
      sfx.slide();
    }

    window.addEventListener('keydown', (e)=>{
      const k=e.key.toLowerCase();
      if(k==='arrowleft') moveLane(-1);
      if(k==='arrowright') moveLane(1);
      if(k==='arrowup' || k===' ') jump();
      if(k==='arrowdown') slide();
      if(k==='p') togglePause();
    });

    let touchStart=null;
    renderer.domElement.addEventListener('pointerdown',(e)=>{
      initAudio();
      renderer.domElement.setPointerCapture(e.pointerId);
      touchStart={x:e.clientX,y:e.clientY,t:performance.now()};
    });
    renderer.domElement.addEventListener('pointerup',(e)=>{
      if(!touchStart) return;
      const dx=e.clientX-touchStart.x, dy=e.clientY-touchStart.y;
      const adx=Math.abs(dx), ady=Math.abs(dy);
      touchStart=null;
      const min=30;
      if(adx<min && ady<min) return;
      if(adx>ady) moveLane(dx>0?1:-1);
      else { if(dy<0) jump(); else slide(); }
    });

    // ===== View mode handling =====
    function applyViewMode(mode){
      if(!['front','back','fps'].includes(mode)) mode = 'front';
      viewMode = mode;
      saveCam();
      setActiveCamBtns();

      camera.up.set(0,1,0);

      // camera near in FPS per evitare clipping
      if(viewMode==='fps'){
        camera.near = 0.02;
      }else{
        camera.near = 0.1;
      }
      camera.updateProjectionMatrix();

      setFpsMaskHidden(viewMode==='fps');
    }

    function hookCamBtn(btn, mode){
  safeOn(btn,'click', ()=>{
    initAudio();
    applyViewMode(mode);
  });
}
hookCamBtn(btnCamBack,'back');
hookCamBtn(btnCamFPS,'fps');
hookCamBtn(btnCamFront,'front');


    // Debug toggle
    safeOn(btnDebug,'click', ()=>{
      debugOn = !debugOn;
      saveCam();
      setDebugUI();
    });

    // ===== Start/Stop/Pause/Home/Dance =====
    function setStop(on){
      game.stopped = !!on;
      if(game.stopped){
        startIdleRandom();
      }else{
        if(game.started && !game.paused && !game.over) playRun();
      }
      updateMainButton();
    }

    function resetRun(){
      game.lane=1;
      runnerX = lanesX[1];
      game.y=0; game.vy=0; game.jumping=false;
      game.sliding=false; game.slideT=0.55*0;
      game.autoSlideCooldown=0;

      game.score=0; game.coins=0;
      game.ringCount=0;
      game.foodCount=0; game.foodHistory=[];
      game.foodBoostCharges = 0;
      refreshFoodUI();

      game.invincibleT=0;
      game.foodBoostT=0;
      game.ringBoostT=0;
      game.magnetT=0;
      game.trioT=0;

      bubble.visible=false;

      for(const e of game.entities) scene.remove(e.obj);
      game.entities.length=0;

      game.spawnT = 0.30;
      game.over=false;
      game.lives=3;

      game.lastTurtleZ = [-99999, -99999, -99999];

      game.started = false;
      game.paused = false;
      setStop(true);

      resetAnimationsToIdle();

      if(scoreEl) scoreEl.textContent = '0';
      if(coinsEl) coinsEl.textContent = '0';
      if(ringsEl) ringsEl.textContent = '0';
      if(hpTxt) hpTxt.textContent = hpString();
      if(magTxt) magTxt.textContent = 'üß≤ 0';
      setBoostUI();
      
      updateFoodBoostButton();
      updateMainButton();
      startIdleRandom();
    }

    function startGame(){
      game.started = true;
      game.paused = false;
      setStop(false);
      playRun();
      updateMainButton();
    }

    function togglePause(){
      if(game.over) return;
      if(!game.started) return;

      game.paused = !game.paused;

      if(game.paused){
        startIdleRandom();
      }else{
        if(game.started && !game.stopped) playRun();
        else startIdleRandom();
      }
    }

    safeOn(btnMain,'click', ()=>{
      initAudio();

      if(game.over){
        resetRun();
        startGame();
        return;
      }
      if(!game.started){
        startGame();
        return;
      }
      if(game.paused) return;
      setStop(!game.stopped);
    });

    safeOn(btnDance,'click', ()=>{
  initAudio();
  if(game.over) return;

  // ‚úÖ animazione bottone
  if(btnDance){
    btnDance.classList.remove('danceActive');
    void btnDance.offsetWidth;
    btnDance.classList.add('danceActive');
    setTimeout(()=>btnDance.classList.remove('danceActive'), 380);
  }

  if(game.started && !game.paused && !game.stopped) setStop(true);
  playDance();
});

    safeOn(btnHome,'click', ()=>{
      initAudio();
      resetRun();
    });
    
    safeOn(btnFoodBoost,'click', ()=>{
  initAudio();

  // non farlo usare se non stai giocando davvero
  if(game.over || game.paused) return;
  if(!game.started) return;
  if(game.stopped) return;

  // ‚úÖ se boost gi√† attivo: niente spam
  if(game.foodBoostT > 0) return;

  if(game.foodBoostCharges <= 0) return;

  // consuma 1 carica
  game.foodBoostCharges -= 1;

  // attiva boost cibo
  game.foodBoostT = 10.0;
  game.invincibleT = Math.max(game.invincibleT, 10.0);
  bubble.visible = true;

  // ‚úÖ animazioni + lock
  pulseBoostCount();
  updateFoodBoostButton();     // disabilita i bottoni mentre √® attivo
  sfx.boost();
});

    // ===== Life / pickups =====
    function loseLife(){
      if(game.invincibleT>0) return;
      game.lives = Math.max(0, game.lives-1);
      sfx.hit();
      if(game.lives<=0){
        game.over=true;
        game.started=false;
        game.paused=false;
        setStop(true);
        playDie();
        updateMainButton();
      }
    }
    function addLife(){
      game.lives = Math.min(game.maxLives, game.lives+1);
      sfx.boost();
    }

    // ===== Update loop =====
    let camZ = baseCamZ, camY = baseCamY, camFov = baseFov, camX = 0;
    let tPrev=performance.now();
    // ‚úÖ Lane smoothing (posizione X del runner ‚Äúmorbida‚Äù)
    let runnerX = lanesX[game.lane];
    let runPhase = 0; // ‚úÖ fase per bob corsa
    // ===== HEAVY SHAKE STATE =====
let hsX = 0, hsY = 0;
let hsVX = 0, hsVY = 0;
let hsTX = 0, hsTY = 0;
let hsTimer = 0;
    // debug fps
    let fpsAcc=0, fpsN=0, fpsShow=0;
    let dbgTimer=0;

    // ‚úÖ FPS camera state (bob + sway ‚Äúreale‚Äù + spring)
    let fpsPhase = 0;
    let fpsX = 0, fpsY = 0;
    let fpsXPrev = 0;
    let fpsLandKick = 0;      // piccolo ‚Äúkick‚Äù atterraggio
    let fpsVyPrev = 0;
    let fpsGroundPrev = true;
    let fpsVelYSm = 0;
    let fpsLaneKick = 0;
    let _prevFoodBoostActive = false;
    let _prevDanceActive = false;
    // ‚úÖ HEAVY CAMERA SHAKE (rotazionale tipo FPS shot)
let boostShakeKick = 0;         // kick iniziale
let _prevAnyBoost = false;      // per rilevare start boost
    // ‚úÖ SHAKE STATE (persistente)
let shX = 0, shY = 0;
let shTX = 0, shTY = 0;
let shTimer = 0;
    function turtleSmashSweep(turtle, prevZ, newZ){
  const lane = turtle.lane;

  // z "front" in entrambi gli istanti
  const prevFront = prevZ - TURTLE_SMASH_FRONT;
  const newFront  = newZ  - TURTLE_SMASH_FRONT;

  // intervallo attraversato dal front in questo frame (+ margine)
  const zA = Math.min(prevFront, newFront) - TURTLE_SMASH_MARGIN;
  const zB = Math.max(prevFront, newFront) + TURTLE_SMASH_MARGIN;

  // ‚úÖ ulteriore limite: non oltre TURTLE_SMASH_RANGE davanti al front attuale
  const zMinAllowed = newFront - TURTLE_SMASH_RANGE;

  let destroyed = false;

  for(let i = game.entities.length - 1; i >= 0; i--){
    const e = game.entities[i];
    if(e.type !== 'obst') continue;
    if(e.lane !== lane) continue;

    // deve essere nel tratto attraversato + non troppo oltre
    if(e.z >= zA && e.z <= zB && e.z >= zMinAllowed){
      scene.remove(e.obj);
      game.entities.splice(i, 1);
      destroyed = true;
    }
  }
  return destroyed;
}


        function update(dt, tNow){
  // Animazioni
  if(runnerMixer){
    runnerMixer.timeScale = 1.0;
    runnerMixer.update(dt);

    if(mixamoHips){
      mixamoHips.position.x = hipsBaseX;
      mixamoHips.position.z = hipsBaseZ;
    }
    if(mixamoRootNode){
      mixamoRootNode.position.x = rootBaseX;
      mixamoRootNode.position.z = rootBaseZ;
    }
  }

  // Effetti
  updateEffects(dt);

  const gameplayOn = game.started && !game.paused && !game.over;
  const stopTarget = game.stopped ? 1.0 : 0.0;
  game.stopBlend = damp(game.stopBlend, stopTarget, 8, dt);

  if(!gameplayOn){
    runnerPivot.position.x = lanesX[1];
    runnerPivot.position.y = 0;

    contact.position.x = runnerPivot.position.x;
    contact.scale.set(1.10, 1.10, 1);
    contact.material.opacity = 0.55;

    const breathe = Math.sin(tNow*0.0022) * 0.015;
    runnerCenter.position.y = 0.95 + breathe;
    runnerCenter.rotation.z = Math.sin(tNow*0.0016) * 0.015;

    game.camSpeed = 0;
    game.grounded = true;
    game.vyNow = 0;
    return;
  }

  const trafficMul = (1.0 - game.stopBlend);
  if(game.stopped){
    game.camSpeed = 0;
    game.grounded = true;
    game.vyNow = 0;
    return;
  }

  // timers
  if(game.invincibleT>0){
    game.invincibleT = Math.max(0, game.invincibleT - dt*trafficMul);
    if(game.invincibleT<=0) bubble.visible=false;
  }
  if(game.foodBoostT>0) game.foodBoostT = Math.max(0, game.foodBoostT - dt*trafficMul);
  // ‚úÖ quando finisce il food boost, riabilita i bottoni
const _nowFoodBoostActive = (game.foodBoostT > 0);
if(_prevFoodBoostActive && !_nowFoodBoostActive){
  updateFoodBoostButton(); // torna cliccabile se ci sono cariche
}
_prevFoodBoostActive = _nowFoodBoostActive;
// ‚ú® MAGIA sul pulsante DANCE mentre stai ballando
const _nowDanceActive = (animState.mode === 'dance');
if(_nowDanceActive !== _prevDanceActive){
  setMagicLevel(btnDance, _nowDanceActive ? 'med' : 0);
  _prevDanceActive = _nowDanceActive;
}
  if(game.ringBoostT>0) game.ringBoostT = Math.max(0, game.ringBoostT - dt*trafficMul);
  if(game.magnetT>0)    game.magnetT    = Math.max(0, game.magnetT    - dt*trafficMul);

  const anyBoost = (game.foodBoostT>0 || game.ringBoostT>0);
  if(anyBoost && game.invincibleT<0.05){
    game.invincibleT = Math.max(game.invincibleT, Math.max(game.foodBoostT, game.ringBoostT));
    bubble.visible=true;
  }

  const foodMul = (game.foodBoostT>0) ? 2.30 : 1.0;
  const ringMul = (game.ringBoostT>0) ? 3.00 : 1.0;
  const both = (game.foodBoostT>0 && game.ringBoostT>0);
  const crazyMul = both ? 1.03 : 1.0;

  const speedMul = foodMul * ringMul * crazyMul;
  const speed = game.baseSpeed * speedMul * trafficMul;

  // bob corsa
  runPhase += dt * (9.5 + (speedMul-1.0)*2.0);
  const grounded = (game.y === 0 && !game.jumping);
  const bobOn = grounded ? 1.0 : 0.25;
  const slideOn = game.sliding ? 0.35 : 1.0;

  const bobY = Math.abs(Math.sin(runPhase)) * 0.045 * bobOn * slideOn;
  const sway = Math.sin(runPhase*0.5) * 0.035 * bobOn * slideOn;
  const lean = Math.sin(runPhase) * 0.050 * bobOn * slideOn;

  runnerCenter.position.y = 0.95 + bobY;
  runnerCenter.rotation.z = lean;
  runnerCenter.rotation.x = -sway * 0.35;

  // info camera FPS
  game.camSpeed = speed;
  game.grounded = (game.y === 0);
  game.vyNow = game.vy;

  // fisica salto
  const g=22.0;
  game.vy += g*dt;
  game.y  += game.vy*dt;
  if(game.y>0){ game.y=0; game.vy=0; game.jumping=false; }

  if(game.sliding){
    game.slideT -= dt;
    if(game.slideT<=0) game.sliding=false;
  }

  // smooth lane follow
  const laneTargetX = lanesX[ clamp(game.lane, 0, 3) ];
  runnerX = damp(runnerX, laneTargetX, 14, dt);
  runnerPivot.position.x = runnerX;
  runnerPivot.position.y = (-game.y);

  // contact shadow
  const h = runnerPivot.position.y;
  const s = 1.10 + clamp(h*0.65, 0, 0.85);
  contact.position.x = runnerPivot.position.x;
  contact.scale.set(s,s,1);
  contact.material.opacity = clamp(0.55 - h*0.24, 0.10, 0.55);

  // scroll
  const scroll = speed*dt;
  game.runDist += scroll;
  for(let l=0; l<3; l++) game.lastTurtleZ[l] += scroll;

  highwayTex.offset.y -= scroll*0.085;
  for(const t of patchTexPool) t.offset.y -= scroll*0.085;

  const roadSpan = segLen * segCount;
const roadHalf = roadSpan * 0.5;

for(const mesh of segments){
  mesh.position.z += scroll;

  // ‚úÖ wrap bidirezionale
  if(mesh.position.z > roadHalf)  mesh.position.z -= roadSpan;
  if(mesh.position.z < -roadHalf) mesh.position.z += roadSpan;
}
  loopJungle(scroll);

  // spawn
  game.spawnT -= dt;
  if(game.spawnT<=0){
    spawnRow();
    game.spawnT = rnd(0.40, 0.75);
  }

  // entities scroll + turtle slide
  for(let i = game.entities.length-1; i >= 0; i--){
    const e = game.entities[i];

    e.z += scroll;
    if(e.obj) e.obj.position.z = e.z;

    if(e.type === 'turtle' && e.hit){
  e.hitAge = (e.hitAge || 0) + dt;

  const mats = e.obj?.userData?.mats || [];
  if(mats.length){
    if(e.hitAge < 0.10) mats.forEach(m => m.color.setHex(0xffd400));
    else                 mats.forEach(m => m.color.setHex(0xff2d2d));
  }

  e.slideT = Math.max(0, e.slideT - dt);
  e.slideV = damp(e.slideV, 0, 6.5, dt);

  const prevZ = e.z;                // ‚úÖ salva prima
  e.z += e.slideV * dt;
  if(e.obj) e.obj.position.z = e.z;
  if(e.obj) e.obj.rotation.y += e.spinV * dt;

  if(e.slideT > 0 && Math.abs(e.slideV) > 15){
    spawnDust(e.obj.position.x, e.z + 0.25);
  }

  const didDestroy = turtleSmashSweep(e, prevZ, e.z);  // ‚úÖ sweep reale
  if(didDestroy) e.destroyedAny = true;

  const almostStopped = (Math.abs(e.slideV) < 6.0) || (e.slideT <= 0);
  if(almostStopped){
    if(!e.destroyedAny){
      spawnTurtleExplosion(e.obj.position.x, e.z);
    }
    scene.remove(e.obj);
    game.entities.splice(i,1);
    continue;
  }
}

    if(e.z > 6){
      scene.remove(e.obj);
      game.entities.splice(i,1);
      continue;
    }
  }
  
    // =========================================================
  // ‚úÖ MAGNETE: attira pickup verso il player
  // =========================================================
  if(game.magnetT > 0){
    const px = runnerPivot.position.x;
    const pz = 0.0; // player √® a z=0
    const py = runnerPivot.position.y + (game.sliding ? 0.55 : 0.95);

    for(const e of game.entities){
      // attira SOLO questi
      if(!(e.type==='coin' || e.type==='food' || e.type==='heart' || e.type==='ring' || e.type==='magnet')) continue;
      if(!e.obj) continue;

      const ox = e.obj.position.x;
      const oy = e.obj.position.y ?? 0;
      const oz = e.z;

      const dx = px - ox;
      const dy = py - oy;
      const dz = pz - oz;

      const d2 = dx*dx + dy*dy + dz*dz;
      if(d2 > MAGNET_RADIUS*MAGNET_RADIUS) continue;

      // forza aumenta quando √® vicino
      const d = Math.max(0.0001, Math.sqrt(d2));
      const k = (MAGNET_PULL * (1.0 - d / MAGNET_RADIUS));

      // ‚Äúvola‚Äù verso il player (nota: e.z √® la verit√† per il gioco)
      e.obj.position.x += (dx / d) * k * dt;
      e.obj.position.y += (dy / d) * k * dt;
      e.z              += (dz / d) * k * dt;
      e.obj.position.z  = e.z;
    }
  }

  // =========================================================
  // ‚úÖ COLLISIONS (ORA √à DENTRO update, quindi niente schermo nero)
  // =========================================================
  const px = runnerPivot.position.x;
  const playerCenterY = runnerPivot.position.y + (game.sliding ? 0.55 : 0.95);

  function collideEntity(ent) {
    const ex = ent.obj.position.x;
    const ey = (ent.obj.position.y ?? 0);
    const ez = ent.z;

    const dx = Math.abs(ex - px);
    const dy = Math.abs(ey - playerCenterY);
    const PLAYER_Z = 0.0;               // player sta a z=0
    const dz = Math.abs(ez - PLAYER_Z);

    const T = {
      coin:   { x: 0.55, y: 0.95, z: 0.80 },
      food:   { x: 0.58, y: 0.98, z: 0.85 },
      heart:  { x: 0.58, y: 0.98, z: 0.85 },
      magnet: { x: 0.60, y: 1.05, z: 0.90 },
      ring:   { x: 0.42, y: 0.75, z: 0.55 },
      obst:   { x: 0.46, y: (game.sliding ? 0.58 : 0.82), z: 0.55 }, // era x0.52 z0.70
      turtle: { x: 0.60, y: 0.55, z: 0.75 }                          // era z0.95
    };

    const th = T[ent.type] || { x: 0.60, y: 1.0, z: 0.85 };

    if (ent.type === 'ring') {
      const yTh = game.sliding ? 0.55 : th.y;
      return (dx < th.x && dy < yTh && dz < th.z);
    }

    if (ent.type === 'turtle') {
      if (game.jumping || runnerPivot.position.y > 0.35) return false;

      const playerFootY = runnerPivot.position.y + (game.sliding ? 0.18 : 0.30);
      const turtleCenterY = (ent.obj.position.y ?? 0) + 0.35;
      const dyFoot = Math.abs(turtleCenterY - playerFootY);

      return (dx < 0.66 && dyFoot < 0.50 && dz < 0.75);
    }

    return (dx < th.x && dy < th.y && dz < th.z);
  }

  for (let i = game.entities.length - 1; i >= 0; i--) {
    const e = game.entities[i];

    if (e.type === 'ring') {
      if (!collideEntity(e)) continue;

      game.ringCount += 1;
      scene.remove(e.obj);
      game.entities.splice(i, 1);
      sfx.ring();

      if (game.ringCount >= 50) {
        game.ringBoostT = 10.0;
        game.invincibleT = Math.max(game.invincibleT, 10.0);
        bubble.visible = true;
        game.ringCount = 0;
        sfx.boost();
      }
      continue;
    }

    if (e.type === 'turtle') {
      if (e.hit) continue;
      if (!collideEntity(e)) continue;

      e.hit = true;
      e.destroyedAny = false;
      e.hitAge = 0;
      e.exploding = false;
      e.explodeT = 0;

      e.slideV = -120.0;
      e.z -= 0.8;
      e.obj.position.z = e.z;

      e.slideT = 1.60;
      e.spinV = (Math.random() < 0.5 ? -1 : 1) * (3.5 + Math.random() * 2.0);

      e.obj.position.y = 0.01;

      sfx.boost();
      continue;
    }

    if (!collideEntity(e)) continue;

    if (e.type === 'coin') {
      game.coins += 1;
      game.score += 28;
      scene.remove(e.obj);
      game.entities.splice(i, 1);
      sfx.coin();
      continue;
    }

    if (e.type === 'food') {
  // ‚ú® magia: dal pickup alla barra cibo
  const toEl = document.querySelector('.foodCount'); // target HUD
  magicFly(
    { x: e.obj.position.x, y: e.obj.position.y ?? 1.15, z: e.z },
    toEl,
    { dur: 560, sparks: IS_IOS ? 10 : 14 }
  );

  game.foodCount += 1;
  game.foodHistory.push(e.emo);

  // flag per pop sulla prima pillola (ultima raccolta)
  game._foodPop = true;

  refreshFoodUI();

  scene.remove(e.obj);
  game.entities.splice(i, 1);
  sfx.food();

  if (game.foodCount >= 10) {
    game.foodBoostCharges += 1;
    game.foodCount = 0;
    game.foodHistory = [];
    refreshFoodUI();
    updateFoodBoostButton();
    sfx.boost();
  }
  continue;
}


    if (e.type === 'heart') {
  if (game.lives < game.maxLives) addLife();

  // ‚úÖ dopo vita: blocca spawn magneti + vita per 2x visibile
  game.noMagHeartUntil = game.runDist + MAGHEART_BLOCK_DIST;

  scene.remove(e.obj);
  game.entities.splice(i, 1);
  continue;
}

    if (e.type === 'magnet') {
  // ‚ú® magia: dal pickup al magnete HUD
  const toEl = document.getElementById('magTxt') || document.querySelector('.hudBarRow');
  magicFly(
    { x: e.obj.position.x, y: e.obj.position.y ?? 1.15, z: e.z },
    toEl,
    { dur: 560, sparks: IS_IOS ? 10 : 14 }
  );

  game.magnetT = 8.0;

  // ‚úÖ dopo magnete: blocca spawn magneti + vita per 2x visibile
  game.noMagHeartUntil = game.runDist + MAGHEART_BLOCK_DIST;

  scene.remove(e.obj);
  game.entities.splice(i, 1);
  sfx.magnet();
  continue;
}

    if (e.type === 'obst') {
      const inv = (game.invincibleT > 0);
      scene.remove(e.obj);
      game.entities.splice(i, 1);
      if (!inv) loseLife();
      continue;
    }
  }

  // score + HUD
  game.score += (18 * speedMul) * dt;

  if(game.score > game.best){
    game.best = Math.floor(game.score);
    saveBest(game.best);
  }

  if(scoreEl) scoreEl.textContent = String(Math.floor(game.score));
  if(coinsEl) coinsEl.textContent = String(game.coins);
  if(bestEl)  bestEl.textContent  = String(game.best);
  if(ringsEl) ringsEl.textContent = String(game.ringCount);
  if(hpTxt)   hpTxt.textContent   = hpString();
  if(magTxt)  magTxt.textContent  = `üß≤ ${game.magnetT>0 ? game.magnetT.toFixed(1) : '0'}`;
  setBoostUI();

  if(bubble.visible){
    bubble.material.opacity = 0.18 + 0.06*Math.sin(tNow*0.01);
  }

  tiltTarget *= 0.92;
  camRoll = damp(camRoll, tiltTarget, 10, dt);
}
 

    function animate(tNow){
      const dt=Math.min(0.030,(tNow-tPrev)/1000);
      tPrev=tNow;

      // debug fps calc
      fpsAcc += dt; fpsN++;
      if(fpsAcc >= 0.5){
        fpsShow = fpsN / fpsAcc;
        fpsAcc = 0; fpsN = 0;
      }

      update(dt,tNow);

      const gameplayOn  = game.started && !game.paused && !game.over;
      const camDynamic  = gameplayOn && !game.stopped;

      const bothBoost = (game.foodBoostT > 0 && game.ringBoostT > 0);
      const anyBoost  = (game.foodBoostT > 0 || game.ringBoostT > 0);
      // ‚úÖ kick quando parte un boost
if(anyBoost && !_prevAnyBoost) boostShakeKick = 1.0;
_prevAnyBoost = anyBoost;

// decay kick
boostShakeKick = damp(boostShakeKick, 0.0, 16, dt);

      const fovBoost = bothBoost ? 7 : (anyBoost ? 5 : 0);
      const zBoost   = bothBoost ? 0.9 : (anyBoost ? 0.5 : 0.0);

      // ‚úÖ FOV dinamico SOLO in FPS se fpsDynFov=true
      const useFovBoost = (viewMode === 'fps') ? fpsDynFov : true;

      const active = profForView();

const targetFov = clamp(active.fov + (useFovBoost ? fovBoost : 0), 30, 110);
const targetZ   = clamp(active.dist + zBoost, 2, 15);
const targetY   = clamp(active.y + (bothBoost ? 0.10 : 0), 0.0, 12.0);

      if(!camDynamic){
  const a = profForView();
  camFov  = a.fov;
  camZ    = a.dist;
  camY    = a.y;
  camX    = 0;
  camRoll = 0;
} else {
        camFov = damp(camFov, targetFov, 8, dt);
        camZ   = damp(camZ,   targetZ,   8, dt);
        camY   = damp(camY,   targetY,   8, dt);

        // segue di pi√π la corsia (prima 0.35)
const targetCamX = clamp(runnerPivot.position.x * 0.55, -1.6, 1.6);

// un filo pi√π morbido (prima lambda 6)
camX = damp(camX, targetCamX, 5, dt);
      }

      camera.fov = camFov;
      camera.updateProjectionMatrix();

      let shakeX = 0, shakeY = 0;

if(camDynamic && shakeEnabled && viewMode!=='fps'){

  const foodOn = (game.foodBoostT > 0);
  const ringOn = (game.ringBoostT > 0);
  const bothOn = foodOn && ringOn;

  if(foodOn || ringOn){

    // ‚úÖ MOLTO pi√π intenso
    const amp =
      bothOn ? 0.16 :
      foodOn ? 0.13 :
      0.16;

    // ‚úÖ ‚Äúsaltelli‚Äù random frequenti (vero tremore schermo)
    shTimer -= dt;
    if(shTimer <= 0){
      shTimer = 0.016 + Math.random()*0.020; // ~60-30 Hz

      shTX = (Math.random()*2 - 1) * amp;
      shTY = (Math.random()*2 - 1) * amp * 0.85;
    }

    // ‚úÖ follow rapidissimo (niente camminata)
    const follow = 38;  // pi√π alto = pi√π nervoso
    shX = damp(shX, shTX, follow, dt);
    shY = damp(shY, shTY, follow, dt);

    // ‚úÖ micro-jitter extra (tremore fine)
    const t = tNow * 0.001;
    const jitter = amp * 0.18;
    const jx = (Math.sin(t*95) + Math.sin(t*141)) * 0.5 * jitter;
    const jy = (Math.cos(t*88) + Math.cos(t*133)) * 0.5 * jitter;

    // micro spostamento laterale (posizione), NON su/gi√π
shakeX = shX * 0.35;   // ‚úÖ laterale
shakeY = 0;            // niente su/gi√π

  } else {
    // reset quando finisce boost
    shX = damp(shX, 0, 18, dt);
    shY = damp(shY, 0, 18, dt);
  }
}

      const bob = camDynamic ? (Math.sin(tNow*0.0020) * 0.005) : 0;

      camera.up.set(0,1,0);

      
      // ===== CAMERA MODES =====
if(viewMode === 'fps'){
  camera.up.set(0,1,0);

  const eyeBaseY = 1.58;
  const eyeFwd   = 1.05;
  const eyeZ     = 0.10;

  const stoppedOrMenu = (!game.started || game.paused || game.over || game.stopped);

  // ===== motion blur fake solo in boost =====
  const anyBoost = (game.foodBoostT>0 || game.ringBoostT>0);
  if(renderer?.domElement){
    renderer.domElement.classList.toggle('blurBoost', !!(motionBlurEnabled && anyBoost && !stoppedOrMenu));
  }

  // ===== breathe in menu/stop =====
  const breatheY = stoppedOrMenu ? (Math.sin(tNow*0.0019) * 0.010) : 0.0;
  const breatheX = stoppedOrMenu ? (Math.sin(tNow*0.0015) * 0.006) : 0.0;

  const grounded = (game.y === 0 && !game.jumping);

  // landing kick
  if(fpsGroundPrev === false && grounded === true) fpsLandKick = 1.0;
  fpsGroundPrev = grounded;

  fpsVelYSm = damp(fpsVelYSm, game.vy, 10, dt);
  fpsLandKick = damp(fpsLandKick, 0.0, 14, dt);

  // ===== elastic lane lag (spring) =====
  // "fpsLaneKick" lo usi gi√† quando cambi corsia: qui lo trasformiamo in elasticit√† vera
  // (pi√π realistico) oppure lo spengo in stabile
  if(!fpsRealistic){
    fpsLaneKick = damp(fpsLaneKick, 0.0, 20, dt);
  }else{
    fpsLaneKick = damp(fpsLaneKick, 0.0, 10, dt);
  }

  // ===== non-linear bob based on speed =====
  // speedNormalized 0..1 circa
  const sNorm = clamp((game.camSpeed - 8.0) / 18.0, 0, 1);
  const nonLinear = Math.pow(sNorm, 1.65); // non lineare (cresce pi√π forte a velocit√† alte)

  if(!stoppedOrMenu && fpsRealistic){
    fpsPhase += dt * (8.6 + 6.2*nonLinear + (anyBoost?1.0:0.0));
  } else {
    fpsPhase += dt * 2.0;
  }

  const runAmpY = (!stoppedOrMenu && fpsRealistic) ? (0.020 + 0.060*nonLinear) : 0.0;
  const runAmpX = (!stoppedOrMenu && fpsRealistic) ? (0.010 + 0.034*nonLinear) : 0.0;

  const runY = Math.abs(Math.sin(fpsPhase)) * runAmpY;
  const runX = Math.sin(fpsPhase*0.5) * runAmpX;

  const air = grounded ? 0.0 : 1.0;
  const airFloat = (fpsRealistic ? Math.sin(tNow*0.006) * 0.008 : 0.0);
  const landY = -fpsLandKick * 0.020;

  const slideChin = (game.sliding ? 0.10 : 0.0);
  const yFollow = runnerPivot.position.y + eyeBaseY - slideChin;

  // micro lag corsia (elasticit√†)
  const laneKickX = fpsRealistic ? (fpsLaneKick * 0.030) : 0.0;

  const yVelFeel = (air * clamp(-fpsVelYSm*0.002, -0.02, 0.02));

  const xOff = breatheX + (1-air)*runX + laneKickX;
  const yOff = breatheY + (1-air)*runY + airFloat + landY + yVelFeel;

  camera.position.set(
    runnerPivot.position.x + xOff,
    yFollow + yOff,
    eyeZ - eyeFwd
  );

  camera.lookAt(
  runnerPivot.position.x + xOff,
  yFollow + yOff,
  -10
);

// ‚úÖ azzera roll in modo stabile (niente flip)
_camEuler.setFromQuaternion(camera.quaternion);
_camEuler.z = 0;
camera.quaternion.setFromEuler(_camEuler);
}
else if(viewMode === 'back'){
  const lookAtY = lerp(0.35, 1.45, profForView().framing);
  const lookAtZ = -6.5;
  camera.position.set(camX + shakeX, camY + bob + shakeY, camZ);
  camera.up.set(0,1,0);
camera.lookAt(camX*0.35, lookAtY, lookAtZ);

// ‚úÖ roll senza rompere lookAt (no capovolgimenti)
camera.rotateZ(camRoll * 0.55);
}
else { // FRONT
  const lookAtY = lerp(0.30, 1.55, profForView().framing);
  const lookAtZ = 0.10;
  camera.position.set(camX + shakeX, camY + bob + shakeY, -camZ);
  camera.up.set(0,1,0);
camera.lookAt(camX*0.35, lookAtY, lookAtZ);

// ‚úÖ roll stabile
camera.rotateZ(camRoll * 0.55);
}

      // ===== Debug panel update (timer) =====
      if(debugOn){
        dbgTimer += dt;
        if(dbgTimer > 0.12){
          dbgTimer = 0;
          if(dbgFps) dbgFps.textContent = `fps: ${fpsShow ? fpsShow.toFixed(0) : '--'}`;
          if(dbgCam) dbgCam.textContent = `${camera.position.x.toFixed(2)}, ${camera.position.y.toFixed(2)}, ${camera.position.z.toFixed(2)}`;
          if(dbgMode) dbgMode.textContent = viewMode;
          if(dbgState) dbgState.textContent = `started:${game.started} stopped:${game.stopped} paused:${game.paused} over:${game.over} anim:${animState.mode}`;
          if(dbgEnt) dbgEnt.textContent = String(game.entities.length);
          if(dbgLane) dbgLane.textContent = String(game.lane);
          if(dbgBoosts) dbgBoosts.textContent = `food:${game.foodBoostT.toFixed(1)} ring:${game.ringBoostT.toFixed(1)} mag:${game.magnetT.toFixed(1)}`;
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    function onResize(){
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onResize);

    // ===== Boot =====
    (async ()=>{
      refreshFoodUI();
      // üî• DEBUG: 5 boost disponibili
      game.foodBoostCharges = 5;
      updateFoodBoostButton();
      if(hpTxt) hpTxt.textContent = hpString();
      syncCamUI();
      // ‚úÖ imposta tab FRONT attivo all'avvio
       setCamProfile('front');

      await loadRunnerModel();

      game.started = false;
      game.over = false;
      game.paused = false;
      game.stopped = true;
      game.stopBlend = 1.0;
      updateMainButton();
      startIdleRandom();

      if(scoreEl) scoreEl.textContent = '0';
      if(coinsEl) coinsEl.textContent = '0';
      if(bestEl)  bestEl.textContent = String(game.best);
      if(ringsEl) ringsEl.textContent = '0';
      if(magTxt)  magTxt.textContent = 'üß≤ 0';
      setBoostUI();

      // applica modalit√† salvata
      applyViewMode(viewMode);
      setDebugUI();

      requestAnimationFrame(animate);
    })();
  </script>
  <canvas id="magicCanvas" style="
position:fixed;
inset:0;
pointer-events:none;
z-index:9999;"></canvas>
</body>
</html>