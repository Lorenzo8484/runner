<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Jungle Emoji Runner (Three.js)</title>
  <style>
    :root { color-scheme: dark; }
    html,body{height:100%;margin:0;background:#040805;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;overflow:hidden;}
    canvas{display:block;touch-action:none;}

    .hud{position:fixed;top:10px;left:10px;right:10px;display:flex;justify-content:space-between;gap:10px;pointer-events:none;z-index:10;}
    .card{pointer-events:none;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);border-radius:14px;padding:10px 12px;color:#eaf1ff;backdrop-filter:blur(10px);min-width:200px;}
    .row{display:flex;justify-content:space-between;gap:10px;align-items:center;}
    .small{font-size:12px;opacity:.86;line-height:1.2}
    .btn{pointer-events:auto;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.16);color:#eaf1ff;padding:10px 12px;border-radius:14px;font-weight:800;cursor:pointer;user-select:none;}
    .btn:active{transform:scale(.98);}

    .pill{display:inline-flex;align-items:center;gap:8px;margin-top:8px;padding:6px 10px;border-radius:999px;background:rgba(255,255,255,.07);border:1px solid rgba(255,255,255,.12);font-size:12px;white-space:nowrap;}
    .bar{height:6px;width:120px;border-radius:999px;background:rgba(255,255,255,.12);overflow:hidden;}
    .bar>i{display:block;height:100%;width:0%;background:rgba(255,255,255,.78);}

    /* right side vertical food column */
    .rightCol{
      position:fixed; top:70px; right:8px; width:72px;
      display:flex; flex-direction:column; align-items:center; gap:6px;
      pointer-events:none; z-index:10;
    }
    .foodStack{
      width:64px; max-height:260px; overflow:hidden;
      display:flex; flex-direction:column; align-items:center; gap:6px;
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      padding:8px 6px;
      backdrop-filter:blur(10px);
    }
    .foodItem{
      width:46px;height:46px;border-radius:14px;
      display:flex;align-items:center;justify-content:center;
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.12);
      font-size:24px;
    }
    .foodCount{
      margin-top:6px;
      width:64px;
      text-align:center;
      font-weight:900;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      border-radius:999px;
      padding:6px 0;
    }

    .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;padding:16px;
      background:radial-gradient(ellipse at center, rgba(0,0,0,.45), rgba(0,0,0,.88));
      backdrop-filter:blur(10px);z-index:20;}
    .panel{width:min(680px,100%);border-radius:18px;border:1px solid rgba(255,255,255,.16);
      background:rgba(10,14,22,.84);box-shadow:0 18px 60px rgba(0,0,0,.55);padding:16px;color:#eaf1ff;}
    .title{font-size:20px;font-weight:950;margin:4px 0 6px;}
    .subtitle{opacity:.88;font-size:13px;margin:0 0 12px;line-height:1.35;}

    .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
    .full{grid-column:1/-1;}

    .toggle{display:flex;align-items:center;justify-content:space-between;border:1px solid rgba(255,255,255,.16);
      border-radius:14px;padding:10px 12px;background:rgba(255,255,255,.06);cursor:pointer;user-select:none;}
    .toggle label{font-weight:900;}
    .toggle span{opacity:.85;font-size:12px;}
    .switch{width:44px;height:26px;border-radius:99px;background:rgba(255,255,255,.14);position:relative;border:1px solid rgba(255,255,255,.16);}
    .switch i{position:absolute;top:3px;left:3px;width:20px;height:20px;border-radius:999px;background:rgba(255,255,255,.86);transition:transform .18s ease;}
    .switch.on{background:rgba(140,255,190,.18);border-color:rgba(140,255,190,.24);}
    .switch.on i{transform:translateX(18px);}

    .help{position:fixed;bottom:10px;left:10px;right:10px;display:flex;justify-content:center;pointer-events:none;z-index:10;}
    .help .card{max-width:980px;text-align:center;}

    input[type="file"]{display:none;}
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div class="hud">
    <div class="card">
      <div class="row">
        <div><strong>Score</strong>: <span id="score">0</span></div>
        <div class="small">Rings: <span id="rings">0</span>/10</div>
      </div>
      <div class="row">
        <div><strong>Emoji</strong>: <span id="coins">0</span></div>
        <div class="small">Record: <span id="best">0</span></div>
      </div>

      <div class="row small" style="margin-top:6px;">
        <div><strong>Vita</strong>: <span id="hpTxt">‚ô•‚ô•‚ô•</span></div>
        <div>Boost: <span id="boostTxt">‚Äî</span></div>
      </div>

      <div class="pill" id="pillBoost" style="display:none;">
        <span id="boostIcon">‚ö°Ô∏è</span><strong id="boostName">Super</strong>
        <div class="bar"><i id="boostBar"></i></div>
      </div>
    </div>

    <div style="display:flex;gap:10px;">
      <button class="btn" id="pause">Pausa</button>
      <button class="btn" id="restart">Restart</button>
    </div>
  </div>

  <div class="rightCol">
    <div class="foodStack" id="foodStack"></div>
    <div class="foodCount"><span id="foodCount">0</span>/10</div>
  </div>

  <div class="help">
    <div class="card small">
      <strong>Comandi</strong> ‚Äî Desktop: ‚Üê ‚Üí corsia, ‚Üë salto, ‚Üì scivolata, P pausa, R restart.
      Mobile: swipe sx/dx, swipe su (salto), swipe gi√π (scivolata).
    </div>
  </div>

  <div class="overlay" id="menu">
    <div class="panel">
      <div class="title">Jungle Emoji Runner</div>
      <div class="subtitle">
        ‚úÖ Anelli verticali: si prendono solo scivolando (‚Üì / swipe gi√π).<br>
        ‚úÖ Supercarica: 10 cibi <strong>o</strong> 10 anelli ‚Üí invincibile + tripla velocit√† per 10s (FOV ampio).
      </div>

      <div class="grid">
        <button class="btn full" id="startBtn">‚ñ∂Ô∏è Inizia</button>

        <div class="toggle full" id="audioToggle">
          <div><label>Suoni</label><br/><span>Fallback semplice (beep leggeri).</span></div>
          <div class="switch on" id="audioSwitch"><i></i></div>
        </div>

        <div class="toggle full">
          <div><label>Record</label><br/><span>Salvato in locale.</span></div>
          <div style="font-weight:950;font-size:18px;" id="bestBig">0</div>
        </div>

        <div class="toggle full">
          <div><label>Game Over</label><br/><span id="overStats">‚Äî</span></div>
          <div style="font-weight:950;font-size:18px;" id="overBig"> </div>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    const IS_IOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

    // ---------- UI
    const scoreEl = document.getElementById('score');
    const coinsEl = document.getElementById('coins');
    const bestEl  = document.getElementById('best');
    const bestBig = document.getElementById('bestBig');
    const ringsEl = document.getElementById('rings');

    const hpTxt   = document.getElementById('hpTxt');
    const boostTxt= document.getElementById('boostTxt');
    const pillBoost = document.getElementById('pillBoost');
    const boostIcon = document.getElementById('boostIcon');
    const boostName = document.getElementById('boostName');
    const boostBar  = document.getElementById('boostBar');

    const foodStack = document.getElementById('foodStack');
    const foodCountEl = document.getElementById('foodCount');

    const menu = document.getElementById('menu');
    const startBtn = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restart');
    const pauseBtn   = document.getElementById('pause');
    const audioToggle= document.getElementById('audioToggle');
    const audioSwitch= document.getElementById('audioSwitch');
    const overStats  = document.getElementById('overStats');
    const overBig    = document.getElementById('overBig');

    const rnd=(a,b)=>a+Math.random()*(b-a);
    const rndi=(a,b)=>Math.floor(rnd(a,b+1));
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp=(a,b,t)=>a+(b-a)*t;

    function toggleSwitch(el,on){ el.classList.toggle('on',!!on); return on; }
    function menuIsOpen(){ return menu.style.display !== 'none'; }

    // ---------- Audio (simple + safe)
    let audioEnabled=true;
    let audioReady=false;
    let actx=null, master=null;

    function initAudio(){
      if(audioReady) return;
      try{
        actx = new (window.AudioContext||window.webkitAudioContext)();
        master = actx.createGain();
        master.gain.value = 0.55;
        master.connect(actx.destination);
        audioReady=true;
      }catch(e){ audioEnabled=false; }
      audioSwitch.classList.toggle('on',!!audioEnabled);
    }
    function beep(type,freq,dur=0.06,g=0.10){
      if(!audioEnabled) return;
      initAudio(); if(!audioReady) return;
      const t0=actx.currentTime;
      const o=actx.createOscillator();
      const gg=actx.createGain();
      o.type=type; o.frequency.setValueAtTime(freq,t0);
      gg.gain.setValueAtTime(0.0001,t0);
      gg.gain.exponentialRampToValueAtTime(g,t0+0.012);
      gg.gain.exponentialRampToValueAtTime(0.0001,t0+dur);
      o.connect(gg); gg.connect(master);
      o.start(t0); o.stop(t0+dur+0.02);
    }
    const sfx = {
      coin: ()=>{ beep('triangle', 900, 0.06, 0.10); beep('sine', 1350, 0.07, 0.07); },
      food: ()=>{ beep('sine', 520, 0.06, 0.09); },
      ring: ()=>{ beep('triangle', 700, 0.06, 0.10); },
      hit:  ()=>{ beep('square', 120, 0.12, 0.11); },
      boost:()=>{ beep('sawtooth', 520, 0.10, 0.09); beep('triangle', 880, 0.10, 0.07); },
      lane: ()=>{ beep('sine', 160, 0.05, 0.05); },
      jump: ()=>{ beep('square', 420, 0.05, 0.08); },
      slide:()=>{ beep('sine', 220, 0.06, 0.06); },
    };

    // ---------- Renderer / Scene
    const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x08120b);
    scene.fog = IS_IOS ? new THREE.Fog(0x08120b, 22, 80) : new THREE.FogExp2(0x06110a, 0.040);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 240);

    // lights
    const sun = new THREE.DirectionalLight(0xf3ffe6, IS_IOS ? 2.8 : 2.0);
    sun.position.set(6, 10, 6);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048,2048);
    sun.shadow.camera.near = 0.5;
    sun.shadow.camera.far = 60;
    sun.shadow.camera.left = -10;
    sun.shadow.camera.right=  10;
    sun.shadow.camera.top  =  10;
    sun.shadow.camera.bottom=-10;
    sun.shadow.bias = -0.00025;
    scene.add(sun);

    scene.add(new THREE.HemisphereLight(0xaaffdd, 0x081209, IS_IOS ? 1.05 : 0.75));
    scene.add(new THREE.AmbientLight(0xffffff, IS_IOS ? 0.6 : 0.22));
    const front = new THREE.DirectionalLight(0xffffff, IS_IOS ? 1.25 : 0.55);
    front.position.set(0, 4, 7);
    scene.add(front);

    // ---------- Contact shadow under runner
    function makeContactShadowTexture(size=512){
      const c=document.createElement('canvas'); c.width=c.height=size;
      const g=c.getContext('2d');
      g.clearRect(0,0,size,size);
      const grd=g.createRadialGradient(size/2,size/2,0, size/2,size/2,size*0.48);
      grd.addColorStop(0,'rgba(0,0,0,0.38)');
      grd.addColorStop(0.55,'rgba(0,0,0,0.10)');
      grd.addColorStop(1,'rgba(0,0,0,0)');
      g.fillStyle=grd; g.fillRect(0,0,size,size);
      const t=new THREE.CanvasTexture(c); t.colorSpace=THREE.SRGBColorSpace;
      return t;
    }
    const contact = new THREE.Mesh(
      new THREE.PlaneGeometry(1.5,1.5),
      new THREE.MeshBasicMaterial({ map:makeContactShadowTexture(512), transparent:true, opacity:0.55, depthWrite:false })
    );
    contact.rotation.x = -Math.PI/2;
    contact.position.set(0, 0.02, 0.2);
    scene.add(contact);

    // ---------- World layout
    const lanesX = [-1.15, 0, 1.15];
    const segLen = 9.0, segCount = 9, roadWidth = 4.2;

    // cheap dirt texture
    function makeDirtTexture(size=512){
      const c=document.createElement('canvas'); c.width=c.height=size;
      const g=c.getContext('2d');
      g.fillStyle='#3b3a28'; g.fillRect(0,0,size,size);
      for(let i=0;i<12000;i++){
        const x=Math.random()*size, y=Math.random()*size;
        const v=rndi(50,120);
        g.fillStyle=`rgba(${v+35},${v+20},${v},${rnd(0.05,0.18)})`;
        g.fillRect(x,y,1,1);
      }
      const t=new THREE.CanvasTexture(c);
      t.colorSpace=THREE.SRGBColorSpace;
      t.wrapS=t.wrapT=THREE.RepeatWrapping;
      t.repeat.set(2.0, 10.0);
      return t;
    }
    const dirtTex = makeDirtTexture(1024);

    const roadMat = new THREE.MeshStandardMaterial({
      map: dirtTex,
      roughness: 0.95,
      metalness: 0.0,
      color: new THREE.Color(0x7f8a62)
    });

    const segments=[];
    for(let i=0;i<segCount;i++){
      const geo = new THREE.PlaneGeometry(roadWidth, segLen);
      geo.rotateX(-Math.PI/2);
      const mesh = new THREE.Mesh(geo, roadMat);
      mesh.position.set(0, 0, -i*segLen);
      mesh.receiveShadow=true;
      scene.add(mesh);
      segments.push(mesh);
    }

    const sideGeo = new THREE.PlaneGeometry(40, segLen*segCount);
    sideGeo.rotateX(-Math.PI/2);
    const sideMat = new THREE.MeshStandardMaterial({ color:0x0d2416, roughness:1, metalness:0 });
    const side = new THREE.Mesh(sideGeo, sideMat);
    side.position.set(0, -0.02, -segLen*segCount/2 + segLen/2);
    side.receiveShadow = true;
    scene.add(side);

    // ---------- Simple jungle trees (lightweight)
    const jungle = new THREE.Group(); scene.add(jungle);
    function makeTree(){
      const g = new THREE.Group();
      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.11, 0.16, 1.6, 10),
        new THREE.MeshStandardMaterial({ color:0x4a3523, roughness:1, metalness:0 })
      );
      trunk.position.y=0.8; trunk.castShadow=true; trunk.receiveShadow=true; g.add(trunk);

      const crown = new THREE.Mesh(
        new THREE.ConeGeometry(0.75, 1.6, 12),
        new THREE.MeshStandardMaterial({ color:0x1c6b33, roughness:1, metalness:0 })
      );
      crown.position.y=1.9; crown.castShadow=true; crown.receiveShadow=true; g.add(crown);

      const crown2 = new THREE.Mesh(
        new THREE.ConeGeometry(0.6, 1.3, 12),
        new THREE.MeshStandardMaterial({ color:0x135226, roughness:1, metalness:0 })
      );
      crown2.position.y=2.3; crown2.castShadow=true; crown2.receiveShadow=true; g.add(crown2);
      return g;
    }
    const treeProto = makeTree();
    const treePool=[];
    const treeSpacing=2.8;
    const treeSideX = roadWidth/2 + 1.7;
    const jungleCount = Math.floor((segLen*segCount)/treeSpacing);
    for(let i=0;i<jungleCount;i++){
      const z = -i*treeSpacing;
      for(const sideSign of [-1,1]){
        const t = treeProto.clone(true);
        t.position.set(sideSign*(treeSideX + rnd(0,1.8)), 0, z);
        t.scale.setScalar(rnd(0.8,1.2));
        t.rotation.y = rnd(0,Math.PI*2);
        t.traverse(o=>{ if(o.isMesh){o.castShadow=true;o.receiveShadow=true;}});
        jungle.add(t); treePool.push(t);
      }
    }
    function loopJungle(scroll){
      const wrapZ = segLen*segCount;
      for(const obj of treePool){
        obj.position.z += scroll;
        if(obj.position.z > 8) obj.position.z -= wrapZ;
      }
    }

    // ---------- Runner
    let runner = new THREE.Group();
    scene.add(runner);

    const dummyBody = new THREE.Mesh(
      new THREE.CapsuleGeometry(0.22, 0.55, 8, 16),
      new THREE.MeshStandardMaterial({ color:0x9db79a, roughness:0.65, metalness:0.0 })
    );
    dummyBody.position.y=0.85; dummyBody.castShadow=true; runner.add(dummyBody);

    const dummyHead = new THREE.Mesh(
      new THREE.SphereGeometry(0.18, 18, 14),
      new THREE.MeshStandardMaterial({ color:0xb7ccb2, roughness:0.6, metalness:0.0 })
    );
    dummyHead.position.set(0, 1.25, 0.05); dummyHead.castShadow=true; runner.add(dummyHead);

    // invincibility bubble
    const bubble = new THREE.Mesh(
      new THREE.SphereGeometry(0.62, 24, 18),
      new THREE.MeshStandardMaterial({
        color:0x66ffcc, roughness:0.25, metalness:0.0,
        emissive:0x33ffaa, emissiveIntensity:0.7,
        transparent:true, opacity:0.22
      })
    );
    bubble.position.y=0.95;
    bubble.visible=false;
    runner.add(bubble);

    // ---------- Entities
    const EMOJIS = ["‚ú®","üçÄ","üíé","‚ö°Ô∏è","üåà","üçã","‚≠êÔ∏è","üçì","ü•ù"];
    const FOOD   = ["üçï","üçî","üçü","üåÆ","üç©","üç™","üç∞","üçú","üç£","ü•ê"];
    const HEART_EMOJI = "‚ù§Ô∏è";
    const RING_ICON = "‚≠ïÔ∏è";

    function makeEmojiSprite(emoji, size=256){
      const c=document.createElement('canvas'); c.width=c.height=size;
      const g=c.getContext('2d');
      g.clearRect(0,0,size,size);
      g.globalAlpha=0.18;
      g.fillStyle='#cfefff';
      g.beginPath(); g.arc(size/2,size/2,size*0.33,0,Math.PI*2); g.fill();
      g.globalAlpha=1;
      g.font=`${size*0.55}px system-ui, Apple Color Emoji, Segoe UI Emoji`;
      g.textAlign='center'; g.textBaseline='middle';
      g.fillText(emoji, size/2, size/2+8);
      const tex=new THREE.CanvasTexture(c);
      tex.colorSpace=THREE.SRGBColorSpace;
      const mat=new THREE.SpriteMaterial({ map:tex, transparent:true });
      const spr=new THREE.Sprite(mat);
      spr.scale.set(0.78,0.78,1);
      return spr;
    }

    function spawnObstacleVisual(){
      const box = new THREE.Mesh(
        new THREE.BoxGeometry(rnd(0.6,0.9), rnd(0.7,1.2), rnd(0.6,0.9)),
        new THREE.MeshStandardMaterial({ color:0x6b4b2b, roughness:0.9, metalness:0.02 })
      );
      box.castShadow=true; box.receiveShadow=true;
      return box;
    }

    // ---------- VERTICAL RING (‚úÖ in piedi)
    function makeVerticalRing(){
      const ring = new THREE.Mesh(
        new THREE.TorusGeometry(0.55, 0.09, 14, 44),
        new THREE.MeshStandardMaterial({
          color:0xff4444,
          roughness:0.35,
          metalness:0.05,
          emissive:0x660000,
          emissiveIntensity:0.55
        })
      );
      ring.castShadow=true; ring.receiveShadow=true;

      // ‚úÖ IMPORTANTISSIMO: VERTICALE (in piedi), quindi nessun rotateX(Math.PI/2)
      ring.rotation.set(0, 0, 0);

      // un piccolo ‚Äúcap‚Äù interno per visibilit√†
      const inner = new THREE.Mesh(
        new THREE.RingGeometry(0.34, 0.40, 28),
        new THREE.MeshStandardMaterial({ color:0xff2222, roughness:0.8, metalness:0, side:THREE.DoubleSide, transparent:true, opacity:0.35 })
      );
      inner.rotation.set(0,0,0);
      ring.add(inner);

      return ring;
    }

    // ---------- Game state
    const BEST_KEY='jungle_runner_best_v2';
    const loadBest=()=>Number(localStorage.getItem(BEST_KEY)||'0')||0;
    const saveBest=(v)=>localStorage.setItem(BEST_KEY,String(v));

    const game = {
      lane:1, targetLane:1,
      y:0, vy:0, jumping:false,
      sliding:false, slideT:0,

      baseSpeed: 12.9,      // ‚úÖ +50% (permanente)
      score:0,
      coins:0,
      best: loadBest(),

      // lives
      maxLives:5,
      lives:3,

      // counters
      ringCount:0,
      foodCount:0,
      foodHistory: [],

      // boosts
      invincibleT:0,
      boostType:null,     // 'food' | 'ring'
      boostT:0,

      // gameplay
      over:false,
      paused:true,
      entities: [],
      spawnT:0.28,        // un po‚Äô pi√π facile
      heartSpawnAcc:0,    // accumulo per cuori

      // magnet
      magnet: true,       // sempre attivo
    };

    bestEl.textContent = String(game.best);
    bestBig.textContent = String(game.best);

    function hpString(){
      let s="";
      for(let i=0;i<game.maxLives;i++){
        s += (i<game.lives) ? "‚ù§Ô∏è" : "üñ§";
      }
      return s;
    }

    function setBoostUI(on, icon, name, t, dur){
      if(!on){
        pillBoost.style.display='none';
        boostTxt.textContent='‚Äî';
        boostBar.style.width='0%';
        return;
      }
      pillBoost.style.display='inline-flex';
      boostIcon.textContent=icon;
      boostName.textContent=name;
      boostTxt.textContent=name;
      const pct = clamp((t/dur)*100,0,100);
      boostBar.style.width = pct.toFixed(1)+'%';
    }

    function refreshFoodUI(){
      foodStack.innerHTML = "";
      // mostra ultimi 6, piccoli e a destra
      const show = game.foodHistory.slice(-6).reverse();
      for(const emo of show){
        const d=document.createElement('div');
        d.className='foodItem';
        d.textContent=emo;
        foodStack.appendChild(d);
      }
      foodCountEl.textContent = String(game.foodCount);
    }

    function openMenu(){
      menu.style.display='flex';
      game.paused=true;
      bestBig.textContent=String(game.best);
      const st = `Score ${Math.floor(game.score)} ‚Ä¢ Emoji ${game.coins} ‚Ä¢ Anelli ${game.ringCount} ‚Ä¢ Cibo ${game.foodCount}`;
      overStats.textContent = game.over ? st : "‚Äî";
      overBig.textContent = game.over ? "GAME OVER" : "";
    }
    function closeMenu(){ menu.style.display='none'; }

    function resetRun(){
      game.lane=1; game.targetLane=1;
      game.y=0; game.vy=0; game.jumping=false;
      game.sliding=false; game.slideT=0;

      game.score=0;
      game.coins=0;

      game.ringCount=0;
      game.foodCount=0;
      game.foodHistory=[];
      refreshFoodUI();

      game.invincibleT=0;
      game.boostType=null;
      game.boostT=0;

      game.over=false;
      game.spawnT=0.28;
      game.heartSpawnAcc=0;

      for(const e of game.entities) scene.remove(e.obj);
      game.entities.length=0;

      game.paused=false;
      pauseBtn.textContent='Pausa';

      bubble.visible=false;
      setBoostUI(false);

      // start with 3 lives always (as requested)
      game.lives=3;
    }

    function togglePause(){
      if(game.over) return;
      game.paused=!game.paused;
      pauseBtn.textContent = game.paused ? 'Riprendi' : 'Pausa';
    }

    // ---------- Spawning
    function spawnRow(){
      const z0 = -52 - rnd(0,16);

      // fewer obstacles (easier)
      const blocked=new Set();
      const oCount = Math.random()<0.55 ? 0 : (Math.random()<0.75 ? 1 : 2);
      while(blocked.size<oCount) blocked.add(rndi(0,2));

      // coins
      const coinLanes=new Set();
      const cCount = rndi(1,2);
      while(coinLanes.size<cCount) coinLanes.add(rndi(0,2));

      // obstacles
      blocked.forEach(l=>{
        const kind = (Math.random()<0.55?'low':'high'); // low=jump, high=slide
        const obj = spawnObstacleVisual();
        obj.position.set(lanesX[l], 0.65, z0);
        scene.add(obj);
        game.entities.push({ type:'obst', lane:l, z:z0, obj, kind, dead:false });
      });

      // emojis
      coinLanes.forEach(l=>{
        const spr = makeEmojiSprite(EMOJIS[rndi(0,EMOJIS.length-1)]);
        spr.position.set(lanesX[l], 1.10, z0 - rnd(0,2.8));
        scene.add(spr);
        game.entities.push({ type:'coin', lane:l, z:spr.position.z, obj:spr });
      });

      // FOOD (more frequent)
      if(Math.random() < 0.28){
        const lane=rndi(0,2);
        const emo = FOOD[rndi(0,FOOD.length-1)];
        const spr = makeEmojiSprite(emo);
        spr.position.set(lanesX[lane], 1.15, z0 - rnd(1,6));
        spr.scale.set(0.82,0.82,1);
        scene.add(spr);
        game.entities.push({ type:'food', lane, z:spr.position.z, obj:spr, emo });
      }

      // VERTICAL RING (every now and then)
      if(Math.random() < 0.22){
        const lane=rndi(0,2);
        const ring = makeVerticalRing();
        // ‚úÖ low on road (but in piedi)
        ring.position.set(lanesX[lane], 0.55, z0 - rnd(2,8));
        scene.add(ring);
        game.entities.push({ type:'ring', lane, z:ring.position.z, obj:ring });
      }

      // Hearts: every 25 emoji (thicker / more frequent)
      // we spawn based on coin accumulation, but also random safety net
      if(game.coins > 0 && game.coins % 25 === 0 && Math.random() < 0.65){
        const lane=rndi(0,2);
        const spr = makeEmojiSprite(HEART_EMOJI);
        spr.position.set(lanesX[lane], 1.15, z0 - rnd(1,6));
        spr.scale.set(0.95,0.95,1);
        scene.add(spr);
        game.entities.push({ type:'heart', lane, z:spr.position.z, obj:spr });
      }
      // extra occasional heart
      if(Math.random() < 0.08){
        const lane=rndi(0,2);
        const spr = makeEmojiSprite(HEART_EMOJI);
        spr.position.set(lanesX[lane], 1.15, z0 - rnd(1,6));
        spr.scale.set(0.90,0.90,1);
        scene.add(spr);
        game.entities.push({ type:'heart', lane, z:spr.position.z, obj:spr });
      }
    }

    // ---------- Controls
    let tiltTarget=0, camRoll=0, camShake=0;
    function moveLane(dir){
      if(game.over||game.paused) return;
      game.targetLane = clamp(game.targetLane+dir,0,2);
      game.lane = game.targetLane;
      tiltTarget = clamp(tiltTarget + dir*0.18, -0.22, 0.22);
      sfx.lane();
    }
    function jump(){
      if(game.over||game.paused) return;
      if(!game.jumping && game.y>=-0.001){
        game.jumping=true;
        game.vy = -7.8;
        sfx.jump();
      }
    }
    function slide(){
      if(game.over||game.paused) return;
      game.sliding=true;
      game.slideT=0.50;
      sfx.slide();
    }

    window.addEventListener('keydown', (e)=>{
      const k=e.key.toLowerCase();
      if(k==='arrowleft') moveLane(-1);
      if(k==='arrowright') moveLane(1);
      if(k==='arrowup' || k===' ') jump();
      if(k==='arrowdown') slide();
      if(k==='p') togglePause();
      if(k==='r') { initAudio(); closeMenu(); resetRun(); }
    });

    let touchStart=null;
    renderer.domElement.addEventListener('pointerdown',(e)=>{
      initAudio();
      renderer.domElement.setPointerCapture(e.pointerId);
      touchStart={x:e.clientX,y:e.clientY,t:performance.now()};
    });
    renderer.domElement.addEventListener('pointerup',(e)=>{
      if(!touchStart) return;
      const dx=e.clientX-touchStart.x, dy=e.clientY-touchStart.y;
      const adx=Math.abs(dx), ady=Math.abs(dy);
      touchStart=null;
      const min=30;
      if(adx<min && ady<min) return;
      if(adx>ady) moveLane(dx>0?1:-1);
      else { if(dy<0) jump(); else slide(); }
    });

    startBtn.addEventListener('click', ()=>{ initAudio(); closeMenu(); resetRun(); });
    restartBtn.addEventListener('click', ()=>{ initAudio(); closeMenu(); resetRun(); });
    pauseBtn.addEventListener('click', ()=>{ initAudio(); togglePause(); });

    audioToggle.addEventListener('click', ()=>{
      initAudio();
      audioEnabled=!audioEnabled;
      toggleSwitch(audioSwitch,audioEnabled);
    });

    // ---------- Gameplay helpers
    function loseLife(){
      if(game.invincibleT > 0) return; // invincible
      game.lives = Math.max(0, game.lives-1);
      camShake = 0.25;
      sfx.hit();

      if(game.lives <= 0){
        game.over=true;
        game.paused=true;
        if(game.score>game.best){ game.best=Math.floor(game.score); saveBest(game.best); }
        openMenu();
        startBtn.textContent='üîÅ Riprova';
      }
    }

    function addLife(){
      game.lives = Math.min(game.maxLives, game.lives+1);
      sfx.boost();
    }

    function startSupercharge(type){
      // type: 'food' | 'ring'
      game.boostType = type;
      game.boostT = 10.0;
      game.invincibleT = Math.max(game.invincibleT, 10.0);
      bubble.visible = true;
      sfx.boost();
    }

    // ---------- Update loop
    let tPrev=performance.now();
    let stepTimer=0;

    // camera state
    let camZ = 9.6;
    let camY = 3.8;
    let camFov = 84;

    function update(dt, tNow){
      if(game.paused) return;

      // mild slowmo only while in air (NOT super slow)
      const inAir = (game.y < -0.01) || game.jumping;
      const slowmo = inAir ? 0.88 : 1.0;
      dt *= slowmo;

      // boosts timers
      if(game.boostT > 0){
        game.boostT -= dt;
        if(game.boostT <= 0){
          game.boostT = 0;
          game.boostType = null;
        }
      }
      if(game.invincibleT > 0){
        game.invincibleT -= dt;
        if(game.invincibleT <= 0){
          game.invincibleT = 0;
          bubble.visible = false;
        }
      }

      const boostOn = (game.boostT > 0);
      const speedMul = boostOn ? 3.0 : 1.0; // ‚úÖ TRIPLA velocit√† in supercarica
      const speed = game.baseSpeed * speedMul;

      // gravity
      const g=22.0;
      game.vy += g*dt;
      game.y  += game.vy*dt;
      if(game.y>0){ game.y=0; game.vy=0; game.jumping=false; }

      // slide timer
      if(game.sliding){
        game.slideT -= dt;
        if(game.slideT<=0) game.sliding=false;
      }

      // runner transform
      runner.position.x = lanesX[game.lane];
      runner.position.y = (-game.y);

      // slide makes runner horizontal-ish
      const slidePitchTarget = game.sliding ? -1.05 : 0.0;
      runner.rotation.x = lerp(runner.rotation.x, slidePitchTarget, 1 - Math.pow(0.0001, dt));
      runner.position.y += game.sliding ? -0.18 : 0.0;

      // runner scale: in boost smaller for visibility
      const targetScale = boostOn ? 0.78 : 1.0;
      runner.scale.setScalar(lerp(runner.scale.x, targetScale, 1 - Math.pow(0.0001, dt)));

      // contact shadow
      const h = runner.position.y;
      const s = 1.10 + clamp(h*0.65, 0, 0.85);
      contact.position.x = runner.position.x;
      contact.scale.set(s,s,1);
      contact.material.opacity = clamp(0.55 - h*0.24, 0.10, 0.55);

      // road scroll
      const scroll = speed*dt;
      dirtTex.offset.y -= scroll*0.085;

      for(const mesh of segments){
        mesh.position.z += scroll;
        if(mesh.position.z > segLen){
          mesh.position.z -= segLen*segCount;
        }
      }
      loopJungle(scroll);

      // spawn
      game.spawnT -= dt;
      if(game.spawnT<=0){
        spawnRow();
        game.spawnT = rnd(0.42, 0.78); // easier spacing
      }

      // move entities + MAGNET STRONG
      for(const e of game.entities){
        e.z += scroll;
        e.obj.position.z = e.z;

        // super magnet for pickups (coin/food/heart/ring)
        if(game.magnet && (e.type==='coin'||e.type==='food'||e.type==='heart'||e.type==='ring')){
          const dx = lanesX[game.lane] - e.obj.position.x;
          const dz = (0 - e.z);
          const dist = Math.hypot(dx*2.2, dz);
          if(dist < 12.0){
            // stronger pull
            e.obj.position.x += dx * dt * (5.2*(1-dist/12.0));
            if(e.obj.position.y < 1.1) e.obj.position.y += dt*0.6;
          }
        }
      }

      // despawn
      for(let i=game.entities.length-1;i>=0;i--){
        if(game.entities[i].z > 5.0){
          scene.remove(game.entities[i].obj);
          game.entities.splice(i,1);
        }
      }

      // collisions
      const px = runner.position.x;
      const py = runner.position.y + (game.sliding ? 0.70 : 0.95);

      for(let i=game.entities.length-1;i>=0;i--){
        const e=game.entities[i];

        const dz=Math.abs(e.z - 0.25);
        const dx=Math.abs(e.obj.position.x - px);
        const dy=Math.abs(e.obj.position.y - py);

        // base hitbox
        const hit = (dz < 0.75 && dx < 0.60 && dy < 1.05);
        if(!hit) continue;

        if(e.type==='coin'){
          game.coins += 1;
          game.score += 28;
          scene.remove(e.obj); game.entities.splice(i,1);
          sfx.coin();
          continue;
        }

        if(e.type==='food'){
          game.foodCount += 1;
          game.foodHistory.push(e.emo);
          refreshFoodUI();
          scene.remove(e.obj); game.entities.splice(i,1);
          sfx.food();

          // 10 food => supercharge + reset food counter immediately
          if(game.foodCount >= 10){
            startSupercharge('food');
            game.foodCount = 0;
            game.foodHistory = [];
            refreshFoodUI();
          }
          continue;
        }

        if(e.type==='heart'){
          if(game.lives < game.maxLives) addLife();
          scene.remove(e.obj); game.entities.splice(i,1);
          continue;
        }

        if(e.type==='ring'){
          // ‚úÖ Ring counts ONLY if sliding (pass through)
          if(game.sliding){
            game.ringCount += 1;
            scene.remove(e.obj); game.entities.splice(i,1);
            sfx.ring();

            if(game.ringCount >= 10){
              startSupercharge('ring');
              game.ringCount = 0; // ‚úÖ reset so you can collect again during boost
            }
          }
          continue;
        }

        if(e.type==='obst'){
          let mustHit=false;
          if(e.kind==='low'  && !game.jumping && game.y===0) mustHit=true;
          if(e.kind==='high' && !game.sliding) mustHit=true;

          if(mustHit){
            // if invincible, destroy obstacle instead
            if(game.invincibleT > 0){
              scene.remove(e.obj); game.entities.splice(i,1);
              camShake = 0.12;
            }else{
              scene.remove(e.obj); game.entities.splice(i,1);
              loseLife();
            }
          }
        }
      }

      // score tick (no acceleration over time)
      game.score += (18 * speedMul) * dt;

      if(game.score>game.best){ game.best=Math.floor(game.score); saveBest(game.best); }

      // HUD
      scoreEl.textContent = String(Math.floor(game.score));
      coinsEl.textContent = String(game.coins);
      bestEl.textContent  = String(game.best);
      bestBig.textContent = String(game.best);
      ringsEl.textContent = String(game.ringCount);

      hpTxt.textContent = hpString();

      // boost UI
      if(boostOn){
        const icon = (game.boostType==='ring') ? "‚≠ïÔ∏è" : "üçî";
        const name = (game.boostType==='ring') ? "RING BOOST" : "FOOD BOOST";
        setBoostUI(true, icon, name, game.boostT, 10.0);
      }else{
        setBoostUI(false);
      }

      // motion feel
      tiltTarget *= 0.92;
      camRoll = camRoll*0.90 + tiltTarget*0.10;
      camShake = Math.max(0, camShake - dt*0.9);

      // bubble pulse
      if(bubble.visible){
        bubble.material.opacity = 0.18 + 0.08*Math.sin(tNow*0.01);
      }
    }

    function animate(tNow){
      const dt=Math.min(0.033,(tNow-tPrev)/1000);
      tPrev=tNow;

      update(dt,tNow);

      const inAir = (game.y < -0.01) || game.jumping;
      const boostOn = (game.boostT > 0);

      // ===== CAMERA: player pi√π in basso + pi√π visibilit√† =====
      const targetFov = boostOn ? 94 : (inAir ? 78 : 86);
      const targetZ   = boostOn ? 10.6 : (inAir ? 9.4 : 9.9);
      const targetY   = boostOn ? 4.05 : (inAir ? 3.70 : 3.90);

      camFov = lerp(camFov, targetFov, 0.08);
      camZ   = lerp(camZ,   targetZ,   0.08);
      camY   = lerp(camY,   targetY,   0.08);

      camera.fov = camFov;
      camera.updateProjectionMatrix();

      const bob = Math.sin(tNow*0.0022) * 0.01;
      camera.position.set(0, camY + bob, camZ);

      const sx = (Math.sin(tNow*0.031)+Math.sin(tNow*0.017))*0.02*camShake;
      const sy = (Math.sin(tNow*0.027))*0.015*camShake;
      camera.position.x += sx;
      camera.position.y += sy;

      camera.rotation.z = camRoll;

      // guarda molto avanti e un filo pi√π in basso => player scende nello schermo
      camera.lookAt(0, 0.45, -15.5);

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    function onResize(){
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onResize);

    // menu + boot
    (async ()=>{
      // init UI
      refreshFoodUI();
      hpTxt.textContent = hpString();
      openMenu();
      requestAnimationFrame(animate);
    })();
  </script>
</body>
</html>